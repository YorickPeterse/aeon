# Extensions for the `Int` type that can only be defined later on in the
# bootstrapping process.
import std::error::StandardError
import std::loop::(repeat)
import std::process::(panic)
import std::range::(Range, ToRange)
import std::string_buffer::StringBuffer

extern def string_to_integer(string: ref String, radix: ref Int) -> Int

impl Int {
  # Parses an `Int` from a `String` in a given base.
  #
  # # Panics
  #
  # This method panics if `radix` isn't within the range `2..36`.
  #
  # # Format
  #
  # The `String` is expected to start with an optional `+` or `-` sign,
  # followed by one or more digits. Digits are a subset of the following
  # ranges, depending on the value of the `radix` argument:
  #
  # * 0-9
  # * a-z
  # * A-Z
  #
  # Leading and/or trailing whitespace is considered to be invalid, and will
  # result in an error being thrown.
  #
  # # Examples
  #
  # Parsing a `String` into a base 2 `Int`:
  #
  #     try! Int.parse(string: '11', radix: 2) # => 3
  #
  # Parsing a `String` into a base 8 `Int`:
  #
  #     try! Int.parse(string: '0o52', radix: 8) # => 42
  #
  # Parsing a `String` into a base 10 `Int`:
  #
  #     try! Int.parse(string: '10', radix: 10) # => 10
  #
  # Parsing a `String` into a base 16 `Int`:
  #
  #     try! Int.parse(string: 'F', radix: 16) # => 15
  static def parse(
    string: ref String,
    radix: Int
  ) !! StandardError -> Int {
    try {
      string_to_integer(string, radix)
    } else (error) {
      throw StandardError.new(error as String)
    }
  }

  # Formats `self` as a `String` using the given base/radix.
  #
  # # Panics
  #
  # This method panics if `radix` isn't within the range `2..36`.
  #
  # # Examples
  #
  # Formatting an integer in base 16 (hexadecimal):
  #
  #     0x2ff.format(radix: 16) # => '2ff'
  def format(radix: Int) -> String {
    if radix < 2 or radix > 36 {
      panic('The radix argument must be between 2 and 36')
    }

    if zero? { return '0' }

    let characters = Array.new
    let mut integer = absolute

    while integer.positive? {
      let digit = match integer % radix {
        0 -> { '0' }
        1 -> { '1' }
        2 -> { '2' }
        3 -> { '3' }
        4 -> { '4' }
        5 -> { '5' }
        6 -> { '6' }
        7 -> { '7' }
        8 -> { '8' }
        9 -> { '9' }
        10 -> { 'a' }
        11 -> { 'b' }
        12 -> { 'c' }
        13 -> { 'd' }
        14 -> { 'e' }
        15 -> { 'f' }
        16 -> { 'g' }
        17 -> { 'h' }
        18 -> { 'i' }
        19 -> { 'j' }
        20 -> { 'k' }
        21 -> { 'l' }
        22 -> { 'm' }
        23 -> { 'n' }
        24 -> { 'o' }
        25 -> { 'p' }
        26 -> { 'q' }
        27 -> { 'r' }
        28 -> { 's' }
        29 -> { 't' }
        30 -> { 'u' }
        31 -> { 'v' }
        32 -> { 'w' }
        33 -> { 'x' }
        34 -> { 'y' }
        else -> { 'z' }
      }

      characters.push(digit)
      integer /= radix
    }

    if negative? { characters.push('-') }

    # The above operation pushes the digits from the back, resulting in our
    # characters being in reverse order. For example, for 0x2ff the `characters`
    # `Array` would be `['f', 'f', '2']`.
    let sorted = Array.new

    loop {
      sorted.push(try characters.pop.get else break)
    }

    StringBuffer.from_array(sorted).to_string
  }

  # Returns an `Iterator` that iterates from `0` up to the value of `self`.
  #
  # # Examples
  #
  # Iterating from `0` to `10`:
  #
  #     4.times.to_array # => Array.new(0, 1, 2, 3)
  move def times => Int {
    repeat(self) do (index) { yield index }
  }
}

impl ToRange!(Int) for Int {
  # Returns a `Range` starting at `self` up to (and including) `other`.
  #
  # # Examples
  #
  # Creating a `Range`:
  #
  #     let range = 1..10
  #
  #     range.start # => 1
  #     range.end   # => 10
  move def ..(other: Int) -> Range!(Int) {
    Range.new(start: self, end: other)
  }
}
