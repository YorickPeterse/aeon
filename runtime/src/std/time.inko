# Types and methods for dealing with time.
import std::conversion::(ToFloat, ToInt)
import std::operators::(
  Add, Equal, Greater, GreaterOrEqual, Smaller, SmallerOrEqual, Subtract
)
import std::process::(panic)
import std::time::bits::*

extern def time_monotonic -> Float
extern def time_system -> Float
extern def time_offset -> Int

# A span of time measured in seconds.
#
# A `Duration` can be used to measure the span of time without having to worry
# about casting the time to different scales yourself. A `Duration` can be
# created using various scales such as seconds and milliseconds.
class Duration {
  # The number of seconds (including fractional seconds) of this `Duration`.
  @seconds: Float

  # Creates a new `Duration` from the given number of seconds.
  #
  # # Examples
  #
  # Creating a `Duration` using an `Int`:
  #
  #     import std::time::Duration
  #
  #     Duration.from_seconds(10)
  #
  # Creating a `Duration` using a `Float`:
  #
  #     import std::time::Duration
  #
  #     Duration.from_seconds(10.5)
  static def from_seconds(seconds: ToFloat) -> Duration {
    new(seconds.to_float)
  }

  # Creates a new `Duration` from the given number of milliseconds.
  #
  # # Examples
  #
  # Creating a `Duration` using an `Int`:
  #
  #     import std::time::Duration
  #
  #     Duration.from_milliseconds(10)
  #
  # Creating a `Duration` using a `Float`:
  #
  #     import std::time::Duration
  #
  #     Duration.from_milliseconds(10.5)
  static def from_milliseconds(milliseconds: ToFloat) -> Duration {
    new(milliseconds.to_float / MILLISEC_TO_SEC)
  }

  # Creates a new `Duration` from the given number of nanoseconds.
  #
  # # Examples
  #
  # Creating a `Duration` using an `Int`:
  #
  #     import std::time::Duration
  #
  #     Duration.from_nanoseconds(10)
  #
  # Creating a `Duration` using a `Float`:
  #
  #     import std::time::Duration
  #
  #     Duration.from_nanoseconds(10.5)
  static def from_nanoseconds(nanoseconds: ToFloat) -> Duration {
    new(nanoseconds.to_float / NANOSEC_TO_SEC)
  }

  static def new(seconds: Float) -> Self {
    Self { @seconds = seconds }
  }

  # Returns the duration in seconds.
  #
  # # Examples
  #
  # Getting the seconds in a `Duration`:
  #
  #     import std::time::Duration
  #
  #     Duration.from_seconds(5).to_seconds # => 5.0
  def to_seconds -> Float {
    @seconds.clone
  }

  # Returns the duration in milliseconds.
  #
  # # Examples
  #
  # Getting the milliseconds in a `Duration`:
  #
  #     import std::time::Duration
  #
  #     Duration.from_seconds(5).to_milliseconds # => 5000.0
  def to_milliseconds -> Float {
    @seconds * MILLISEC_TO_SEC
  }

  # Returns the duration in microseconds.
  #
  # # Examples
  #
  # Getting the microseconds in a `Duration`:
  #
  #     import std::time::Duration
  #
  #     Duration.from_seconds(5).to_microseconds # => 5000000.0
  def to_microseconds -> Float {
    @seconds * MICROSEC_TO_SEC
  }

  # Returns the duration in nanoseconds.
  #
  # # Examples
  #
  # Getting the nanoseconds in a `Duration`:
  #
  #     import std::time::Duration
  #
  #     Duration.from_seconds(5).to_nanoseconds # => 5000000000.0
  def to_nanoseconds -> Float {
    @seconds * NANOSEC_TO_SEC
  }
}

impl ToInt for Duration {
  # Returns the number of seconds in the `Duration`.
  def to_int -> Int {
    @seconds.to_int
  }
}

impl ToFloat for Duration {
  # Returns the number of seconds in the `Duration`.
  def to_float -> Float {
    @seconds.clone
  }
}

impl Add!(Self) for Duration {
  # Adds two `Duration` objects together.
  #
  # # Examples
  #
  # Adding two `Duration` objects:
  #
  #     import std::time::Duration
  #
  #     let sum = Duration.from_seconds(5) + Duration.from_seconds(2)
  #
  #     sum.to_seconds # => 7.0
  def +(other: ref Self) -> Self {
    Duration.new(@seconds + other.to_seconds)
  }
}

impl Subtract!(Self) for Duration {
  # Subtracts the given `Duration` from `self`.
  #
  # # Examples
  #
  # Subtracting a `Duration` from another `Duration`
  #
  #     import std::time::Duration
  #
  #     let diff = Duration.from_seconds(5) - Duration.from_seconds(2)
  #
  #     diff.to_seconds # => 3.0
  def -(other: ref Self) -> Self {
    Duration.new(@seconds - other.to_seconds)
  }
}

impl Smaller for Duration {
  # Returns `True` if `self` is smaller than the given `Duration`.
  #
  # # Examples
  #
  # Comparing two `Duration` objects:
  #
  #     import std::time::Duration
  #
  #     Duration.from_seconds(5) < Duration.from_seconds(10) # => True
  def <(other: ref Self) -> Boolean {
    @seconds < other.to_seconds
  }
}

impl Greater for Duration {
  # Returns `True` if `self` is greater than the given `Duration`.
  #
  # # Examples
  #
  # Comparing two `Duration` objects:
  #
  #     import std::time::Duration
  #
  #     Duration.from_seconds(5) > Duration.from_seconds(10) # => False
  def >(other: ref Self) -> Boolean {
    @seconds > other.to_seconds
  }
}

impl SmallerOrEqual for Duration {
  # Returns `True` if `self` is smaller than or equal to the given `Duration`.
  #
  # # Examples
  #
  # Comparing two `Duration` objects:
  #
  #     import std::time::Duration
  #
  #     Duration.from_seconds(5) <= Duration.from_seconds(10) # => True
  #     Duration.from_seconds(5) <= Duration.from_seconds(5)  # => True
  def <=(other: ref Self) -> Boolean {
    @seconds <= other.to_seconds
  }
}

impl GreaterOrEqual for Duration {
  # Returns `True` if `self` is greater than or equal to the given `Duration`.
  #
  # # Examples
  #
  # Comparing two `Duration` objects:
  #
  #     import std::time::Duration
  #
  #     Duration.from_seconds(5) >= Duration.from_seconds(10) # => False
  #     Duration.from_seconds(5) >= Duration.from_seconds(5)  # => True
  def >=(other: ref Self) -> Boolean {
    @seconds >= other.to_seconds
  }
}

# An object representing the current system time.
#
# A `DateTime` object represents the current system in seconds relative to
# the Unix epoch. Due to the use of the system clock an instance of
# `DateTime` can be influenced by time zone changes, clock adjustments, or
# leap seconds. If you need a monotonically increasing clock you should use
# `Instant` instead.
class DateTime {
  # The year of this `DateTime`.
  @year: Int

  # The month of this `DateTime`, from `1` to `12`.
  @month: Int

  # The day of this `DateTime`, from `1` to `31`.
  @day: Int

  # The hour of this `DateTime`, from `0` to `23`.
  @hour: Int

  # The minute of this `DateTime`, from `0` to `59`.
  @minute: Int

  # The second of this `DateTime`, from `0` to `59`.
  @second: Int

  # The sub seconds of this `DateTime`.
  @sub_second: Float

  # The UTC offset (in seconds) of this `DateTime`.
  @utc_offset: Int

  # Returns a new `DateTime` representing the current time using the local
  # timezone.
  #
  # # Examples
  #
  # Getting the current time:
  #
  #     import std::time::DateTime
  #
  #     DateTime.now
  static def now -> DateTime {
    from_timestamp(time: time_system, utc_offset: time_offset)
  }

  # Returns a new `DateTime` representing the current time using UTC as the
  # timezone.
  #
  # # Examples
  #
  # Getting the current time in UTC:
  #
  #     import std::time::DateTime
  #
  #     DateTime.utc
  static def utc -> DateTime {
    from_utc_timestamp(time_system)
  }

  # Returns a new `DateTime` from a Unix timestamp and UTC offset.
  static def from_timestamp(
    time: ToFloat,
    utc_offset: Int,
  ) -> DateTime {
    # The algorithm below is based on the following code from the musl standard
    # library: http://git.musl-libc.org/cgit/musl/tree/src/time/__secs_to_tm.c.
    # Notable changes compared to the original algorithm:
    #
    # * Overflow checking has been removed because this is not necessary in
    #   Inko.
    # * Checking for negative results produced by the `%` has been removed
    #   because in Inko this operator is the modulo operator and not the
    #   remainder operator, thus it won't produce negative values in the code
    #   below.
    # * Calculating the day of the week and the year of the day has been removed
    #   because we don't explicitly store this anywhere.
    # * Documentation has been added in various places and variables have more
    #   human friendly names.
    #
    # When looking at the code keep in mind that the algorithm uses March 1st,
    # 2000 UTC as the epoch and _not_ January 1st, 1970 UTC. Using March 1st
    # simplifies some of the calculations, especially when dealing with leap
    # years. This epoch is internal and not exposed to the public API.
    #
    # Because musl is licensed under the MIT license we include a copy of the
    # license here:
    #
    #     Copyright Â© 2005-2014 Rich Felker, et al.
    #
    #     Permission is hereby granted, free of charge, to any person obtaining
    #     a copy of this software and associated documentation files (the
    #     "Software"), to deal in the Software without restriction, including
    #     without limitation the rights to use, copy, modify, merge, publish,
    #     distribute, sublicense, and/or sell copies of the Software, and to
    #     permit persons to whom the Software is furnished to do so, subject to
    #     the following conditions:
    #
    #     The above copyright notice and this permission notice shall be
    #     included in all copies or substantial portions of the Software.
    #
    #     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
    #     EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    #     MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
    #     IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
    #     CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
    #     TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
    #     SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

    # Unix timestamps are in UTC. Thus if we want to correctly calculate the
    # _local_ time we need to add the offset to the timestamp before we
    # decompose it.
    let local_time = time.to_float + utc_offset.to_float
    let local_time_int = local_time.to_int

    let mut year = 0
    let mut month = 0
    let mut day = 0
    let mut hour = 0
    let mut minute = 0
    let mut second = 0
    let mut sub_second = local_time.fractional

    let secs = local_time_int - EPOCH
    let days = secs / SECS_PER_DAY
    let rem_secs = secs % SECS_PER_DAY
    let quadrennial_century_cycles = days / DAYS_PER_400Y
    let mut rem_days = days % DAYS_PER_400Y
    let mut century_cycles = rem_days / DAYS_PER_100Y

    if century_cycles == 4 { century_cycles -= 1 }

    rem_days -= century_cycles * DAYS_PER_100Y

    let mut quadrennial_cycles = rem_days / DAYS_PER_4Y

    # 25 cycles == 100 years
    if quadrennial_cycles == 25 { quadrennial_cycles -= 1 }

    rem_days -= quadrennial_cycles * DAYS_PER_4Y

    let mut rem_years = rem_days / DAYS_PER_NORMAL_YEAR

    if rem_years == 4 { rem_years -= 1 }

    rem_days -= rem_years * DAYS_PER_NORMAL_YEAR

    # Calculate the number of years since 2000, then convert this to the current
    # year (e.g. 2018 instead of 18).
    let years = (rem_years + (4 * quadrennial_cycles))
      + (100 * century_cycles)
      + (400 * quadrennial_century_cycles)
      + EPOCH_YEAR

    let mut months = 0

    while days_in_month(months) <= rem_days {
      rem_days -= days_in_month(months)
      months += 1
    }

    year = years

    # We add two to adjust for January and February (since our epoch starts in
    # March).
    month = months + 2

    if month >= MONTHS_PER_YEAR {
      month = month - MONTHS_PER_YEAR
      year = year + 1
    }

    # Per ISO 8601 the first month of the year is 1, and so is the first day of
    # the month.
    month = month + 1
    day = rem_days + 1

    hour = rem_secs / SECS_PER_HOUR
    minute = rem_secs / SECS_PER_MIN % SECS_PER_MIN
    second = rem_secs % SECS_PER_MIN

    new(
      year: year,
      month: month,
      day: day,
      hour: hour,
      minute: minute,
      second: second,
      sub_second: sub_second,
      utc_offset: utc_offset
    )
  }

  # Returns a new `DateTime` from a Unix timestamp using UTC as the timezone.
  static def from_utc_timestamp(time: ToFloat) -> DateTime {
    from_timestamp(time, utc_offset: 0)
  }

  static def new(
    year: Int,
    month: Int,
    day: Int,
    hour: Int,
    minute: Int,
    second: Int,
    sub_second: Float,
    utc_offset: Int
  ) -> Self {
    Self {
      @year = year,
      @month = month,
      @day = day,
      @hour = hour,
      @minute = minute,
      @second = second,
      @sub_second = sub_second,
      @utc_offset = utc_offset
    }
  }

  # Returns the hour of the day from 0 to 23.
  def hour -> Int {
    @hour.clone
  }

  # Returns the minute of the hour from 0 to 59.
  def minute -> Int {
    @minute.clone
  }

  # Returns the second of the minute from 0 to 60.
  def second -> Int {
    @second.clone
  }

  # Returns the fractional part of the second, in seconds.
  def sub_second -> Float {
    @sub_second.clone
  }

  # Returns the year of the current time.
  def year -> Int {
    @year.clone
  }

  # Returns the month of the year from 1 to 12.
  def month -> Int {
    @month.clone
  }

  # Returns the day of the month from 1 to 31.
  def day -> Int {
    @day.clone
  }

  # Returns the day of the week from 1 to 7.
  #
  # Per ISO 8601 the first day of the week starts on Monday, not Sunday.
  def day_of_week -> Int {
    # January 1st, 1970 (our anchor date) was on a Thursday. We add 3 so that
    # Monday (3 days before Thursday) becomes the anchor date.
    #
    # We later on add 1 since the % operator will return 0 for Monday (since its
    # the first value in the range), but week days range from 1 to 7; not 0 to
    # 6.
    #
    # The following table should help illustrate this:
    #
    # | Date       | Day of week | days_since_unix_epoch
    # |:-----------|:------------|:----------------------
    # | 1969-12-29 | Monday      | -3
    # | 1969-12-30 | Tuesday     | -2
    # | 1969-12-31 | Wednesday   | -1
    # | 1970-01-01 | Thursday    | 0
    # | 1970-01-02 | Friday      | 1
    # | 1970-01-03 | Saturday    | 2
    # | 1970-01-04 | Sunday      | 3
    #
    # For these dates, the calculations would be as follows:
    #
    # | Date       | Calculation        | Simplified  | Return value
    # |:-----------|:-------------------|:------------|:------------
    # | 1969-12-29 | ((-3 + 3) % 7) + 1 | (0 % 7) + 1 | 1
    # | 1969-12-30 | ((-2 + 3) % 7) + 1 | (1 % 7) + 1 | 2
    # | 1969-12-31 | ((-1 + 3) % 7) + 1 | (2 % 7) + 1 | 3
    # | 1970-01-01 | ((0 + 3) % 7) + 1  | (3 % 7) + 1 | 4
    # | 1970-01-02 | ((1 + 3) % 7) + 1  | (4 % 7) + 1 | 5
    # | 1970-01-03 | ((2 + 3) % 7) + 1  | (5 % 7) + 1 | 6
    # | 1970-01-04 | ((3 + 3) % 7) + 1  | (6 % 7) + 1 | 7
    days_since_unix_epoch + 3
      % DAYS_PER_WEEK
      + 1
  }

  # Returns the day of the year from 1 to 366 for leap years, and from 1 to 365
  # for regular years.
  def day_of_year -> Int {
    days_since_january(month: month - 1, leap: leap_year?) + day
  }

  # Returns the number of days between `self` and the Unix epoch.
  #
  # The returned `Int` is negative if `self` is before the Unix epoch, and
  # positive for a value that is on or after the Unix epoch.
  def days_since_unix_epoch -> Int {
    let years = (year - UNIX_EPOCH_YEAR).absolute
    let leap_days = (years / 4)
      - (years / 100)
      + (years / 400)

    # The number of days since the Unix epoch, up until the first day of the
    # year.
    let days_until_year_start = years
      * DAYS_PER_NORMAL_YEAR
      + leap_days

    # The number of days since the start of this year, with a value of 0
    # representing the first day of the year.
    let days_since_year_start = day_of_year - 1

    if before_unix_epoch? {
      0 - (days_until_year_start - days_since_year_start)
    } else {
      days_until_year_start + days_since_year_start
    }
  }

  # Returns `True` if the year in `self` comes before the Unix epoch.
  def before_unix_epoch? -> Boolean {
    year < UNIX_EPOCH_YEAR
  }

  # Returns `True` if the current year is a leap year.
  def leap_year? -> Boolean {
    let year = @year

    (year % 4).zero? and ((year % 100).positive? or (year % 400).zero?)
  }

  # Returns the offset in seconds relative to UTC.
  def utc_offset -> Int {
    @utc_offset.clone
  }

  # Returns `True` if UTC is used.
  def utc? -> Boolean {
    utc_offset == 0
  }

  # Returns the number of seconds since the Unix epoch in UTC.
  #
  # This value will be negative if `self` is a `DateTime` before the Unix
  # epoch.
  def seconds_since_unix_epoch -> Int {
    let day_sec = days_since_unix_epoch.absolute * SECS_PER_DAY
    let time_sec = (hour * SECS_PER_HOUR) + (minute * SECS_PER_MIN) + second
    let seconds = if before_unix_epoch? {
      0 - (day_sec - time_sec)
    } else {
      day_sec + time_sec
    }

    # Timestamps are always in UTC, not in the local time.
    seconds - utc_offset
  }

  # Converts the `DateTime` to another `DateTime` that uses UTC as the
  # timezone.
  def to_utc -> Self {
    DateTime.from_utc_timestamp(to_float)
  }
}

impl ToInt for DateTime {
  # Returns the timestamp since the Unix epoch.
  def to_int -> Int {
    seconds_since_unix_epoch
  }
}

impl ToFloat for DateTime {
  # Returns the timestamp since the Unix epoch, the including fractional
  # seconds.
  def to_float -> Float {
    seconds_since_unix_epoch.to_float + sub_second
  }
}

impl Add!(Duration) for DateTime {
  # Adds the given number of seconds to `self`, returning the result as a new
  # `DateTime`.
  #
  # # Examples
  #
  # Adding a `Duration` to a `DateTime`:
  #
  #     import std::time::(Duration, DateTime)
  #
  #     DateTime.now + Duration.from_seconds(5)
  def +(other: ref Duration) -> Self {
    let timestamp = to_float + other.to_float

    if utc? {
      DateTime.from_utc_timestamp(timestamp)
    } else {
      DateTime.from_timestamp(time: timestamp, utc_offset: utc_offset)
    }
  }
}

impl Subtract!(Duration) for DateTime {
  # Subtracts the given number of seconds from `self`, returning the result as
  # a new `DateTime`.
  #
  # # Examples
  #
  # Subtracting a `Duration` from a `DateTime`:
  #
  #     import std::time::(Duration, DateTime)
  #
  #     DateTime.now - Duration.from_seconds(5)
  def -(other: ref Duration) -> Self {
    let timestamp = to_float - other.to_float

    if utc? {
      DateTime.from_utc_timestamp(timestamp)
    } else {
      DateTime.from_timestamp(time: timestamp, utc_offset: utc_offset)
    }
  }
}

impl Smaller for DateTime {
  # Returns `True` if `self` is smaller than the given `DateTime`.
  #
  # # Examples
  #
  # Comparing two `DateTime` objects:
  #
  #     import std::time::DateTime
  #
  #     let before = DateTime.now
  #     let after = before + 5
  #
  #     before < after # => True
  def <(other: ref Self) -> Boolean {
    to_float < other.to_float
  }
}

impl SmallerOrEqual for DateTime {
  # Returns `True` if `self` is smaller than or equal to the given
  # `DateTime`.
  #
  # # Examples
  #
  # Comparing two `DateTime` objects:
  #
  #     import std::time::DateTime
  #
  #     let before = DateTime.now
  #     let after = before + 5
  #
  #     before <= after  # => True
  #     before <= before # => True
  def <=(other: ref Self) -> Boolean {
    to_float <= other.to_float
  }
}

impl Greater for DateTime {
  # Returns `True` if `self` is greater than the given `DateTime`.
  #
  # # Examples
  #
  # Comparing two `DateTime` objects:
  #
  #     import std::time::DateTime
  #
  #     let before = DateTime.now
  #     let after = before + 5
  #
  #     after > before # => True
  def >(other: ref Self) -> Boolean {
    to_float > other.to_float
  }
}

impl GreaterOrEqual for DateTime {
  # Returns `True` if `self` is greater than or equal to the given
  # `DateTime`.
  #
  # # Examples
  #
  # Comparing two `DateTime` objects:
  #
  #     import std::time::DateTime
  #
  #     let before = DateTime.now
  #     let after = before + 5
  #
  #     after >= before # => True
  #     after >= after  # => True
  def >=(other: ref Self) -> Boolean {
    to_float >= other.to_float
  }
}

impl Equal for DateTime {
  # Returns `True` if `self` and the given `DateTime` are equal to each
  # other.
  #
  # # Examples
  #
  # Comparing two `DateTime` objects:
  #
  #     import std::time::DateTime
  #
  #     let now = DateTime.now
  #
  #     now == now # => True
  def ==(other: ref Self) -> Boolean {
    to_float == other.to_float
  }
}

# A monotonically increasing clock.
#
# `Instant` objects represent the number of seconds relative to an unspecified
# epoch. Unlike a system clock a monotonic clock never decreases, making it
# useful for tasks such as measuring the execution time of a block of code.
class Instant {
  # The (internal) timestamp of this `Instant`.
  @time: Float

  # Returns a new `Instant` representing the current time.
  static def now -> Self {
    Self { @time = time_monotonic }
  }

  # Returns a new `Instant` at the given offset.
  static def new(time: Float) -> Self {
    Self { @time = time }
  }

  # Returns a `Duration` measuring the time elapsed since the point in time
  # that `self` represents.
  #
  # # Examples
  #
  # Obtaining the time elapsed:
  #
  #     import std::process
  #     import std::time::(Duration, Instant)
  #
  #     let start = Instant.new
  #
  #     process.suspend(Duration.from_seconds(1))
  #
  #     start.elapsed.to_int # => 1
  def elapsed -> Duration {
    Duration.new(time_monotonic - @time)
  }
}

impl ToInt for Instant {
  # Returns the number of seconds since the epoch.
  def to_int -> Int {
    @time.to_int
  }
}

impl ToFloat for Instant {
  # Returns the number of seconds since the epoch.
  def to_float -> Float {
    @time.clone
  }
}

impl Add!(Duration) for Instant {
  # Adds the given number of seconds to `self`, returning the result as a new
  # `Instant`.
  #
  # # Examples
  #
  # Adding a `Duration` to a `Instant`:
  #
  #     import std::time::(Duration, Instant)
  #
  #     Instant.now + Duration.from_seconds(5)
  def +(other: ref Duration) -> Self {
    Instant { @time = @time + other.to_float }
  }
}

impl Subtract!(Duration) for Instant {
  # Subtracts the given number of seconds from `self`, returning the result as
  # a new `Instant`.
  #
  # Subtracting a `Duration` from a `Instant`:
  #
  #     import std::time::(Duration, Instant)
  #
  #     Instant.now - Duration.from_seconds(5)
  def -(other: ref Duration) -> Self {
    Instant { @time = @time - other.to_float }
  }
}

impl Smaller for Instant {
  # Returns `True` if `self` is smaller than the given `Instant`.
  #
  # # Examples
  #
  # Comparing two `Instant` objects:
  #
  #     import std::time::(Duration, Instant)
  #
  #     let before = Instant.new
  #     let after = before + Duration.from_seconds(5)
  #
  #     before < after # => True
  def <(other: ref Self) -> Boolean {
    @time < other.to_float
  }
}

impl SmallerOrEqual for Instant {
  # Returns `True` if `self` is smaller than or equal to the given
  # `Instant`.
  #
  # # Examples
  #
  # Comparing two `Instant` objects:
  #
  #     import std::time::(Duration, Instant)
  #
  #     let before = Instant.new
  #     let after = before + Duration.from_seconds(5)
  #
  #     before <= after  # => True
  #     before <= before # => True
  def <=(other: ref Self) -> Boolean {
    @time <= other.to_float
  }
}

impl Greater for Instant {
  # Returns `True` if `self` is greater than the given `Instant`.
  #
  # # Examples
  #
  # Comparing two `Instant` objects:
  #
  #     import std::time::(Duration, Instant)
  #
  #     let before = Instant.new
  #     let after = before + Duration.from_seconds(5)
  #
  #     after > before # => True
  def >(other: ref Self) -> Boolean {
    @time > other.to_float
  }
}

impl GreaterOrEqual for Instant {
  # Returns `True` if `self` is greater than or equal to the given
  # `Instant`.
  #
  # # Examples
  #
  # Comparing two `Instant` objects:
  #
  #     import std::time::(Duration, Instant)
  #
  #     let before = Instant.new
  #     let after = before + Duration.from_seconds(5)
  #
  #     after >= before # => True
  #     after >= after  # => True
  def >=(other: ref Self) -> Boolean {
    @time >= other.to_float
  }
}

impl Equal  for Instant {
  # Returns `True` if `self` is equal to the given `Instant`.
  #
  # # Examples
  #
  # Comparing two `Instant` objects:
  #
  #     import std::time::Instant
  #
  #     Instant.now == Instant.now
  def ==(other: ref Self) -> Boolean {
    @time == other.to_float
  }
}
