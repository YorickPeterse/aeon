# Symbols and symbol tables for mapping names to types and other information.
import std::index::Index
import std::length::Length
import std::map::Map
import std::option::Option

# Information of a single symbol, such as an identifier or a constant.
class Symbol!(T) {
  # The name of the symbol.
  @name: String

  # The ID of the symbol, unique to the table it is defined in.
  @id: Int

  # The type of the symbol.
  @type: T

  # If the symbol is mutable or not.
  @mutable: Boolean

  static def new(name: String, id: Int, type: T, mutable: Boolean) -> Self {
    Self { @name = name, @id = id, @type = type, @mutable = mutable }
  }

  def name -> String {
    @name.clone
  }

  def id -> Int {
    @id.clone
  }

  def type -> ref T {
    @type
  }

  def mutable? -> Boolean {
    @mutable.clone
  }
}

# A collection of symbols and associated information such as their types, mapped
# to their names.
class SymbolTable!(T) {
  # An array of the symbols in the order they are defined in.
  @symbols: Array!(Symbol!(T))

  # The names of the symbols and Symbol instances.
  @mapping: Map!(String, ref Symbol!(T))

  static def new -> Self {
    Self { @mapping = Map.new, @symbols = Array.new }
  }

  # Defines a new symbol with the given type.
  def define(name: String, type: T, mutable: Boolean) -> ref Symbol!(T) {
    let id_opt = @mapping.get(name).map do (sym) { sym.id }
    let update = id_opt.some?
    let id = try id_opt.get else @mapping.length
    let symbol = Symbol.new(name: name, id: id, type: type, mutable: mutable)

    if update { @symbols[id] = symbol } else { @symbols.push(symbol) }

    let sym_ref = @symbols[id]

    @mapping[name] = sym_ref

    sym_ref
  }

  # Returns `True` if a symbol is defined for the given name.
  def defines?(name: String) -> Boolean {
    @mapping.key?(name)
  }

  # Returns `True` if the symbol table contains the given symbol.
  def contains?(symbol: Symbol!(T)) -> Boolean {
    try {
      @symbols.get(symbol.id).map do (ours) { ours.same_object?(symbol) }.get
    } else {
      False
    }
  }

  # Returns all the symbols defined.
  def symbols -> ref Array!(Symbol!(T)) {
    @symbols
  }

  # Yields references to the symbols in this table.
  def iter => ref Symbol!(T) {
    for sym in @symbols.iter { yield sym }
  }

  def get(name: String) -> ?ref Symbol!(T) {
    @mapping.get(name)
  }
}

impl Index!(String, ref Symbol!(T)) for SymbolTable {
  def [](index: String) -> ref Symbol!(T) {
    @mapping[index]
  }
}

impl Length for SymbolTable {
  def length -> Int {
    @symbols.length
  }
}
