# Parsing of Inko source code into an Abstract Syntax Tree.
#
# The types and methods of this module are not part of the public API at this
# time, meaning they can change at any time.
import std::byte_array::ToByteArray
import std::compiler::ast::blocks::*
import std::compiler::ast::body::Body
import std::compiler::ast::comments::*
import std::compiler::ast::control_flow::*
import std::compiler::ast::imports::*
import std::compiler::ast::literals::*
import std::compiler::ast::node::*
import std::compiler::ast::objects::*
import std::compiler::ast::operators::*
import std::compiler::ast::pattern_matching::*
import std::compiler::ast::send::*
import std::compiler::ast::types::*
import std::compiler::ast::variables::*
import std::compiler::lexer::Lexer
import std::compiler::source_location::SourceLocation
import std::compiler::token::Token
import std::conversion::ToString
import std::error::Error
import std::fs::path::ToPath
import std::option::Option

# An error produced by the parser.
class ParseError {
  # The error message to display.
  @message: String

  # The source location of the error.
  @location: SourceLocation

  static def unexpected_token(token: Token) -> Self {
    let message = if token.null? {
      'More input was expected, but we ran out of input'
    } else {
      'The following unexpected input was encountered: ' + token.value
    }

    new(message: message, location: token.location)
  }

  static def missing_argument_type(location: SourceLocation) -> Self {
    let message = 'An explicit type or default value is required for this argument'

    new(message: message, location: location)
  }

  static def new(message: String, location: SourceLocation) -> Self {
    Self { @message = message, @location = location }
  }

  def location -> SourceLocation {
    @location
  }
}

impl ToString for ParseError {
  def to_string -> String {
    @message
  }
}

impl Error for ParseError {}

# An LL(1) recursive descent parser for parsing Inko source code into an AST.
class Parser {
  # The lexer to use for lexing the input stream.
  @lexer: Lexer

  # A Token that has been peeked but not yet consumed.
  @peeked_token: ?Token

  # All comments that have been parsed so far.
  @comments: Array!(Comment)

  # A boolean that indicates if comments should be stored (True), or if they
  # should be ignored (False).
  @parse_comments: Boolean

  # Initialises the parser.
  #
  # The `input` argument can be a `ByteArray` or a `String`.
  #
  # The `file` argument should contain the path that produced the input data.
  # This can be a `String`, `Path`, or some other type that implements
  # `std::fs::path::ToPath`.
  #
  # # Parsing comments
  #
  # When `parse_comments` is set to `True`, comments will be stored in the
  # `Parser` instance. These can then be retrieved using `Parser.comments`:
  #
  #     let parser =
  #       Parser.new(input: '# hello', file: 'test.inko', parse_comments: True)
  #
  #     try! parser.parse
  #
  #     parser.comments.length # => 1
  static def new(
    input: ToByteArray,
    file: ToPath,
    parse_comments: Boolean
  ) -> Self {
    Self {
      @lexer = Lexer.new(input: input, file: file),
      @peeked_token = Option.none,
      @comments = Array.new,
      @parse_comments = parse_comments
    }
  }

  # Returns all comments that have been parsed so far.
  def comments -> Array!(Comment) {
    @comments
  }

  # Parses the input source code and returns an AST.
  #
  # # Examples
  #
  # Parsing a simple expression:
  #
  #     import std::compiler::ast::literals::IntegerLiteral
  #     import std::compiler::parser::Parser
  #
  #     let parser = Parser.new(input: '10', file: 'test.inko')
  #     let ast = try! parser.parse
  #     let int = ast.children[0]! as IntegerLiteral
  #
  #     int.value # => '10'
  def parse !! ParseError -> Body {
    let location = @lexer.current_location
    let children = Array.new

    while peek_token.valid? {
      children.push(try top_level_expression(next_token))
    }

    Body.new(children: children, location: location)
  }

  def top_level_expression(token: Token) !! ParseError -> Node {
    match token.type {
      'import' -> { try import_module(token) }
      'class' -> { try class_definition(token) }
      'trait' -> { try trait_definition(token) }
      'impl' -> { try implement_or_reopen(token) }
      'def' -> { try method_definition(token) }
      'let' -> { try define_local_variable_or_constant(token) }
      'extern' -> { try external_method_definition(token) }
      else -> { try expression(token) }
    } as Node
  }

  def import_module(token: Token) !! ParseError -> Import {
    let path = try import_path
    let loc = token.location

    if peek_token.type == 'mul' {
      next_token

      return Import.new(
        path: path,
        symbols: Array.new,
        import_all: True,
        location: loc
      )
    }

    Import.new(
      path: path,
      symbols: try import_symbols,
      import_all: False,
      location: loc
    )
  }

  def import_path !! ParseError -> Array!(Identifier) {
    let steps = Array.new

    loop {
      let token = next_token

      if not token.keyword? or token.type != 'identifier' {
        throw ParseError.unexpected_token(token)
      }

      steps.push(identifier_from_token(token))

      if peek_token.type != 'colon_colon' {
        return steps
      }

      next_token

      match peek_token.type {
        'constant', 'paren_open', 'mul' -> { return steps }
        else -> {}
      }
    }
  }

  def import_symbols !! ParseError -> Array!(ImportSymbol) {
    let peeked = peek_token

    if peeked.type == 'constant' {
      let tok = next_token
      let sym = ImportSymbol
        .new(name: tok.value, location: tok.location, alias: Option.none)

      return Array.new(sym)
    }

    try collect_optional_greedy_list(
      start: 'paren_open',
      stop: 'paren_close'
    ) do (token) {
      let alias = match token.type {
        'identifier', 'constant' -> { try import_alias(token.type) }
        'self' -> { try import_alias('identifier') }
        else -> { throw ParseError.unexpected_token(token) }
      }

      ImportSymbol
        .new(name: token.value, location: token.location, alias: alias)
    }
  }

  def import_alias(expected: String) !! ParseError -> ?ImportAlias {
    if peek_token.type != 'as' { return Option.none }

    # Skip the "as"
    next_token

    let token = next_token

    if token.type != expected { throw ParseError.unexpected_token(token) }

    Option.some(ImportAlias.new(name: token.value, location: token.location))
  }

  def class_definition(token: Token) !! ParseError -> DefineClass {
    let name = try token_of_type('constant')
    let params = try type_parameter_definitions
    let body = try class_body

    DefineClass.new(
      name: name.value,
      type_parameters: params,
      body: body,
      location: token.location
    )
  }

  def attribute_definition(token: Token) !! ParseError -> DefineAttribute {
    try token_of_type('colon')

    let type = try type(next_token)

    DefineAttribute
      .new(name: token.value, value_type: type, location: token.location)
  }

  def trait_definition(token: Token) !! ParseError -> DefineTrait {
    let name = try token_of_type('constant')
    let params = try type_parameter_definitions
    let required_traits = try required_traits
    let body = try trait_body

    DefineTrait.new(
      name: name.value,
      type_parameters: params,
      required_traits: required_traits,
      body: body,
      location: token.location
    )
  }

  def implement_or_reopen(token: Token) !! ParseError -> Node {
    let first_name = try token_of_type('constant')
    let peeked = peek_token.type

    if peeked == 'type_args_open' {
      let trait_name = try constant(first_name)

      try token_of_type('for')

      return try implement_trait(token: token, trait_name: trait_name)
    }

    if peeked == 'for' {
      # Skip the "for"
      next_token

      let trait_name = constant_from_token(first_name)

      return try implement_trait(token: token, trait_name: trait_name)
    }

    let class_name = constant_from_token(first_name)

    try reopen_class(token: token, class_name: class_name)
  }

  def implement_trait(
    token: Token,
    trait_name: Constant
  ) !! ParseError -> ImplementTrait {
    let class_name = constant_from_token(try token_of_type('constant'))
    let bounds = try type_parameter_bounds
    let body = try trait_implementation_body

    ImplementTrait.new(
      trait_name: trait_name,
      class_name: class_name,
      type_parameter_bounds: bounds,
      body: body,
      location: token.location
    )
  }

  def reopen_class(
    token: Token,
    class_name: Constant
  ) !! ParseError -> ReopenObject {
    let body = try reopen_class_body

    ReopenObject.new(name: class_name, body: body, location: token.location)
  }

  def method_definition(token: Token) !! ParseError -> Node {
    let static_method = try static_method?(token)
    let name =
      try message_name_from_token(token: next_token, consume_assign: True)

    let type_params = try type_parameter_definitions
    let arguments = try argument_definitions(require_types: True)
    let throw_type = try optional_throw_type
    let return_type = try optional_return_type
    let yield_type = try optional_yield_type
    let bounds = try type_parameter_bounds

    DefineMethod.new(
      name: name,
      type_parameters: type_params,
      type_parameter_bounds: bounds,
      arguments: arguments,
      throw_type: throw_type,
      return_type: return_type,
      yield_type: yield_type,
      static_method: static_method,
      body: try body,
      location: token.location
    )
  }

  def external_method_definition(token: Token) !! ParseError -> Node {
    try token_of_type('def')

    let name =
      try message_name_from_token(token: next_token, consume_assign: True)

    let arguments = try external_method_argument_definitions
    let throws = try optional_throw_type
    let returns = try optional_return_type

    DefineExternalFunction.new(
      name: name,
      arguments: arguments,
      throw_type: throws,
      return_type: returns,
      location: token.location
    )
  }

  def trait_method_definition(token: Token) !! ParseError -> Node {
    let name =
      try message_name_from_token(token: next_token, consume_assign: True)

    let type_params = try type_parameter_definitions
    let arguments = try argument_definitions(require_types: True)
    let throw_type = try optional_throw_type
    let return_type = try optional_return_type
    let yield_type = try optional_yield_type
    let bounds = try type_parameter_bounds

    if peek_token.type != 'curly_open' {
      return DefineRequiredMethod.new(
        name: name,
        type_parameters: type_params,
        type_parameter_bounds: bounds,
        arguments: arguments,
        throw_type: throw_type,
        return_type: return_type,
        yield_type: yield_type,
        location: token.location
      )
    }

    DefineMethod.new(
      name: name,
      type_parameters: type_params,
      type_parameter_bounds: bounds,
      arguments: arguments,
      throw_type: throw_type,
      return_type: return_type,
      yield_type: yield_type,
      static_method: False,
      body: try body,
      location: token.location
    )
  }

  def static_method?(token: Token) !! ParseError -> Boolean {
    if token.type != 'static' { return False }

    try token_of_type('def')

    True
  }

  def grouped_expression !! ParseError -> Node {
    let node = try expression(next_token)

    try token_of_type('paren_close')

    node
  }

  def basic_closure(token: Token) !! ParseError -> BasicClosure {
    BasicClosure.new(body: try block_body(token), location: token.location)
  }

  def closure(token: Token) !! ParseError -> Closure {
    let type_params = try type_parameter_definitions
    let arguments = try argument_definitions(require_types: False)
    let throw_type = try optional_throw_type
    let return_type = try optional_return_type
    let body = try body

    Closure.new(
      type_parameters: type_params,
      arguments: arguments,
      body: body,
      throw_type: throw_type,
      return_type: return_type,
      location: token.location
    )
  }

  def lambda(token: Token) !! ParseError -> Lambda {
    let type_params = try type_parameter_definitions
    let arguments = try argument_definitions(require_types: False)
    let throw_type = try optional_throw_type
    let return_type = try optional_return_type
    let body = try body

    Lambda.new(
      type_parameters: type_params,
      arguments: arguments,
      body: body,
      throw_type: throw_type,
      return_type: return_type,
      location: token.location
    )

  }

  def block_body(start: Token) !! ParseError -> Body {
    try collect_block_body_nodes(start.location) do (token) {
      try expression(token)
    }
  }

  def restricted_class_body_node(token: Token) !! ParseError -> Node {
    match token.type {
      'def', 'static' -> { try method_definition(token) }
      'move' -> {
        # TODO: moving methods
        if peek_token.type == 'mut' { next_token }

        try method_definition(try token_of_type('def'))
      }
      'mut' -> {
        # TODO: mutable methods
        try method_definition(try token_of_type('def'))
      }
      'attribute' -> { try attribute_definition(token) }
      else -> { throw ParseError.unexpected_token(token) }
    }
  }

  def restricted_trait_body_node(token: Token) !! ParseError -> Node {
    match token.type {
      'def' -> { try trait_method_definition(token) }
      'move' -> {
        # TODO: moving methods
        if peek_token.type == 'mut' { next_token }

        try trait_method_definition(try token_of_type('def'))
      }
      'mut' -> {
        # TODO: mutable methods
        try trait_method_definition(try token_of_type('def'))
      }
      else -> { throw ParseError.unexpected_token(token) }
    }
  }

  def restricted_trait_implementation_body_node(token: Token) !! ParseError -> Node {
    match token.type {
      'def' -> { try method_definition(token) }
      'move' -> {
        # TODO: moving methods
        if peek_token.type == 'mut' { next_token }

        try method_definition(try token_of_type('def'))
      }
      'mut' -> {
        # TODO: mutable methods
        try method_definition(try token_of_type('def'))
      }
      else -> { throw ParseError.unexpected_token(token) }
    }
  }

  def restricted_reopen_class_body_node(token: Token) !! ParseError -> Node {
    match token.type {
      'def', 'static' -> { try method_definition(token) }
      'move' -> {
        # TODO: moving methods
        if peek_token.type == 'mut' { next_token }

        try method_definition(try token_of_type('def'))
      }
      'mut' -> {
        # TODO: mutable methods
        try method_definition(try token_of_type('def'))
      }
      else -> { throw ParseError.unexpected_token(token) }
    }
  }

  def optional_identifier_type !! ParseError -> ?TypeNode {
    if peek_token.type != 'colon' { return Option.none }

    # Skip the ":"
    next_token
    Option.some(try type(next_token))
  }

  def default_value(rest: Boolean) !! ParseError -> ?Node {
    if peek_token.type != 'assign' { return Option.none }

    # Skip the "="
    let assign = next_token

    if rest {
      # Default values for rest arguments make no sense, as the default value
      # will already be set to an empty Array.
      throw ParseError.unexpected_token(assign)
    }

    Option.some(try expression(next_token))
  }

  def type_parameter_definitions !! ParseError -> Array!(DefineTypeParameter) {
    try collect_optional_greedy_list(
      start: 'type_args_open',
      stop: 'paren_close'
    ) do (token) {
      try type_parameter_definition(token)
    }
  }

  def type_parameter_definition(
    name: Token
  ) !! ParseError -> DefineTypeParameter {
    if name.type != 'constant' { throw ParseError.unexpected_token(name) }

    let traits = try required_traits

    DefineTypeParameter
      .new(name: name.value, required_traits: traits, location: name.location)
  }

  def argument_definitions(
    require_types: Boolean
  ) !! ParseError -> Array!(DefineArgument) {
    try collect_optional_greedy_list(
      start: 'paren_open',
      stop: 'paren_close'
    ) do (current) {
      let mut token = current
      let mut rest = False

      if token.type == 'mul' {
        token = next_token
        rest = True
      }

      try require_token_type(token: token, expected: 'identifier')

      let type = try optional_identifier_type
      let default = try default_value(rest: rest)
      let node = if rest {
        if not type { throw ParseError.missing_argument_type(token.location) }

        DefineRestArgument.new(
          name: token.value,
          value_type: type.get,
          location: token.location
        )
      } else if default.some? {
        DefineOptionalArgument.new(
          name: token.value,
          value_type: type,
          default_value: default.get,
          location: token.location
        )
      } else if type.some? {
        DefineRequiredArgument.new(
          name: token.value,
          value_type: type.get,
          location: token.location
        )
      } else if require_types {
        throw ParseError.missing_argument_type(token.location)
      } else {
        DefineUntypedArgument.new(name: token.value, location: token.location)
      }

      node as DefineArgument
    }
  }

  def external_method_argument_definitions
    !! ParseError
    -> Array!(DefineRequiredArgument)
  {
    try collect_optional_greedy_list(
      start: 'paren_open',
      stop: 'paren_close'
    ) do (token) {
      try require_token_type(token: token, expected: 'identifier')

      let type = try optional_identifier_type

      DefineRequiredArgument.new(
        name: token.value,
        value_type: type.get,
        location: token.location
      )
    }
  }

  def required_traits !! ParseError -> Array!(Constant) {
    let traits = Array.new

    if peek_token.type != 'colon' { return traits }

    # Skip the ":"
    next_token

    loop {
      let constant = try next_as_constant

      traits.push(constant)

      if peek_token.type != 'add' { return traits }

      next_token
    }
  }

  def type_parameter_bounds !! ParseError -> Array!(DefineTypeParameter) {
    if peek_token.type != 'when' { return Array.new }

    # Skip the "when"
    next_token

    try collect_list(stop: 'curly_open') do (token) {
      try type_parameter_definition(token)
    }
  }

  def expression(token: Token) !! ParseError -> Node {
    try binary(token)
  }

  def binary(token: Token) !! ParseError -> Node {
    let mut node = try type_cast(token)

    while peek_token.binary? {
      let operator = next_token
      let operand = try type_cast(next_token)

      node = Send.new(
        message: operator.value,
        receiver: Option.some(node),
        arguments: Array.new(operand),
        type_arguments: Array.new,
        location: operator.location
      )
    }

    node
  }

  def type_cast(token: Token) !! ParseError -> Node {
    let mut node = try postfix(token: token)

    while peek_token.type == 'as' {
      let as_token = next_token
      let cast_to = try type(next_token)

      node = TypeCast
        .new(expression: node, cast_to: cast_to, location: as_token.location)
    }

    node
  }

  def postfix(token: Token) !! ParseError -> Node {
    let mut node = try value(token)

    loop {
      let step = try postfix_step(node)

      if step.same_object?(node) { return node }

      node = step
    }
  }

  def postfix_step(node: Node) !! ParseError -> Node {
    let peeked = peek_token

    match peeked.type {
      'dot' -> {
        next_token
        try send_with_receiver(node)
      }
      'bracket_open' -> { try bracket_send(start: next_token, receiver: node) }
      else -> { node }
    } as Node
  }

  def bracket_send(start: Token, receiver: Node) !! ParseError -> Node {
    let arguments = Array.new(try expression(next_token))

    try token_of_type('bracket_close')

    let message = if peek_token.type == 'assign' {
      # Skip the "="
      next_token

      arguments.push(try expression(next_token))

      '[]='
    } else {
      '[]'
    }

    Send.new(
      message: message,
      receiver: Option.some(receiver),
      arguments: arguments,
      type_arguments: Array.new,
      location: start.location
    )
  }

  def return_value(token: Token) !! ParseError -> Node {
    let peeked = peek_token
    let expr = match peeked.type {
      'identifier',
      'attribute',
      'constant',
      'curly_open',
      'do',
      'fn',
      'integer',
      'float',
      'string',
      'self',
      'match',
      'paren_open',
      'let',
      'return',
      'throw',
      'try',
      'local',
      'colon_colon'
      when peeked.same_line?(token) -> {
        Option.some(try expression(next_token))
      }
      else -> { Option.none }
    }

    Return.new(expression: expr, location: token.location)
  }

  def throw_value(token: Token, local_throw: Boolean) !! ParseError -> Node {
    let expr = try expression(next_token)

    Throw
      .new(expression: expr, local_throw: local_throw, location: token.location)
  }

  def yield_value(token: Token) !! ParseError -> Node {
    let expr = try expression(next_token)

    Yield.new(expression: expr, location: token.location)
  }

  # TODO: remove
  def local_expression(token: Token) !! ParseError -> Node {
    let kind = next_token
    let loc = token.location

    match kind.type {
      'throw' -> {
        try throw_value(token: kind, local_throw: True, location: loc)
      }
      'try' -> {
        try try_expression(token: kind, local_throw: True, location: loc)
      }
      else -> { throw ParseError.unexpected_token(kind) }
    }
  }

  def try_expression(token: Token, local_throw: Boolean) !! ParseError -> Node {
    if peek_token.type == 'exclamation' { return try try_panic(token) }

    let location = token.location
    let expr = try try_expression_value

    if peek_token.type == 'else' {
      try try_with_else(
        token: token,
        expression: expr,
        local_throw: local_throw,
        location: location
      )
    } else {
      try_without_else(
        token: token,
        expression: expr,
        local_throw: local_throw,
        location: location
      )
    }
  }

  def try_panic(token: Token) !! ParseError -> TryPanic {
    # Skip the "!"
    next_token

    let expr = try try_expression_value

    TryPanic.new(expression: expr, location: token.location)
  }

  def try_with_else(
    token: Token,
    expression: Node,
    local_throw: Boolean,
  ) !! ParseError -> Try {
    # Skip the "else" keyword
    next_token

    let location = token.location
    let else_var = if peek_token.type == 'paren_open' {
      # Skip the "("
      next_token

      let var = try token_of_type('identifier')

      try token_of_type('paren_close')

      Option.some(var.value)
    } else {
      Option.none
    }

    let else_body = if peek_token.type == 'curly_open' {
      try body
    } else {
      let body = try expression(next_token)

      Body.new(children: Array.new(body), location: body.location)
    }

    Try.new(
      expression: expression,
      error_variable: else_var,
      else_body: else_body,
      local_throw: local_throw,
      location: location
    )
  }

  def try_without_else(
    token: Token,
    expression: Node,
    local_throw: Boolean,
  ) -> Try {
    let location = token.location
    let else_expr = Body.new(children: Array.new, location: location)

    Try.new(
      expression: expression,
      error_variable: Option.none,
      else_body: else_expr,
      local_throw: local_throw,
      location: location
    )
  }

  def try_expression_value !! ParseError -> Node {
    let expr = try expression(next_token)

    match let matched = expr {
      as TryExpressionNode -> { matched.inside_try }
      else -> {}
    }

    expr
  }

  def self_object(token: Token) -> SelfObject {
    SelfObject.new(location: token.location)
  }

  def identifier(token: Token) !! ParseError -> Node {
    let peeked = peek_token
    let peeked_type = peeked.type

    if peeked_type == 'type_args_open'
      or peeked_type == 'paren_open'
      or next_token_is_argument?(token)
    {
      return try identifier_send(token)
    }

    let ident = identifier_from_token(token)

    if peeked_type == 'assign' { return try assign_local(ident) }

    if peeked.binary_assign? {
      return AssignLocal.new(name: ident, value: try binary_assign(ident))
    }

    ident
  }

  def identifier_send(token: Token) !! ParseError -> Send {
    let type_args = try type_arguments
    let args = try message_arguments(name: token, setter: False)

    Send.new(
      message: token.value,
      arguments: args,
      type_arguments: type_args,
      location: token.location,
      receiver: Option.none
    )
  }

  def assign_local(identifier: Identifier) !! ParseError -> AssignLocal {
    # Skip the "="
    next_token

    AssignLocal.new(name: identifier, value: try expression(next_token))
  }

  def binary_assign(variable: Node) !! ParseError -> Send {
    let operator = next_token
    let message =
      operator.value.slice(start: 0, length: operator.value.length - 1)

    let operand = try expression(next_token)

    Send.new(
      message: message,
      receiver: Option.some(variable),
      arguments: Array.new(operand),
      type_arguments: Array.new,
      location: operator.location
    )
  }

  def value(token: Token) !! ParseError -> Node {
    # When adding a new token to the "match" below, make sure to also update the
    # "match" in the return_value() method.
    match token.type {
      'identifier' -> { try identifier(token) }
      'attribute' -> { try attribute(token) }
      'constant' -> { try constant_or_constructor(token) }
      'curly_open' -> { try basic_closure(token) }
      'do' -> { try closure(token) }
      'fn' -> { try self.lambda(token) }
      'integer' -> { integer(token) }
      'float' -> { float(token) }
      'string' -> { string(token) }
      'self' -> { self_object(token) }
      'match' -> { try pattern_match(token) }
      'paren_open' -> { try grouped_expression }
      'let' -> {
        try define_local_variable(token: token, mutable: next_token_is_mutable?)
      }
      'return' -> { try return_value(token) }
      'throw' -> { try throw_value(token) }
      'try' -> { try try_expression(token) }
      'yield' -> { try yield_value(token) }
      'local' -> { try local_expression(token) }
      'colon_colon' -> { try global(token) }
      else -> { throw ParseError.unexpected_token(token) }
    } as Node
  }

  def integer(token: Token) -> IntegerLiteral {
    IntegerLiteral.new(value: token.value, location: token.location)
  }

  def float(token: Token) -> FloatLiteral {
    FloatLiteral.new(value: token.value, location: token.location)
  }

  def string(token: Token) -> StringLiteral {
    StringLiteral.new(value: token.value, location: token.location)
  }

  def constant(token: Token) !! ParseError -> Constant {
    let node = constant_from_token(token)

    if peek_token.type == 'type_args_open' {
      # Skip the "!("
      next_token

      try greedy_list(stop: 'paren_close') {
        node.type_arguments.push(try type(next_token))
      }
    }

    node
  }

  def constant_or_constructor(token: Token) !! ParseError -> Node {
    let peeked = peek_token

    if peeked.type == 'curly_open' and peeked.same_line?(token) {
      return try constructor(token)
    }

    try constant(token)
  }

  def constructor(token: Token) !! ParseError -> Constructor {
    try token_of_type('curly_open')

    let attrs = try collect_list(stop: 'curly_close') do (attr) {
      require_token_type(token: attr, expected: 'attribute')

      try token_of_type('assign')

      let value = try expression(next_token)

      ConstructorAttribute
        .new(name: attr.value, value: value, location: attr.location)
    }

    try token_of_type('curly_close')

    Constructor
      .new(name: token.value, attributes: attrs, location: token.location)
  }

  def global(token: Token) !! ParseError -> Global {
    let name_token = next_token

    if name_token.type != 'identifier' and name_token.type != 'constant' {
      throw ParseError.unexpected_token(name_token)
    }

    Global.new(name: name_token.value, location: token.location)
  }

  def define_local_variable_or_constant(token: Token) !! ParseError -> Node {
    let mutable = next_token_is_mutable?

    if mutable { return try define_local_variable(token: token, mutable: True) }

    if peek_token.type == 'constant' { return try define_constant(token) }

    try define_local_variable(token: token, mutable: False)
  }

  def define_local_variable(
    token: Token, mutable: Boolean
  ) !! ParseError -> DefineLocalVariable {
    let name = identifier_from_token(try token_of_type('identifier'))
    let type = try optional_identifier_type

    try token_of_type('assign')

    let value = try expression(next_token)

    DefineLocalVariable.new(
      name: name,
      value_type: type,
      value: value,
      mutable: mutable,
      location: token.location
    )
  }

  def define_constant(token: Token) !! ParseError -> DefineConstant {
    let name = constant_from_token(try token_of_type('constant'))
    let type = try optional_identifier_type

    try token_of_type('assign')

    let value = try expression(next_token)

    DefineConstant.new(
      name: name,
      value_type: type,
      value: value,
      location: token.location
    )
  }

  def send_with_receiver(receiver: Node) !! ParseError -> Node {
    let name_token = next_token
    let name =
      try message_name_from_token(token: name_token, consume_assign: False)

    # If the message is a setter message (e.g. `bar=` in `foo.bar = 10`), we
    # need to limit its argument to a single expression. The `=` is already part
    # of the message name retrieved above, so we can consume the token if
    # present; without having to append it to the message name.
    let setter =
      if peek_token.type == 'assign' { next_token True } else { False }

    let type_arguments = try type_arguments
    let arguments = try message_arguments(name: name_token, setter: setter)

    Send.new(
      message: name,
      receiver: Option.some(receiver),
      arguments: arguments,
      type_arguments: type_arguments,
      location: name_token.location
    )
  }

  def message_name_from_token(
    token: Token,
    consume_assign: Boolean
  ) !! ParseError -> String {
    if not token.valid? {
      throw ParseError.new(
        message: 'More input was expected, but we ran out of input',
        location: token.location
      )
    }

    if not valid_message_token?(token) {
      throw ParseError.unexpected_token(token)
    }

    let mut name = token.value

    if token.type == 'bracket_open' { name += next_token.value }

    if peek_token.type == 'assign' {
      if consume_assign { next_token }

      name += '='
    }

    name
  }

  def valid_message_token?(token: Token) -> Boolean {
    token.type == 'identifier'
      or token.type == 'constant'
      or token.binary?
      or token.keyword?
      or (token.type == 'bracket_open' and peek_token.type == 'bracket_close')
  }

  def message_arguments(
    name: Token,
    setter: Boolean
  ) !! ParseError -> Array!(Node) {
    # Setter messages have their arguments limited to a single expression.
    # Example: `foo.bar = 10`.
    if setter { return Array.new(try expression(next_token)) }

    let peeked = peek_token

    if peeked.type == 'paren_open' and peeked.same_line?(name) {
      return try message_arguments_with_parentheses
    }

    if next_token_is_argument?(name) {
      return try message_arguments_without_parentheses
    }

    Array.new
  }

  def message_arguments_with_parentheses !! ParseError -> Array!(Node) {
    let mut allow_positional = True

    # Skip the opening "("
    next_token

    let arguments = try collect_list(stop: 'paren_close') do (token) {
      if token.type == 'identifier' and peek_token.type == 'colon' {
        allow_positional = False

        try keyword_argument(token)
      } else if allow_positional {
        try expression(token)
      } else {
        throw ParseError.new(
          message: 'Positional arguments must come before any keyword arguments',
          location: token.location
        )
      }
    }

    let closing_paren = try token_of_type('paren_close')

    if next_token_is_argument?(closing_paren) {
      arguments.push(try expression(next_token))
    }

    arguments
  }

  # TODO: this syntax isn't consistent with what we allow when parens are used
  def message_arguments_without_parentheses !! ParseError -> Array!(Node) {
    let arguments = Array.new

    loop {
      let token = next_token

      arguments.push(try value(token))

      if peek_token.type == 'comma' { next_token } else { return arguments }
    }
  }

  def keyword_argument(token: Token) !! ParseError -> Node {
    # Skip the colon
    next_token

    let name = identifier_from_token(token)
    let value = try expression(next_token)

    KeywordArgument.new(name: name, value: value, location: name.location)
  }

  def type_arguments !! ParseError -> Array!(TypeNode) {
    try collect_optional_greedy_list(
      start: 'type_args_open',
      stop: 'paren_close'
    ) do (token) {
      try type(token)
    }
  }

  def type(token: Token) !! ParseError -> TypeNode {
    match token.type {
      'mut' -> {
        let type_token = next_token

        if type_token.type == 'ref' {
          # TODO: mutable ref
          try type_without_modifier(type_token)
        }
        else {
          try type_without_modifier(type_token)
        }
      }
      'ref' -> {
        # TODO: immutable ref
        try type_without_modifier(next_token)
      }
      else -> { try type_without_modifier(token) }
    }
  }

  def type_without_modifier(token: Token) !! ParseError -> TypeNode {
    match token.type {
      'constant' -> { try constant(token) }
      'question' -> { try option_type(token) }
      'do' -> { try closure_type(token) }
      'fn' -> { try lambda_type(token) }
      else -> { throw ParseError.unexpected_token(token) }
    } as TypeNode
  }

  def option_type(token: Token) !! ParseError -> OptionType {
    OptionType.new(type: try type(next_token), location: token.location)
  }

  def closure_type(token: Token) !! ParseError -> ClosureType {
    ClosureType.new(
      type_parameters: try type_parameter_definitions,
      arguments: try block_argument_types,
      throw_type: try optional_throw_type,
      return_type: try optional_return_type,
      location: token.location
    )
  }

  def lambda_type(token: Token) !! ParseError -> LambdaType {
    LambdaType.new(
      type_parameters: try type_parameter_definitions,
      arguments: try block_argument_types,
      throw_type: try optional_throw_type,
      return_type: try optional_return_type,
      location: token.location
    )
  }

  def block_argument_types !! ParseError -> Array!(TypeNode) {
    try collect_optional_greedy_list(
      start: 'paren_open',
      stop: 'paren_close'
    ) do (token) {
      try type(token)
    }
  }

  def optional_yield_type !! ParseError -> ?TypeNode {
    if peek_token.type != 'double_arrow' { return Option.none }

    # Skip the "=>"
    next_token

    Option.some(try type(next_token))
  }

  def optional_throw_type !! ParseError -> ?TypeNode {
    if peek_token.type != 'throws' { return Option.none }

    # Skip the "!!"
    next_token

    Option.some(try type(next_token))
  }

  def optional_return_type !! ParseError -> ?TypeNode {
    if peek_token.type != 'arrow' { return Option.none }

    # Skip the "->"
    next_token

    Option.some(try type(next_token))
  }

  def attribute(token: Token) !! ParseError -> Node {
    let attr = Attribute.new(name: token.value, location: token.location)
    let peeked = peek_token

    if peeked.type == 'assign' { return try assign_attribute(attr) }

    if peeked.binary_assign? {
      return AssignAttribute.new(name: attr, value: try binary_assign(attr))
    }

    attr
  }

  def assign_attribute(attribute: Attribute) !! ParseError -> AssignAttribute {
    # Skip the "="
    next_token

    AssignAttribute.new(name: attribute, value: try expression(next_token))
  }

  def identifier_from_token(token: Token) -> Identifier {
    Identifier.new(name: token.value, location: token.location)
  }

  def next_token_is_argument?(start_token: Token) -> Boolean {
    let peeked = peek_token

    peeked.valid?
      and peeked.same_line?(start_token)
      and (
        peeked.type == 'curly_open'
          or peeked.type == 'do'
          or peeked.type == 'fn'
      )
  }

  def next_token_is_mutable? -> Boolean {
    if peek_token.type != 'mut' { return False }

    # Skip the "mut"
    next_token

    True
  }

  def require_token_type(token: Token, expected: String) !! ParseError {
    if token.type == expected { return }

    throw ParseError.unexpected_token(token)
  }

  def token_of_type(type: String) !! ParseError -> Token {
    let token = next_token

    try require_token_type(token: token, expected: type)

    token
  }

  def next_as_constant !! ParseError -> Constant {
    try constant(try token_of_type('constant'))
  }

  def constant_from_token(token: Token) -> Constant {
    Constant.new(name: token.value, location: token.location)
  }

  def body !! ParseError -> Body {
    try block_body(try token_of_type('curly_open'))
  }

  def class_body !! ParseError -> Body {
    let start = try token_of_type('curly_open')

    try collect_block_body_nodes(start.location) do (token) {
      try restricted_class_body_node(token)
    }
  }

  def trait_body !! ParseError -> Body {
    let start = try token_of_type('curly_open')

    try collect_block_body_nodes(start.location) do (token) {
      try restricted_trait_body_node(token)
    }
  }

  def reopen_class_body !! ParseError -> Body {
    let start = try token_of_type('curly_open')

    try collect_block_body_nodes(start.location) do (token) {
      try restricted_reopen_class_body_node(token)
    }
  }

  def trait_implementation_body !! ParseError -> Body {
    let start = try token_of_type('curly_open')

    try collect_block_body_nodes(start.location) do (token) {
      try restricted_trait_implementation_body_node(token)
    }
  }

  def pattern_match(start: Token) !! ParseError -> Match {
    let cases: Array!(MatchCase) = Array.new
    let mut else_branch: ?MatchElse = Option.none
    let mut binding: ?Identifier = Option.none
    let mut match_expr: ?Node = Option.none

    # TODO: remove parentheses requirement
    if peek_token.type == 'paren_open' {
      try token_of_type('paren_open')

      if peek_token.type == 'let' {
        next_token

        binding =
          Option.some(identifier_from_token(try token_of_type('identifier')))

        try token_of_type('assign')
      }

      match_expr = Option.some(try expression(next_token))

      try token_of_type('paren_close')
    }

    try token_of_type('curly_open')

    while peek_token.type != 'curly_close' and peek_token.valid? {
      let token = next_token

      match token.type {
        'as' -> {
          let pattern = constant_from_token(try token_of_type('constant'))
          let type_guard = try optional_pattern_match_guard

          try token_of_type('arrow')

          cases.push(MatchType.new(
            pattern: pattern,
            guard: type_guard,
            body: try body,
            location: token.location
          ))
        }
        'else' -> {
          if else_branch { throw ParseError.unexpected_token(token) }

          try token_of_type('arrow')

          else_branch = Option.some(
            MatchElse.new(
              body: try block_body(try token_of_type('curly_open')),
              location: token.location
            )
          )
        }
        else -> {
          let patterns = Array.new(try expression(token))

          while peek_token.type == 'comma' {
            next_token
            patterns.push(try expression(next_token))
          }

          let expr_guard = try optional_pattern_match_guard

          try token_of_type('arrow')

          cases.push(MatchExpressions.new(
            patterns: patterns,
            guard: expr_guard,
            body: try body,
            location: token.location
          ))
        }
      }
    }

    try token_of_type('curly_close')

    Match.new(
      expression: match_expr,
      binding: binding,
      cases: cases,
      else_branch: else_branch,
      location: start.location
    )
  }

  def optional_pattern_match_guard !! ParseError -> ?Node {
    if peek_token.type != 'when' { return Option.none }

    # Skip the "when" keyword.
    next_token
    Option.some(try expression(next_token))
  }

  def next_token -> Token {
    # TODO: we need a swap here, as `@peeked_token` is a `ref Token`.
    let peeked = try @peeked_token.get else return next_token_from_lexer

    @peeked_token = Option.none

    peeked
  }

  def peek_token -> Token {
    @peeked_token
      .else { @peeked_token = Option.some(next_token_from_lexer) }
      .get
  }

  def next_token_from_lexer -> Token {
    let token = @lexer.next

    if token.type != 'comment' { return token }

    if @parse_comments {
      @comments.push(Comment.new(text: token.value, location: token.location))
    }

    next_token_from_lexer
  }

  def collect_block_body_nodes(
    location: SourceLocation,
    block: do (Token) !! ParseError -> Node
  ) !! ParseError -> Body {
    let nodes = Array.new

    loop {
      let token = next_token

      if token.type == 'curly_close' {
        return Body.new(children: nodes, location: location)
      }

      nodes.push(try block.call(token))
    }
  }

  def collect_optional_greedy_list!(T)(
    start: String,
    stop: String,
    block: do (Token) !! ParseError -> T
  ) !! ParseError -> Array!(T) {
    if peek_token.type != start { return Array.new }

    try collect_greedy_list(stop: stop, block: block)
  }

  def collect_greedy_list!(T)(
    stop: String,
    block: do (Token) !! ParseError -> T
  ) !! ParseError -> Array!(T) {
    # Skip the opening token.
    next_token

    let values = try collect_list(stop: stop, block: block)

    try token_of_type(stop)

    values
  }

  def collect_list!(T)(
    stop: String,
    block: do (Token) !! ParseError -> T
  ) !! ParseError -> Array!(T) {
    let values = Array.new

    try list(stop) {
      values.push(block.call(next_token))
    }

    values
  }

  def greedy_list(stop: String, block: do !! ParseError) !! ParseError {
    try list(stop: stop, block: block)
    try token_of_type(stop)
  }

  def list(stop: String, block: do !! ParseError) !! ParseError {
    while peek_token.type != stop {
      try block.call
      try list_separator_or_terminal(stop)
    }
  }

  def list_separator_or_terminal(type: String) !! ParseError {
    let peeked = peek_token

    match peeked.type {
      'comma' -> {
        next_token
        return
      }
      type -> { return }
      else -> { throw ParseError.unexpected_token(peeked) }
    }
  }
}
