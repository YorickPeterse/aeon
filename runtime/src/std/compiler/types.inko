# Types for representing Inko types.
import std::compiler::module_name::ModuleName
import std::compiler::symbol_table::(Symbol, SymbolTable)
import std::conversion::ToString
import std::hash::Hash
import std::index::*
import std::iterator::Iterator
import std::length::Length
import std::map::Map
import std::operators::Equal
import std::option::Option
import std::pair::Pair
import std::set::Set
import std::stdio::stdout
import std::string_buffer::StringBuffer

# The name of a constant to signal the use of the `Any` type.
let ANY_TYPE = 'Any'

# The name of a constant to signal the use of the `Never` type.
let NEVER_TYPE = 'Never'

# The name of a constant to signal the use of the `Self` type.
let SELF_TYPE = 'Self'

# The name of Inko's option type.
let OPTION_TYPE = 'Option'

# The name of the constant that refers to the current module.
let THIS_MODULE = 'ThisModule'

# The name of the instance attribute to store object names in.
let OBJECT_NAME_ATTRIBUTE = '@_object_name'

# The name of the single type parameter used for the `Array` type.
let ARRAY_TYPE_PARAMETER = 'T'

# The name of the value type parameter used for the `Generator` type.
let GENERATOR_VALUE_TYPE_PARAMETER = 'T'

# The name of the error type parameter used for the `Generator` type.
let GENERATOR_ERROR_TYPE_PARAMETER = 'E'

# The name of the module defining the Object trait.
let BOOTSTRAP_MODULE = ModuleName.new(Array.new('std', 'bootstrap'))

# The name of the module defining the Match trait.
let OPERATORS_MODULE = ModuleName.new(Array.new('std', 'operators'))

# The name of the module defining the Option object.
let OPTION_MODULE = ModuleName.new(Array.new('std', 'option'))

# The name of the trait that must be implemented by types to be used as
# expression match cases.
let MATCH_TRAIT = 'Match'

# The name of the method to use for pattern matching expressions.
let MATCH_METHOD = '=~'

# The name of the Object trait, implemented by all objects.
let OBJECT_TRAIT = 'Object'

# The name of the message used for running blocks.
let CALL_MESSAGE = 'call'

# A type used when type-checking to look up types and assign type parameters.
trait TypeCheckScope {
  # Returns the type of self/Self.
  def self_type -> ref Type

  # Looks up a type parameter's type.
  def lookup_type_parameter_type(parameter: ref TypeParameterType) -> ?ref Type

  # Assigns a type parameter to the given type.
  def assign_type_parameter(parameter: ref TypeParameterType, type: Type)

  def assign_unassigned_type_parameter(
    parameter: ref TypeParameterType,
    type: Type
  ) {
    if lookup_type_parameter_type(parameter) { return }

    assign_type_parameter(parameter: parameter, type: type)
  }
}

# A (lexical) scope to use for looking up types.
class TypeScope {
  # The module that surrounds the scope.
  @module: ref ModuleType

  # The type of `self`.
  @self_type: ref Type

  # The block (a method, closure, or lambda) that surrounds this scope, if any.
  @block: ?ref BlockType

  # The parent type scope.
  @parent: ?ref TypeScope

  static def new(
    module: ref ModuleType,
    self_type: ref Type,
    block: ?ref BlockType,
    parent: ?ref TypeScope
  ) -> Self {
    Self {
      @module = module,
      @self_type = self_type,
      @block = block,
      @parent = parent
    }
  }

  def module -> ref ModuleType {
    @module
  }

  def self_type -> ref Type {
    @self_type
  }

  def block -> ref ?ref BlockType {
    @block
  }

  def parent -> ref ?ref TypeScope {
    @parent
  }

  def enclosing_blocks => ref BlockType {
    let mut source = self

    loop {
      if not source.block { return }

      yield source.block.get_ref

      if not source.parent { return }

      source = source.parent.get_ref
    }
  }

  def block_scope_boundary -> ?ref BlockType {
    for type in enclosing_blocks {
      if type.scope_boundary? { return Option.some(type) }
    }

    Option.none
  }

  def yield_boundary -> ?ref MethodType {
    for type in enclosing_blocks {
      match let matched = type {
        as MethodType -> { return Option.some(matched) }
        as LambdaType -> { return Option.none }
        else -> {}
      }
    }

    Option.none
  }

  def lookup_type(name: String) -> ?ref Symbol!(Type) {
    @block
      .as_ref
      .then do (block) { block.lookup_type(name) }
      .else {
        block_scope_boundary.then do (method) { method.lookup_type(name) }
      }
      .else { @self_type.lookup_type(name) }
      .else { @module.lookup_type(name) }
  }

  def lookup_type_as_value(name: String) -> ?ref Symbol!(Type) {
    @module.lookup_type(name)
  }

  def lookup_method(name: String) -> ?ref Symbol!(MethodType) {
    let method = @self_type.lookup_method(name)

    if method { method } else { @module.lookup_method(name) }
  }
}

impl TypeCheckScope for TypeScope {
  def self_type -> ref Type {
    @self_type
  }

  def lookup_type_parameter_type(parameter: ref TypeParameterType) -> ?ref Type {
    # A TypeScope is used for a lexical scope, not when sending messages. Block
    # type parameters can only be assigned when sending messages, and only live
    # for the duration of the message.
    #
    # Because of this, a TypeScope doesn't need to look for parameter
    # assignments.
    @self_type.lookup_type_parameter_type(parameter)
  }

  def assign_type_parameter(parameter: ref TypeParameterType, type: Type) {
    @self_type.assign_type_parameter(parameter: parameter, type: type)
  }
}

# A type scope used for assigning type parameters to their rigid counterparts.
#
# Certain symbols have two (context specific) types. Take this method for
# example:
#
#     def push!(A)(values: Array!(A)) {
#       values.push(values[0])
#     }
#
# The public/outside type of `values` is `Array!(A)`, and any type is compatible
# with `A`. In the method body however, `values` is a `Array!(rigid A)`, where
# `rigid A` signals a rigid type parameter A.
#
# This difference is necessary to ensure the body of the method doesn't produce
# unsound behaviour. For example, the method doesn't know what the actual type
# of `A` is at runtime. As such, it can't substitute it with other types (e.g.
# the `Int`) type. This means this is invalid:
#
#     def push!(A)(values: Array!(A)) {
#       values.push(10)
#     }
#
#     push(Array.new('foo', 'bar'))
#
# A RigidTypeScope is used to assign type parameters to their rigid counterparts
# whenever this is necessary, removing the need for visiting AST nodes multiple
# times just to produce the right types for the right contexts.
class RigidTypeScope {
  # The type of `self`/`Self`.
  @self_type: ref Type

  # Type parameters and their rigid type parameters.
  @type_parameter_types: TypeParameterTypes

  static def new(self_type: ref Type) -> Self {
    Self {
      @self_type = self_type,
      @type_parameter_types = TypeParameterTypes.new
    }
  }

  static def from_type_scope(scope: ref TypeScope) -> Self {
    let types = TypeParameterTypes.new

    scope.each_enclosing_block do (block) {
      types.assign_rigid_type_parameters(block.type_parameters)
    }

    match let type = scope.self_type {
      as TraitInstance -> {
        types.assign_rigid_type_parameters(type.instance_of.type_parameters)
      }
      as ClassInstance -> {
        types.assign_rigid_type_parameters(type.instance_of.type_parameters)
      }
      else -> {}
    }

    Self { @self_type = scope.self_type, @type_parameter_types = types }
  }
}

impl TypeCheckScope for RigidTypeScope {
  def self_type -> ref Type {
    @self_type
  }

  def lookup_type_parameter_type(parameter: ref TypeParameterType) -> ?ref Type {
    @type_parameter_types.get(parameter)
  }

  def assign_type_parameter(parameter: ref TypeParameterType, type: Type) {
    @type_parameter_types[parameter] = type
  }
}

# An Inko type.
trait Type {
  # Returns a human-readable name of this type.
  def type_name -> String

  # Returns `True` if the current type is compatible with the given type.
  #
  # When comparing with a type parameter that isn't assigned a type, it will be
  # assigned the type that is compared with the parameter; if they are
  # compatible.
  def type_compatible?(
    with: Type,
    builtins: Builtins,
    scope: TypeCheckScope
  ) -> Boolean

  # Returns `True` if `self` is a `Error` type.
  def error? -> Boolean {
    False
  }

  # Returns `True` if `self` is a `Never` type.
  def never? -> Boolean {
    False
  }

  # Returns `True` if `self` is a `Self` type.
  def self_type? -> Boolean {
    False
  }

  # Returns `True` if this type is a closure or lambda.
  def closure_or_lambda? -> Boolean {
    False
  }

  # Returns `True` if this type is a type parameter.
  def type_parameter? -> Boolean {
    False
  }

  # Returns `True` if `self` is a generic type that can be initialised.
  def initialise? -> Boolean {
    False
  }

  # Returns `True` if this type should be inferred to a real type.
  def infer? -> Boolean {
    False
  }

  # Returns `True` if this type is a method.
  def method? -> Boolean {
    False
  }

  # Returns the number of type parameters defined on `self`.
  def number_of_type_parameters -> Int {
    0
  }

  # Looks up an attribute by its name.
  def lookup_attribute(name: String) -> ?Symbol!(AttributeType) {
    Option.none
  }

  # Looks up a method by its name.
  def lookup_method(name: String) -> ?Symbol!(MethodType) {
    Option.none
  }

  # Looks up a type (a constant, type parameter, etc) by its name.
  def lookup_type(name: String) -> ?Symbol!(Type) {
    Option.none
  }

  # Looks up a type parameter by its name.
  def lookup_type_parameter(name: String) -> ?Symbol!(TypeParameterType) {
    Option.none
  }

  # Returns `True` if the given type parameter is defined by the current type.
  def defines_type_parameter?(parameter: TypeParameterType) -> Boolean {
    let param = try lookup_type_parameter(parameter.name) else return False

    param.type.same_object?(parameter)
  }

  # Looks up the type a type parameter is assigned to.
  def lookup_type_parameter_type(parameter: TypeParameterType) -> ?Type {
    Option.none
  }

  # Assigns the given type parameter to a type.
  def assign_type_parameter(parameter: TypeParameterType, type: Type) {}

  # Returns a new instance of the current type.
  def new_instance(type_arguments: Array!(Type)) -> Self {
    self
  }

  # Returns `True` if `self` is an object and an instance of the given object.
  def object_instance_of?(type: ClassType) -> Boolean {
    False
  }

  # Returns `True` if the current type is compatible with _all_ the given types.
  def type_compatible_with_all?(
    types: Array!(Type),
    builtins: Builtins,
    scope: TypeCheckScope
  ) -> Boolean {
    types.iter.all? do (type) {
      type_compatible?(type, builtins, scope)
    }
  }

  def type_compatible_with_type_parameter?(
    parameter: TypeParameterType,
    builtins: Builtins,
    scope: TypeCheckScope
  ) -> Boolean {
    let type = scope.lookup_type_parameter_type(parameter)

    # A type parameter may be assigned to itself. In such a case, the type-check
    # below would keep recursing back into this method.
    #
    # To prevent this from happening, if parameter P is not assigned or assigned
    # to itself, we just compare ourselves with the required traits.
    let compatible = if type.some? and type.same_object?(parameter).false? {
      type_compatible?(type.get, builtins, scope)
    } else {
      type_compatible_with_all?(types: parameter.required_traits, builtins, scope)
    }

    if compatible and type.none? {
      scope.assign_type_parameter(parameter: parameter, type: self)
    }

    compatible
  }

  # Substitutes Self types and type parameters for their concrete types.
  def substitute(scope: TypeCheckScope) -> Type {
    self
  }
}

# A collection of type parameters and the types assigned to them.
class TypeParameterTypes {
  # The type parameters and the types assigned to these parameters.
  #
  # We use a Map as type parameters can be assigned to out of order. This can
  # happen when one or more type parameters are assigned after creating an
  # instance of the object they belong to.
  @map: Map!(TypeParameterType, Type)

  static def copied_from(type: Type) -> Self {
    let copy = new
    let from = match let matched = type {
      as TraitInstance -> { matched.type_parameter_types }
      as ClassInstance -> { matched.type_parameter_types }
      else -> { return copy }
    }

    for (param, type) in from { copy[param] = type }

    copy
  }

  static def new -> Self {
    Self { @map = Map.new }
  }

  def assign_in_order(
    table: SymbolTable!(TypeParameterType),
    arguments: Array!(Type)
  ) {
    for (sym, type) in table.iter.zip(arguments.iter) {
      @map[sym.type] = type
    }
  }

  def substitute(scope: TypeCheckScope) -> Self {
    let types = TypeParameterTypes.new

    for (param, type) in @map { types[param] = type.substitute(scope) }

    types
  }

  def type_compatible?(
    with: TypeParameterTypes,
    builtins: Builtins,
    scope: TypeCheckScope
  ) -> Boolean {
    if length != with.length { return False }

    @map.iter.all? do (pair) {
      let theirs = try with.get(pair.key).get else return False

      pair.value.type_compatible?(theirs, builtins, scope)
    }
  }

  def iter -> Pair!(ref TypeParameterType, ref Type) {
    @map.iter
  }

  def copy_into_type(type: Type) {
    match let matched = type {
      as ClassInstance -> {
        copy_into_type_parameter_types(
          parameters: matched.instance_of.type_parameters,
          arguments: matched.type_parameter_types
        )
      }
      as TraitInstance -> {
        copy_into_type_parameter_types(
          parameters: matched.instance_of.type_parameters,
          arguments: matched.type_parameter_types
        )
      }
      else -> {
        # Object and trait instances are the only generic types that should
        # persist their type arguments.
      }
    }
  }

  def copy_into_type_parameter_types(
    parameters: SymbolTable!(TypeParameterType),
    arguments: TypeParameterTypes
  ) {
    for (param, type) in @map {
      # We only want to copy the parameter assignment if the target type owns
      # the parameter, and if the parameter isn't already assigned a value.
      if arguments.defines?(param) { next }

      let sym = try parameters.get(param.name).get_ref else next

      if sym.type.same_object?(param) { arguments[param] = type }
    }
  }

  def defines?(parameter: TypeParameterType) -> Boolean {
    @map.key?(parameter)
  }

  def get(parameter: TypeParameterType) -> ?Type {
    @map.get(parameter)
  }

  def assign_rigid_type_parameters(parameters: SymbolTable!(TypeParameterType)) {
    for symbol in parameters.symbols {
      self[symbol.type] = RigidTypeParameterType.new(symbol.type)
    }
  }
}

impl Length for TypeParameterTypes {
  def length -> Int {
    @map.length
  }
}

impl Index!(TypeParameterType, ref Type) for TypeParameterTypes {
  def [](index: ref TypeParameterType) -> ref Type {
    @map[index]
  }
}

impl SetIndex!(TypeParameterType, Type) for TypeParameterTypes {
  def []=(index: TypeParameterType, value: Type) -> Type {
    @map[index] = value
  }
}

# A collection of built-in types.
class Builtins {
  @trait_type: ClassType
  @boolean_type: ClassType
  @true_singleton: ClassInstance
  @false_singleton: ClassInstance
  @nil_type: ClassType
  @nil_singleton: ClassInstance
  @block_type: ClassType
  @integer_type: ClassType
  @float_type: ClassType
  @string_type: ClassType
  @module_type: ClassType
  @array_type: ClassType
  @byte_array_type: ClassType
  @ffi_library_type: ClassType
  @ffi_function_type: ClassType
  @ffi_pointer_type: ClassType
  @ip_socket_type: ClassType
  @unix_socket_type: ClassType
  @process_type: ClassType
  @read_only_file_type: ClassType
  @write_only_file_type: ClassType
  @read_write_file_type: ClassType
  @hasher_type: ClassType
  @generator_type: ClassType
  @child_process_type: ClassType

  static def new -> Self {
    let array_type = ClassType.builtin('Array')
    let boolean_type = ClassType.builtin('Boolean')
    let nil_type = ClassType.builtin('NilType')

    array_type.type_parameters.define(
      name: ARRAY_TYPE_PARAMETER,
      type: TypeParameterType.new(ARRAY_TYPE_PARAMETER)
    )

    let generator_type = ClassType.builtin('Generator')

    generator_type.type_parameters.define(
      name: GENERATOR_VALUE_TYPE_PARAMETER,
      type: TypeParameterType.new(GENERATOR_VALUE_TYPE_PARAMETER)
    )

    generator_type.type_parameters.define(
      name: GENERATOR_ERROR_TYPE_PARAMETER,
      type: TypeParameterType.new(GENERATOR_ERROR_TYPE_PARAMETER)
    )

    Self {
      @trait_type = ClassType.builtin('Trait'),
      @boolean_type = boolean_type,
      @true_singleton = ClassInstance.new(boolean_type),
      @false_singleton = ClassInstance.new(boolean_type),
      @nil_type = nil_type,
      @nil_singleton = ClassInstance.new(nil_type),
      @block_type = ClassType.builtin('Block'),
      @integer_type = ClassType.builtin('Int'),
      @float_type = ClassType.builtin('Float'),
      @string_type = ClassType.builtin('String'),
      @module_type = ClassType.builtin('Module'),
      @byte_array_type = ClassType.builtin('ByteArray'),
      @array_type = array_type,
      @ffi_library_type = ClassType.builtin('Library'),
      @ffi_function_type = ClassType.builtin('Function'),
      @ffi_pointer_type = ClassType.builtin('Pointer'),
      @ip_socket_type = ClassType.builtin('Socket'),
      @unix_socket_type = ClassType.builtin('Socket'),
      @process_type = ClassType.builtin('Process'),
      @read_only_file_type = ClassType.builtin('ReadOnlyFile'),
      @write_only_file_type = ClassType.builtin('WriteOnlyFile'),
      @read_write_file_type = ClassType.builtin('ReadWriteFile'),
      @hasher_type = ClassType.builtin('Hasher'),
      @generator_type = generator_type,
      @child_process_type = ClassType.builtin('ChildProcess')
    }
  }

  def trait_type -> ClassType {
    @trait_type
  }

  def boolean_type -> ClassType {
    @boolean_type
  }

  def true_singleton -> ClassInstance {
    @true_singleton
  }

  def false_singleton -> ClassInstance {
    @false_singleton
  }

  def nil_type -> ClassType {
    @nil_type
  }

  def nil_singleton -> ClassInstance {
    @nil_singleton
  }

  def block_type -> ClassType {
    @block_type
  }

  def integer_type -> ClassType {
    @integer_type
  }

  def float_type -> ClassType {
    @float_type
  }

  def string_type -> ClassType {
    @string_type
  }

  def module_type -> ClassType {
    @module_type
  }

  def array_type -> ClassType {
    @array_type
  }

  def byte_array_type -> ClassType {
    @byte_array_type
  }

  def ffi_library_type -> ClassType {
    @ffi_library_type
  }

  def ffi_function_type -> ClassType {
    @ffi_function_type
  }

  def ffi_pointer_type -> ClassType {
    @ffi_pointer_type
  }

  def ip_socket_type -> ClassType {
    @ip_socket_type
  }

  def unix_socket_type -> ClassType {
    @unix_socket_type
  }

  def process_type -> ClassType {
    @process_type
  }

  def read_only_file_type -> ClassType {
    @read_only_file_type
  }

  def write_only_file_type -> ClassType {
    @write_only_file_type
  }

  def read_write_file_type -> ClassType {
    @read_write_file_type
  }

  def hasher_type -> ClassType {
    @hasher_type
  }

  def generator_type -> ClassType {
    @generator_type
  }

  def child_process_type -> ClassType {
    @child_process_type
  }
}

# A type that signals something will never happen.
#
# A Never type used as for example a return type means a method will never
# return.
class NeverType {
  static def new -> Self {
    Self {}
  }
}

impl Type for NeverType {
  def type_name -> String {
    NEVER_TYPE
  }

  def never? -> Boolean {
    True
  }

  def type_compatible?(
    with: Type,
    builtins: Builtins,
    scope: TypeCheckScope
  ) -> Boolean {
    match let type = with {
      as TypeParameterType -> {
        scope.assign_unassigned_type_parameter(parameter: type, type: self)
        True
      }
      else -> { True }
    }
  }
}

# A type that signals a real type has to be inferred somehow.
class InferType {
  static def new -> Self {
    Self {}
  }
}

impl Type for InferType {
  def type_name -> String {
    '?'
  }

  def type_compatible?(
    with: Type,
    builtins: Builtins,
    scope: TypeCheckScope
  ) -> Boolean {
    match with {
      as InferType -> { True }
      as ErrorType -> { True }
      else -> { False }
    }
  }

  def infer? -> Boolean {
    True
  }
}

# A type that all other types are compatible with.
class AnyType {
  static def new -> Self {
    Self {}
  }
}

impl Type for AnyType {
  def type_name -> String {
    ANY_TYPE
  }

  def type_compatible?(
    with: Type,
    builtins: Builtins,
    scope: TypeCheckScope
  ) -> Boolean {
    match let matched = with {
      as SelfType -> { type_compatible?(scope.self_type, builtins, scope) }
      as TypeParameterType -> {
        type_compatible_with_type_parameter?(matched, builtins, scope)
      }
      as AnyType -> { True }
      as InferType -> { True }
      as ErrorType -> { True }
      else -> { False }
    }
  }
}

# A type that will resolve to the type of `self` when used.
#
# `Self` types are essentially placeholders for types that should be resolved to
# the type of `self` when they are used. Take this method for example:
#
#     class Thing {
#       def example(thing: Self) {}
#     }
#
# When used, the type of `thing` will be resolved to `Thing`.
#
# Self types are mostly useful in traits, as this allows them to be inferred to
# the type of the object that implements the trait.
class SelfType {
  static def new -> Self {
    Self {}
  }
}

impl Type for SelfType {
  def type_name -> String {
    SELF_TYPE
  }

  def self_type? -> Boolean {
    True
  }

  def type_compatible?(
    with: Type,
    builtins: Builtins,
    scope: TypeCheckScope
  ) -> Boolean {
    match with {
      as AnyType -> { True }
      as ErrorType -> { True }
      else -> {
        let self_type = scope.self_type

        # In practise this should never happen, but without an explicit check
        # this method will keep recursing into itself. To make it clear a
        # SelfType is not to be compared with another SelfType, we treat them as
        # being incompatible with each other.
        if self_type.self_type? { return False }

        self_type.new_instance.type_compatible?(with, builtins, scope)
      }
    }
  }

  def substitute(scope: TypeCheckScope) -> Type {
    # A Self type always refers to an instance of a type. So if `self` is an
    # object itself (e.g. the String type), then the Self type refers to
    # instances of String.
    scope.self_type.new_instance
  }
}

# A type that signals a concrete type could not be determined.
#
# Error types can only be created by the compiler. These types are compatible
# with all other types to prevent cascading errors. This is safe, because the
# compiler will not continue the compilation process when errors are present.
class ErrorType {
  static def new -> Self {
    Self {}
  }
}

impl Type for ErrorType {
  def type_name -> String {
    '<type error>'
  }

  def error? -> Boolean {
    True
  }

  def type_compatible?(
    with: Type,
    builtins: Builtins,
    scope: TypeCheckScope
  ) -> Boolean {
    True
  }
}

# A type parameter used in a generic type.
class TypeParameterType {
  # The name of the type parameter.
  @name: String

  # The traits required by this type parameter.
  @required_traits: Array!(TraitInstance)

  static def new(name: String, required_traits: Array!(TraitInstance)) -> Self {
    Self { @name = name, @required_traits = required_traits }
  }

  def name -> String {
    @name
  }

  def required_traits -> Array!(TraitInstance) {
    @required_traits
  }
}

impl Equal for TypeParameterType {}
impl Hash for TypeParameterType {}

impl Type for TypeParameterType {
  def type_name -> String {
    if @required_traits.empty? {
      @name
    } else {
      let reqs = @required_traits.iter.map do (t) { t.type_name }.join(' + ')

      `{@name}: {reqs}`
    }
  }

  def lookup_method(name: String) -> ?Symbol!(MethodType) {
    @required_traits.iter.find_some do (type) { type.lookup_method(name) }
  }

  def type_compatible?(
    with: Type,
    builtins: Builtins,
    scope: TypeCheckScope
  ) -> Boolean {
    match let expected = with {
      as TraitInstance -> {
        @required_traits.iter.any? do (required) {
          required.type_compatible?(expected, builtins, scope)
        }
      }
      as TypeParameterType -> {
        type_compatible_with_type_parameter?(expected, builtins, scope)
      }
      as ErrorType -> { True }
      as AnyType -> { True }
      else -> { False }
    }
  }

  def substitute(scope: TypeCheckScope) -> Type {
    let assigned =
      try scope.lookup_type_parameter_type(self).get_ref else return self

    if not assigned.same_object?(self) { return assigned.substitute(scope) }

    self
  }

  def type_parameter? -> Boolean {
    True
  }
}

# A type parameter that can't be assigned/inferred a new type.
#
# Rigid type parameters are used inside methods. These can't be assigned new
# types, as those types may not be compatible with the type assigned by the
# user. Take this method for example:
#
#     def unsound!(T)(values: Array!(T)) {
#       values.push(10)
#     }
#
# Inside this method, `T` is a rigid type parameter. The `Int` type can't be
# assigned to a rigid type parameter, and thus this code doesn't compile.
# Without rigid type parameters, the above code could result in unsound
# behaviour. For example:
#
#     unsound(Array.new('foo'))
#
# Here the input is of type `Array!(String)`, but due to the soundness hole the
# Array would end up containing an integer value.
#
# The term "rigid type parameter" originates from Haskell, and is sometimes
# referred to as a "skolem type parameter". A type parameter is best seen as a
# type placeholder that has certain requirements, but isn't an actual type (at
# runtime). A rigid type parameter is _some type_ that happens to meet the type
# parameter requirements, we just don't know what the actual type is.
class RigidTypeParameterType {
  # The type parameter we belong to.
  @type: TypeParameterType

  static def new(type: TypeParameterType) -> Self {
    Self { @type = type }
  }

  def type -> TypeParameterType {
    @type
  }
}

impl Type for RigidTypeParameterType {
  def type_name -> String {
    @type.type_name
  }

  def lookup_method(name: String) -> ?Symbol!(MethodType) {
    @type.lookup_method(name)
  }

  def type_compatible?(
    with: Type,
    builtins: Builtins,
    scope: TypeCheckScope
  ) -> Boolean {
    match let exp = with {
      as RigidTypeParameterType -> { @type == exp.type }
      else -> { @type.type_compatible?(exp, builtins, scope) }
    }
  }

  def substitute(scope: TypeCheckScope) -> Type {
    # Rigid type parameter's can't be substituted with another type.
    self
  }
}

# Additional type parameter bounds to apply to a trait implementation or method.
class TypeParameterBounds {
  # All type parameters that have additional bounds, in the order they are
  # defined in.
  @parameters: Array!(TypeParameterType)

  # A mapping of type parameters and their additional requirements.
  @mapping: Map!(TypeParameterType, Array!(TraitInstance))

  static def new -> Self {
    Self { @parameters = Array.new, @mapping = Map.new }
  }

  def parameters -> Array!(TypeParameterType) {
    @parameters
  }

  def define(
    parameter: TypeParameterType,
    requirements: Array!(TraitInstance)
  ) -> Boolean {
    if @mapping.get(parameter) { return False }

    @mapping[parameter] = requirements

    @parameters.push(parameter)
    True
  }

  def merge(other: TypeParameterBounds) -> Self {
    for param in other.parameters {
      define(parameter: param, requirements: other[param])
    }

    self
  }

  def met_by?(
    type_parameter_types: TypeParameterTypes,
    builtins: Builtins,
    scope: TypeCheckScope
  ) -> Boolean {
    for (param, requirements) in @mapping {
      let compare = try type_parameter_types.get(param).get else param

      for req in requirements {
        if not compare.type_compatible?(req, builtins, scope) { return False }
      }
    }

    True
  }

  def get(index: TypeParameterType) -> ?Array!(TraitInstance) {
    @mapping.get(index)
  }
}

impl Index!(TypeParameterType, ref Array!(TraitInstance)) for TypeParameterBounds {
  def [](index: ref TypeParameterType) -> ref Array!(TraitInstance) {
    @mapping[index]
  }
}

impl Length for TypeParameterBounds {
  def length -> Int {
    @parameters.length
  }
}

# A block, such as a method or closure.
trait BlockType: Type {
  # Returns the BlockLayout of this block.
  def layout -> BlockLayout

  # Returns the arguments and their types.
  def arguments -> SymbolTable!(Type) {
    layout.arguments
  }

  # Returns the number of required arguments.
  def required_arguments -> Int {
    layout.required_arguments
  }

  # Returns `True` if the last argument is a rest argument.
  def rest_argument? -> Boolean {
    layout.rest_argument?
  }

  # Defines a new required argument.
  def define_required_argument(
    name: String,
    type: Type,
    mutable: Boolean
  ) -> Symbol!(Type) {
    layout.define_required_argument(name: name, type: type, mutable: mutable)
  }

  # Defines a new rest argument.
  def define_rest_argument(
    name: String,
    type: Type,
    mutable: Boolean
  ) -> Symbol!(Type) {
    layout.define_rest_argument(name: name, type: type, mutable: mutable)
  }

  # Returns the type thrown, if any.
  def throw_type -> ?Type {
    layout.throw_type
  }

  # Sets the throw type to the given type.
  def throw_type=(type: Type) -> Type {
    layout.throw_type = type
  }

  # Removes the throw type of this block.
  def unset_throw_type {
    layout.unset_throw_type
  }

  # Returns a boolean indicating if this block throws.
  def throws? -> Boolean {
    layout.throws?
  }

  # Marks this block as throwing a value.
  def throws {
    layout.throws
  }

  # Returns the type returned, if any.
  def return_type -> Type {
    layout.return_type
  }

  # Sets the return type to the given type.
  def return_type=(type: Type) -> Type {
    layout.return_type = type
  }

  # Returns the type parameters defined for this block.
  def type_parameters -> SymbolTable!(TypeParameterType) {
    layout.type_parameters
  }

  # Returns `True` if `self` is an instance of the given type.
  def instance_of?(type: ClassType, builtins: Builtins) -> Boolean {
    type.same_object?(builtins.block_type)
  }

  # Returns `True` if `self` implements the given trait.
  def implements_trait?(
    type: TraitInstance,
    builtins: Builtins,
    scope: TypeCheckScope
  ) -> Boolean {
    builtins.block_type.implements_trait?(type, builtins, scope)
  }

  # Returns `True` if `self` is compatible with the given `BlockType`.
  def block_compatible?(
    with: BlockType,
    builtins: Builtins,
    scope: TypeCheckScope
  ) -> Boolean {
    if not type_parameters_compatible?(with, builtins, scope) { return False }
    if not arguments_compatible?(with, builtins, scope) { return False }
    if not throw_type_compatible?(with, builtins, scope) { return False }

    return_type.type_compatible?(with.return_type, builtins, scope)
  }

  def type_parameters_compatible?(
    with: BlockType,
    builtins: Builtins,
    scope: TypeCheckScope
  ) -> Boolean {
    let their_params = with.type_parameters

    type_parameters.length != their_params.length { return False }

    for (index, ours) in type_parameters.symbols.iter.with_index {
      let theirs = their_params.symbols[index]

      if not ours.type.type_compatible?(theirs.type, builtins, scope) {
        return False
      }
    }

    True
  }

  def arguments_compatible?(
    with: BlockType,
    builtins: Builtins,
    scope: TypeCheckScope
  ) -> Boolean {
    let their_args = with.arguments

    if arguments.length != their_args.length { return False }

    for (index, ours) in arguments.symbols.iter.with_index {
      let theirs = their_args.symbols[index]

      if ours.name != theirs.name { return False }

      if not ours.type.type_compatible?(theirs.type, builtins, scope) {
        return False
      }
    }

    True
  }

  def throw_type_compatible?(
    with: BlockType,
    builtins: Builtins,
    scope: TypeCheckScope
  ) -> Boolean {
    let ours = throw_type
    let theirs = with.throw_type

    # A block that doesn't throw can safely substitute a block that does throw.
    if ours.none? { return True }

    # A block that throws (= ours) can't safely substitute a block that doesn't.
    if theirs.none? { return False }

    ours.get.type_compatible?(theirs.get, builtins, scope)
  }

  # Signals that this block captures one or more local variables.
  def captures -> Boolean {
    False
  }

  # Returns `True` if this block captures one or more local variables.
  def captures? -> Boolean {
    False
  }

  def available_to?(
    type: Type,
    builtins: Builtins,
    scope: TypeCheckScope
  ) -> Boolean {
    True
  }

  def resolve_return_type(
    throw_type: ?Type,
    builtins: Builtins,
    scope: TypeCheckScope
  ) -> Type {
    return_type.substitute(scope)
  }

  def yields? -> Boolean {
    False
  }

  def yield_type -> ?Type {
    Option.none
  }

  def scope_boundary? -> Boolean {
    False
  }

  def external_function? -> Boolean {
    False
  }
}

# An object used for building the type name of a block type, such as a
# MethodType.
#
# Generating the type name of a block is a bit complex, as much of the data used
# for this is optional (e.g. a block may be defined without any arguments).
# Since the logic is the same for all block types (methods, closures, etc), we
# use this separate object for building type names.
class BlockNameBuilder {
  # The buffer to use for building the type name.
  @buffer: StringBuffer

  static def new(keyword: String) -> Self {
    Self { @buffer = StringBuffer.new(keyword) }
  }

  def buffer -> StringBuffer {
    @buffer
  }

  def push(value: String) -> Self {
    @buffer.push(value)
    self
  }

  def format_type_list(table: SymbolTable!(Type), mark: String) -> Self {
    if table.empty? { return self }

    push(mark)
    push(table.symbols.iter.map do (s) { s.type.type_name }.join(', '))
    push(')')
  }

  def format_type_parameters(table: SymbolTable!(TypeParameterType)) -> Self {
    format_type_list(table: table, mark: '!(')
    self
  }

  def format_arguments(table: SymbolTable!(Type)) -> Self {
    format_type_list(table: table, mark: '(')
    self
  }

  def format_throw_type(type: ?Type) -> Self {
    let type_ref = try type.get_ref else return self

    push(' !! ')
    push(type_ref.type_name)
    self
  }

  def format_return_type(type: Type) -> Self {
    push(' -> ')
    push(type.type_name)
    self
  }

  def format_bounds(bounds: TypeParameterBounds) -> Self {
    if bounds.empty? { return self }

    push(' when ')

    for (index, param) in bounds.parameters.iter.with_index {
      let requirements = bounds[param]

      if index.positive? {
        push(', ')
      }

      push(param.name)
      push(': ')
      push(requirements.iter.map do (r) { r.type_name }.join(' + '))
    }

    self
  }
}

impl ToString for BlockNameBuilder {
  def to_string -> String {
    @buffer.to_string
  }
}

# Data available to all block types, such as the arguments symbol table.
#
# Methods, closures and lambdas all need these fields. Instead of duplicating
# these fields and methods for every block type, we provide them through this
# `BlockLayout` type.
class BlockLayout {
  # The type parameters this block defines.
  @type_parameters: SymbolTable!(TypeParameterType)

  # The arguments and their types.
  @arguments: SymbolTable!(Type)

  # The number of required arguments.
  @required_arguments: Int

  # A boolean indicating the last argument is a rest argument.
  @rest_argument: Boolean

  # The type of error this block will throw.
  @throw_type: ?Type

  # A boolean indicating if this block throws or not.
  @throws: Boolean

  # The return type of the block.
  @return_type: Type

  static def new(
    return_type: Type,
    throw_type: ?Type,
    type_parameters: SymbolTable!(TypeParameterType),
    required_arguments: Int,
    rest_argument: Boolean,
    throws: Boolean
  ) -> Self {
    Self {
      @type_parameters = type_parameters,
      @arguments = SymbolTable.new,
      @required_arguments = required_arguments,
      @rest_argument = rest_argument,
      @throws = throws,
      @return_type = return_type,
      @throw_type = throw_type
    }
  }

  def type_parameters -> SymbolTable!(TypeParameterType) {
    @type_parameters
  }

  def arguments -> SymbolTable!(Type) {
    @arguments
  }

  def required_arguments -> Int {
    @required_arguments
  }

  def define_required_argument(
    name: String,
    type: Type,
    mutable: Boolean,
  ) -> Symbol!(Type) {
    @required_arguments += 1
    @arguments.define(name: name, type: type, mutable: mutable)
  }

  def define_rest_argument(
    name: String,
    type: Type,
    mutable: Boolean,
  ) -> Symbol!(Type) {
    @rest_argument = True
    @arguments.define(name: name, type: type, mutable: mutable)
  }

  def rest_argument? -> Boolean {
    @rest_argument
  }

  def throw_type -> ?Type {
    @throw_type
  }

  def throw_type=(type: Type) -> Type {
    @throw_type = Option.some(type)
    type
  }

  def unset_throw_type {
    @throw_type = Option.none
  }

  def throws? -> Boolean {
    @throws
  }

  def throws {
    @throws = True
  }

  def return_type -> Type {
    @return_type
  }

  def return_type=(type: Type) -> Type {
    @return_type = type
  }

  def substitute(scope: TypeCheckScope) -> Self {
    let new_layout = BlockLayout.new(
      return_type: @return_type.substitute(scope),
      throw_type: @throw_type.map(do (type) { type.substitute(scope) }),
      type_parameters: @type_parameters,
      required_arguments: @required_arguments,
      rest_argument: @rest_argument,
      throws: @throws
    )

    for arg in @arguments.symbols {
      let new_type = arg.type.substitute(scope)

      new_layout
        .arguments
        .define(name: arg.name, type: new_type, mutable: arg.mutable?)
    }

    new_layout
  }
}

# A method bound to a type.
class MethodType {
  # The basic data of this method, such as its arguments.
  @layout: BlockLayout

  # The name of the method.
  @name: String

  # A boolean indicating if this is a static method or an instance method.
  @static_method: Boolean

  # Additional type parameter requirements that must be met for this method to
  # be available.
  @type_parameter_bounds: TypeParameterBounds

  # The type of value this method yields.
  @yield_type: ?Type

  # A boolean indicating this method yields a value.
  @yields: Boolean

  # A boolean indicating that this method is an external function.
  @external: Boolean

  static def new(
    name: String,
    layout: BlockLayout,
    static_method: Boolean,
    external: Boolean
  ) -> Self {
    Self {
      @layout = layout,
      @name = name,
      @static_method = static_method,
      @type_parameter_bounds = TypeParameterBounds.new,
      @yield_type = Option.none,
      @yields = False,
      @external = external
    }
  }

  def static_method? -> Boolean {
    @static_method
  }

  def instance_method? -> Boolean {
    @static_method.false?
  }

  def type_parameter_bounds -> TypeParameterBounds {
    @type_parameter_bounds
  }

  def name -> String {
    @name
  }

  def yield_type=(value: ?Type) -> ?Type {
    @yield_type = value
  }

  def yields {
    @yields = True
  }

  def yield_type_compatible?(
    with: BlockType,
    builtins: Builtins,
    scope: TypeCheckScope
  ) -> Boolean {
    let ours = yield_type
    let theirs = with.yield_type

    if ours.none? and theirs.none? { return True }

    if ours.some? and theirs.some? {
      return ours.get.type_compatible?(theirs.get, builtins, scope)
    }

    # A method that yields can't safely substitute one that doesn't, and vice-
    # versa.
    False
  }
}

impl Type for MethodType {
  def type_name -> String {
    let prefix = if static_method? { 'static def ' } else { 'def ' }
    let builder = BlockNameBuilder
      .new(prefix)
      .push(@name)
      .format_type_parameters(type_parameters)
      .format_arguments(arguments)
      .format_throw_type(throw_type)

    if yield_type {
      builder.push(' => ')
      builder.push(yield_type.get.type_name)
    } else {
      builder.format_return_type(return_type)
    }

    builder.format_bounds(@type_parameter_bounds).to_string
  }

  def type_compatible?(
    with: Type,
    builtins: Builtins,
    scope: TypeCheckScope
  ) -> Boolean {
    match let expected = with {
      as MethodType -> {
        @name == expected.name
          and block_compatible?(expected, builtins, scope)
          and yield_type_compatible?(expected, builtins, scope)
      }
      as ClassInstance -> {
        instance_of?(expected.instance_of, builtins)
      }
      as TraitInstance -> {
        implements_trait?(expected, builtins, scope)
      }
      as TypeParameterType -> {
        type_compatible_with_type_parameter?(expected, builtins, scope)
      }
      as ErrorType -> { True }
      as AnyType -> { True }
      else -> { False }
    }
  }

  def method? -> Boolean {
    True
  }

  def lookup_type(name: String) -> ?Symbol!(Type) {
    lookup_type_parameter(name)
  }

  def lookup_type_parameter(name: String) -> ?Symbol!(TypeParameterType) {
    type_parameters.get(name)
  }
}

impl BlockType for MethodType {
  def layout -> BlockLayout {
    @layout
  }

  def available_to?(
    type: Type,
    builtins: Builtins,
    scope: TypeCheckScope
  ) -> Boolean {
    let type_parameter_types = match let matched = type {
      as TraitInstance -> { matched.type_parameter_types }
      as ClassInstance -> { matched.type_parameter_types }
      else -> { return True }
    }

    type_parameter_bounds.met_by?(
      type_parameter_types: type_parameter_types,
      builtins,
      scope
    )
  }

  def resolve_return_type(
    throw_type: ?Type,
    builtins: Builtins,
    scope: TypeCheckScope
  ) -> Type {
    let type = try yield_type.get_ref else return return_type.substitute(scope)
    let vtype = type.substitute(scope)
    let etype = try throw_type.get else NeverType.new

    builtins.generator_type.new_instance(Array.new(vtype, etype))
  }

  def yields? -> Boolean {
    @yields
  }

  def yield_type -> ?Type {
    @yield_type
  }

  def scope_boundary? -> Boolean {
    True
  }

  def external_function? -> Boolean {
    @external
  }
}

# Type information about closures.
class ClosureType {
  # The basic data of this closure, such as its arguments.
  @layout: BlockLayout

  # Type parameters and the types assigned to these parameters.
  @type_parameter_types: TypeParameterTypes

  # A boolean that indicates if this closure captures one or more variables.
  @captures: Boolean

  static def new(layout: BlockLayout, captures: Boolean) -> Self {
    Self {
      @layout = layout,
      @type_parameter_types = TypeParameterTypes.new,
      @captures = captures
    }
  }
}

impl Type for ClosureType {
  def closure_or_lambda? -> Boolean {
    True
  }

  def type_name -> String {
    BlockNameBuilder
      .new('do')
      .format_type_parameters(type_parameters)
      .format_arguments(arguments)
      .format_throw_type(throw_type)
      .format_return_type(return_type)
      .to_string
  }

  def type_compatible?(
    with: Type,
    builtins: Builtins,
    scope: TypeCheckScope
  ) -> Boolean {
    match let expected = with {
      as ClosureType -> {
        block_compatible?(expected, builtins, scope)
      }
      as LambdaType -> {
        not captures? and block_compatible?(expected, builtins, scope)
      }
      as ClassInstance -> {
        instance_of?(expected.instance_of, builtins)
      }
      as TraitInstance -> {
        implements_trait?(expected, builtins, scope)
      }
      as TypeParameterType -> {
        type_compatible_with_type_parameter?(
          expected,
          builtins,
          scope
        )
      }
      as ErrorType -> { True }
      as AnyType -> { True }
      else -> { False }
    }
  }

  def lookup_type(name: String) -> ?Symbol!(Type) {
    lookup_type_parameter(name)
  }

  def lookup_type_parameter(name: String) -> ?Symbol!(TypeParameterType) {
    type_parameters.get(name)
  }

  def substitute(scope: TypeCheckScope) -> Self {
    ClosureType.new(layout: @layout.substitute(scope), captures: @captures)
  }
}

impl BlockType for ClosureType {
  def layout -> BlockLayout {
    @layout
  }

  def captures? -> Boolean {
    @captures
  }

  def captures -> Boolean {
    @captures = True
  }
}

# Type information about lambdas.
class LambdaType {
  # The basic data of this lambda, such as its arguments.
  @layout: BlockLayout

  static def new(layout: BlockLayout) -> Self {
    Self { @layout = layout }
  }
}

impl Type for LambdaType {
  def closure_or_lambda? -> Boolean {
    True
  }

  def lambda? -> Boolean {
    True
  }

  def type_name -> String {
    BlockNameBuilder
      .new('lambda')
      .format_type_parameters(type_parameters)
      .format_arguments(arguments)
      .format_throw_type(throw_type)
      .format_return_type(return_type)
      .to_string
  }

  def type_compatible?(
    with: Type,
    builtins: Builtins,
    scope: TypeCheckScope
  ) -> Boolean {
    match let expected = with {
      as LambdaType -> {
        block_compatible?(expected, builtins, scope)
      }
      # Lambdas can safely substitute a closure, but not the other way around.
      # This is because when we expect a lambda, we may not be able to handle a
      # closure that captures any variables.
      as ClosureType -> {
        block_compatible?(expected, builtins, scope)
      }
      as ClassInstance -> {
        instance_of?(expected.instance_of, builtins)
      }
      as TraitInstance -> {
        implements_trait?(expected, builtins, scope)
      }
      as TypeParameterType -> {
        type_compatible_with_type_parameter?(expected, builtins, scope)
      }
      as ErrorType -> { True }
      as AnyType -> { True }
      else -> { False }
    }
  }

  def lookup_type(name: String) -> ?Symbol!(Type) {
    lookup_type_parameter(name)
  }

  def lookup_type_parameter(name: String) -> ?Symbol!(TypeParameterType) {
    type_parameters.get(name)
  }

  def substitute(scope: TypeCheckScope) -> Self {
    LambdaType.new(@layout.substitute(scope))
  }
}

impl BlockType for LambdaType {
  def layout -> BlockLayout {
    @layout
  }

  def scope_boundary? -> Boolean {
    True
  }
}

# Type information of an Inko trait.
class TraitType {
  # The name of the trait.
  @name: String

  # The required methods objects must implement.
  @required_methods: SymbolTable!(MethodType)

  # The default methods provided by this trait.
  @default_methods: SymbolTable!(MethodType)

  # The type parameters this trait defines.
  @type_parameters: SymbolTable!(TypeParameterType)

  # The traits this trait requires to be implemented first.
  @required_traits: Array!(TraitInstance)

  # The traits available to all objects that implement this trait.
  @default_traits: Array!(TraitInstance)

  static def new(
    name: String,
    required_traits: Array!(TraitInstance),
    default_traits: Array!(TraitInstance)
  ) -> Self {
    Self {
      @name = name,
      @required_methods = SymbolTable.new,
      @default_methods = SymbolTable.new,
      @type_parameters = SymbolTable.new,
      @required_traits = required_traits,
      @default_traits = default_traits
    }
  }

  def name -> String {
    @name
  }

  def type_parameters -> SymbolTable!(TypeParameterType) {
    @type_parameters
  }

  def default_methods -> SymbolTable!(MethodType) {
    @default_methods
  }

  def required_methods -> SymbolTable!(MethodType) {
    @required_methods
  }

  def required_traits -> Array!(TraitInstance) {
    @required_traits
  }

  def default_traits -> Array!(TraitInstance) {
    @default_traits
  }
}

impl Equal for TraitType {}
impl Hash for TraitType {}

impl Type for TraitType {
  def type_name -> String {
    format_type_name(name: @name, type_parameters: @type_parameters)
  }

  def lookup_type(name: String) -> ?Symbol!(TypeParameterType) {
    lookup_type_parameter(name)
  }

  def lookup_type_parameter(name: String) -> ?Symbol!(TypeParameterType) {
    @type_parameters.get(name)
  }

  def initialise? -> Boolean {
    @type_parameters.length.positive?
  }

  def number_of_type_parameters -> Int {
    @type_parameters.length
  }

  def new_instance(type_arguments: Array!(Type)) -> TraitInstance {
    let instance = TraitInstance.new(self)

    instance
      .type_parameter_types
      .assign_in_order(table: @type_parameters, arguments: type_arguments)

    instance
  }

  def type_compatible?(
    with: Type,
    builtins: Builtins,
    scope: TypeCheckScope
  ) -> Boolean {
    match let expected = with {
      as TraitType -> { self.same_object?(expected) }
      as SelfType -> {
        type_compatible?(scope.self_type.new_instance, builtins, scope)
      }
      as TypeParameterType -> {
        type_compatible_with_type_parameter?(expected, builtins, scope)
      }
      as ErrorType -> { True }
      as AnyType -> { True }
      else -> { False }
    }
  }
}

# An instance of an Inko trait.
class TraitInstance {
  # The trait `self` is an instance of.
  @instance_of: TraitType

  # Type parameters and the types assigned to these parameters.
  @type_parameter_types: TypeParameterTypes

  static def new(instance_of: TraitType) -> Self {
    Self {
      @instance_of = instance_of,
      @type_parameter_types = TypeParameterTypes.new
    }
  }

  def instance_of -> TraitType {
    @instance_of
  }

  def type_parameter_types -> TypeParameterTypes {
    @type_parameter_types
  }

  def type_compatible_with_trait?(
    with: TraitInstance,
    builtins: Builtins,
    scope: TypeCheckScope
  ) -> Boolean {
    if @instance_of.same_object?(with.instance_of) {
      return @type_parameter_types
        .type_compatible?(with.type_parameter_types, builtins, scope)
    }

    for instance in @instance_of.required_traits {
      if instance.type_compatible?(with, builtins, scope) { return True }
    }

    for instance in @instance_of.default_traits {
      if instance.type_compatible?(with, builtins, scope) { return True }
    }

    False
  }
}

impl Type for TraitInstance {
  def type_name -> String {
    format_type_name(
      name: @instance_of.name,
      type_parameters: @instance_of.type_parameters,
      type_parameter_types: @type_parameter_types
    )
  }

  def number_of_type_parameters -> Int {
    @instance_of.type_parameters.length
  }

  def lookup_method(name: String) -> ?Symbol!(MethodType) {
    let src = @instance_of

    src
      .default_methods
      .get(name)
      .else { src.required_methods.get(name) }
      .else { src.required_traits.iter.find_some do (t) { t.lookup_method(name) } }
      .else { src.default_traits.iter.find_some do (t) { t.lookup_method(name) } }
  }

  def lookup_type(name: String) -> ?Symbol!(Type) {
    @instance_of.lookup_type(name)
  }

  def lookup_type_parameter(name: String) -> ?Symbol!(TypeParameterType) {
    @instance_of.lookup_type_parameter(name)
  }

  def lookup_type_parameter_type(parameter: TypeParameterType) -> ?Type {
    @type_parameter_types.get(parameter)
  }

  def type_compatible?(
    with: Type,
    builtins: Builtins,
    scope: TypeCheckScope
  ) -> Boolean {
    match let expected = with {
      as TraitInstance -> {
        type_compatible_with_trait?(expected, builtins, scope)
      }
      as TypeParameterType -> {
        type_compatible_with_type_parameter?(expected, builtins, scope)
      }
      as SelfType -> {
        type_compatible?(scope.self_type.new_instance, builtins, scope)
      }
      as ErrorType -> { True }
      as AnyType -> { True }
      else -> { False }
    }
  }
}

# A trait implemented for an object.
class TraitImplementation {
  # The trait type that is implemented.
  @type: TraitInstance

  # Additional type parameter requirements that must be met for this trait to be
  # available.
  #
  # Type parameter bounds are evaluated against an initialised trait. Consider
  # this example:
  #
  #     impl Equal for Array when T: Equal {
  #       # ...
  #     }
  #
  # Here the `Equal` trait would only be available to `Array` whenever `T` is
  # assigned any type that also implements `Equal`.
  @bounds: TypeParameterBounds

  static def new(type: TraitInstance) -> Self {
    Self { @type = type, @bounds = TypeParameterBounds.new }
  }

  def type -> TraitInstance {
    @type
  }

  def bounds -> TypeParameterBounds {
    @bounds
  }
}

# An attribute defined for an object.
class AttributeType {
  # The public type of the attribute.
  #
  # This is the type as defined by the user.
  @public_type: Type

  # The internal type of the attribute, used when referring to an attribute.
  #
  # If the attribute is or contains a type parameter, those type parameters are
  # turned into rigid type parameters.
  @internal_type: Type

  static def new(public_type: Type, internal_type: Type) -> Self {
    Self { @public_type = public_type, @internal_type = internal_type }
  }

  def public_type -> Type {
    @public_type
  }

  def internal_type -> Type {
    @internal_type
  }
}

# An Inko class.
class ClassType {
  # The name of the class.
  @name: String

  # The instance attributes defined on this class.
  @attributes: SymbolTable!(AttributeType)

  # The static methods defined on this class.
  @static_methods: SymbolTable!(MethodType)

  # The instance methods defined on this class.
  @instance_methods: SymbolTable!(MethodType)

  # The type parameters this class defines.
  @type_parameters: SymbolTable!(TypeParameterType)

  # The traits this class implements.
  @implemented_traits: Map!(TraitType, TraitImplementation)

  # If the type is a built-in type or not.
  @builtin: Boolean

  static def builtin(name: String) -> Self {
    Self {
      @name = name,
      @attributes = SymbolTable.new,
      @static_methods = SymbolTable.new,
      @instance_methods = SymbolTable.new,
      @type_parameters = SymbolTable.new,
      @implemented_traits = Map.new,
      @builtin = True
    }
  }

  static def new(name: String) -> Self {
    Self {
      @name = name,
      @attributes = SymbolTable.new,
      @static_methods = SymbolTable.new,
      @instance_methods = SymbolTable.new,
      @type_parameters = SymbolTable.new,
      @implemented_traits = Map.new,
      @builtin = False
    }
  }

  def name -> String {
    @name
  }

  def attributes -> SymbolTable!(AttributeType) {
    @attributes
  }

  def static_methods -> SymbolTable!(MethodType) {
    @static_methods
  }

  def instance_methods -> SymbolTable!(MethodType) {
    @instance_methods
  }

  def type_parameters -> SymbolTable!(TypeParameterType) {
    @type_parameters
  }

  def implemented_traits -> Map!(TraitType, TraitImplementation) {
    @implemented_traits
  }

  def add_trait_implementation(
    implementation: TraitImplementation
  ) -> TraitImplementation {
    @implemented_traits[implementation.type.instance_of] = implementation
  }

  def remove_trait_implementation(
    implementation: TraitImplementation
  ) -> ?TraitImplementation {
    @implemented_traits.remove(implementation.type.instance_of)
  }

  def define_attribute(name: String, type: Type) -> Symbol!(AttributeType) {
    let internal = if initialise? {
      let scope = RigidTypeScope.new(self)

      for sym in type_parameters.symbols {
        let param = sym.type

        scope.assign_type_parameter(param, RigidTypeParameterType.new(param))
      }

      type.substitute(scope)
    } else {
      type
    }

    let attr = AttributeType.new(public_type: type, internal_type: internal)

    @attributes.define(name: name, type: attr)
  }

  def implements_trait?(
    type: TraitInstance,
    builtins: Builtins,
    scope: TypeCheckScope
  ) -> Boolean {
    let trait_impl =
      try implemented_traits.get(type.instance_of).get else return False

    # ClassType types can never be generic (e.g. Array itself is not generic,
    # but instances of Array are), so we don't need to check any bounds.
    trait_impl
      .type
      .type_parameter_types
      .type_compatible?(type.type_parameter_types, builtins, scope)
  }

  def builtin? -> Boolean {
    @builtin
  }
}

impl Type for ClassType {
  def type_name -> String {
    format_type_name(name: @name, type_parameters: @type_parameters)
  }

  def lookup_type(name: String) -> ?Symbol!(TypeParameterType) {
    lookup_type_parameter(name)
  }

  def lookup_type_parameter(name: String) -> ?Symbol!(TypeParameterType) {
    @type_parameters.get(name)
  }

  def lookup_method(name: String) -> ?Symbol!(MethodType) {
    @static_methods.get(name)
  }

  def initialise? -> Boolean {
    @type_parameters.length.positive?
  }

  def number_of_type_parameters -> Int {
    @type_parameters.length
  }

  def new_instance(type_arguments: Array!(Type)) -> ClassInstance {
    let instance = ClassInstance.new(self)

    instance
      .type_parameter_types
      .assign_in_order(table: @type_parameters, arguments: type_arguments)

    instance
  }

  def type_compatible?(
    with: Type,
    builtins: Builtins,
    scope: TypeCheckScope
  ) -> Boolean {
    match let expected = with {
      as ClassType -> { self.same_object?(expected) }
      as SelfType -> {
        type_compatible?(scope.self_type.new_instance, builtins, scope)
      }
      as TypeParameterType -> {
        type_compatible_with_type_parameter?(expected, builtins, scope)
      }
      as ErrorType -> { True }
      as AnyType -> { True }
      else -> { False }
    }
  }
}

# An instance of an Inko class.
class ClassInstance {
  # The class `self` is an instance of.
  @instance_of: ClassType

  # Type parameters and the types assigned to these parameters.
  @type_parameter_types: TypeParameterTypes

  static def new(
    instance_of: ClassType,
    type_parameter_types: TypeParameterTypes,
  ) -> Self {
    Self {
      @instance_of = instance_of,
      @type_parameter_types = type_parameter_types
    }
  }

  def instance_of -> ClassType {
    @instance_of
  }

  def type_parameter_types -> TypeParameterTypes {
    @type_parameter_types
  }
}

impl Type for ClassInstance {
  def type_name -> String {
    format_type_name(
      name: @instance_of.name,
      type_parameters: @instance_of.type_parameters,
      type_parameter_types: @type_parameter_types
    )
  }

  def number_of_type_parameters -> Int {
    @instance_of.type_parameters.length
  }

  def lookup_attribute(name: String) -> ?Symbol!(AttributeType) {
    @instance_of.attributes.get(name)
  }

  def lookup_method(name: String) -> ?Symbol!(MethodType) {
    @instance_of.instance_methods.get(name)
  }

  def lookup_type(name: String) -> ?Symbol!(TypeParameterType) {
    @instance_of.lookup_type(name)
  }

  def lookup_type_parameter(name: String) -> ?Symbol!(TypeParameterType) {
    @instance_of.lookup_type_parameter(name)
  }

  def lookup_type_parameter_type(parameter: TypeParameterType) -> ?Type {
    @type_parameter_types.get(parameter)
  }

  def assign_type_parameter(parameter: TypeParameterType, type: Type) {
    @type_parameter_types[parameter] = type
  }

  def object_instance_of?(type: ClassType) -> Boolean {
    @instance_of.same_object?(type)
  }

  def implements_trait?(
    type: TraitInstance,
    builtins: Builtins,
    scope: TypeCheckScope
  ) -> Boolean {
    let trait_impl = try {
      @instance_of.implemented_traits.get(type.instance_of).get
    } else {
      return False
    }

    if not trait_impl.bounds.met_by?(@type_parameter_types, builtins, scope) {
      return False
    }

    trait_impl
      .type
      .type_parameter_types
      .type_compatible?(type.type_parameter_types, builtins, scope)
  }

  def type_compatible?(
    with: Type,
    builtins: Builtins,
    scope: TypeCheckScope
  ) -> Boolean {
    match let expected = with {
      as ClassInstance -> {
        if not @instance_of.same_object?(expected.instance_of) { return False }

        @type_parameter_types
          .type_compatible?(expected.type_parameter_types, builtins, scope)
      }
      as TraitInstance -> { implements_trait?(expected, builtins, scope) }
      as TypeParameterType -> {
        type_compatible_with_type_parameter?(expected, builtins, scope)
      }
      as SelfType -> {
        type_compatible?(scope.self_type.new_instance, builtins, scope)
      }
      as ErrorType -> { True }
      as AnyType -> { True }
      else -> { False }
    }
  }

  def substitute(scope: TypeCheckScope) -> Self {
    if number_of_type_parameters.zero? { return self }

    ClassInstance.new(
      instance_of: @instance_of,
      type_parameter_types: @type_parameter_types.substitute(scope)
    )
  }
}

# Type information for an Inko module.
class ModuleType {
  # The name of the module.
  @name: ModuleName

  # The methods defined in this module.
  @methods: SymbolTable!(MethodType)

  # The types and constants defined in this module.
  @constants: SymbolTable!(Type)

  # The symbols available to this module, including imported ones.
  @globals: SymbolTable!(Type)

  static def new(name: ModuleName) -> Self {
    Self {
      @name = name,
      @methods = SymbolTable.new,
      @constants = SymbolTable.new,
      @globals = SymbolTable.new
    }
  }

  def name -> ModuleName {
    @name
  }

  def constants -> SymbolTable!(Type) {
    @constants
  }

  def methods -> SymbolTable!(MethodType) {
    @methods
  }

  def globals -> SymbolTable!(Type) {
    @globals
  }

  def defines?(name: String) -> Boolean {
    @globals.get(name).else { @methods.get(name) }.some?
  }

  def define_constant(name: String, type: Type) {
    @constants.define(name: name, type: type)
    @globals.define(name: name, type: type)
  }

  def define_method(name: String, type: MethodType) {
    # External functions can't be imported from other modules, and calling them
    # doesn't depend on runtime lookups. As such, we only need/should define
    # them as a global.
    if not type.external_function? { @methods.define(name: name, type: type) }

    @globals.define(name: name, type: type)
  }
}

impl Type for ModuleType {
  def type_name -> String {
    @name.to_string
  }

  def lookup_type(name: String) -> ?Symbol!(Type) {
    @globals.get(name)
  }

  def lookup_method(name: String) -> ?Symbol!(MethodType) {
    let sym = @globals.get(name)

    if sym.some? and sym.get.type.method?  { return sym as ?Symbol!(MethodType) }

    Option.none
  }

  def type_compatible?(
    with: Type,
    builtins: Builtins,
    scope: TypeCheckScope
  ) -> Boolean {
    match let expected = with {
      as ModuleType -> { expected.same_object?(self) }
      as ClassInstance -> {
        expected.object_instance_of?(builtins.module_type)
      }
      as TraitInstance -> {
        builtins.module_type
          .implements_trait?(type: expected, builtins, scope)
      }
      as TypeParameterType -> {
        type_compatible_with_type_parameter?(expected, builtins, scope)
      }
      as SelfType -> {
        type_compatible?(scope.self_type.new_instance, builtins, scope)
      }
      as ErrorType -> { True }
      as AnyType -> { True }
      else -> { False }
    }
  }
}

# Returns a type name for an object or trait type.
def format_type_name(
  name: String,
  type_parameters: SymbolTable!(TypeParameterType),
  type_parameter_types: TypeParameterTypes,
) -> String {
  if type_parameters.empty? { return name }

  let buffer = StringBuffer.new(name, '!(')

  for (index, param) in type_parameters.symbols.iter.with_index {
    if index.positive? { buffer.push(', ') }

    let type = type_parameter_types.get(param.type)

    buffer.push(
      if type { type.get.type_name } else { param.type.type_name }
    )
  }

  buffer.push(')')
  buffer.to_string
}
