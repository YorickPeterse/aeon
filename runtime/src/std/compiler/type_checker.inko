# Types for defining and checking types.
import std::compiler::ast::blocks::*
import std::compiler::ast::body::Body
import std::compiler::ast::control_flow::*
import std::compiler::ast::imports::(Import, ImportSymbol)
import std::compiler::ast::literals::*
import std::compiler::ast::node::*
import std::compiler::ast::objects::*
import std::compiler::ast::operators::*
import std::compiler::ast::pattern_matching::*
import std::compiler::ast::send::*
import std::compiler::ast::types::(
  ClosureType as ClosureTypeNode, OptionType as OptionTypeNode,
  LambdaType as LambdaTypeNode
)
import std::compiler::ast::variables::*
import std::compiler::diagnostics::Diagnostics
import std::compiler::module_name::ModuleName
import std::compiler::module_parser::ParsedModule
import std::compiler::source_location::SourceLocation
import std::compiler::symbol_table::(Symbol, SymbolTable)
import std::compiler::types::*
import std::compiler::variable_scope::VariableScope
import std::map::Map
import std::option::Option
import std::process::(panic)
import std::set::Set

# A message sent to an object that needs to be validated.
class Message {
  # The receiver of the message.
  @receiver: Type

  # The block to run in response to the message.
  @block: BlockType

  # Type parameter assignments that only live for the duration of the message.
  @type_parameter_types: TypeParameterTypes

  # The total number of (unique) arguments specified.
  @total_arguments: Int

  # The number of required arguments that have been provided.
  @required_arguments: Int

  # The keyword arguments that have been specifed.
  @keyword_arguments: Set!(String)

  # The index of the first optional argument.
  @first_optional_argument: Int

  static def new(receiver: Type, block: BlockType) -> Self {
    Self {
      @receiver = receiver,
      @block = block,
      @type_parameter_types = TypeParameterTypes.copied_from(receiver),
      @total_arguments = 0,
      @required_arguments = 0,
      @keyword_arguments = Set.new,
      @first_optional_argument = block.required_arguments
    }
  }

  def receiver -> Type {
    @receiver
  }

  def block -> BlockType {
    @block
  }

  def type_parameter_types -> TypeParameterTypes {
    @type_parameter_types
  }

  def maximum_arguments -> Int {
    @block.arguments.length
  }

  def minimum_arguments -> Int {
    @block.required_arguments
  }

  def total_arguments -> Int {
    @total_arguments
  }

  def required_arguments -> Int {
    @required_arguments
  }

  def increment_argument_count {
    @total_arguments += 1
  }

  def increment_required_arguments(index: Int) {
    if index < @first_optional_argument { @required_arguments += 1 }
  }

  def add_keyword_argument(name: String) -> Boolean {
    @keyword_arguments.insert(name)
  }

  def not_enough_arguments? -> Boolean {
    @required_arguments < @block.required_arguments
  }

  def too_many_arguments? -> Boolean {
    @total_arguments > @block.arguments.length and not @block.rest_argument?
  }
}

impl TypeCheckScope for Message {
  def self_type -> Type {
    @receiver
  }

  def lookup_type_parameter_type(parameter: TypeParameterType) -> ?Type {
    let from_local = @type_parameter_types.get(parameter)

    if from_local { return from_local }

    @receiver.lookup_type_parameter_type(parameter)
  }

  def assign_type_parameter(parameter: TypeParameterType, type: Type) {
    let rec = @receiver

    if rec.defines_type_parameter?(parameter) {
      rec.assign_type_parameter(parameter: parameter, type: type)
    } else {
      @type_parameter_types[parameter] = type
    }
  }
}

# A type-checking pass.
trait Pass {
  # Runs the pass, returning a `Boolean` that indicates if we should continue
  # running passes.
  def run(ast: Body) -> Boolean
}

# A compiler pass for defining and checking types.
#
# This trait provides various methods that (almost) every type-inference related
# pass is going to need, such as methods for resolving constants to their types.
trait TypePass {
  # Returns the type checker that is running this pass.
  def type_checker -> TypeChecker

  # Returns the `ModuleType` of the module that is being processed.
  def module -> ModuleType

  # Returns the type of a node used in a type signature.
  #
  # Constants in type signatures require slightly different rules for type
  # arguments, so we dispatch to a dedicated method for constants. For all other
  # nodes we use the regular visitor methods.
  def visit_type_node(node: TypeNode, types: TypeScope) -> Type {
    let return_type = match let matched = node {
      as Constant -> { visit_constant_as_type(node: matched, types: types) }
      as ClosureTypeNode -> { visit_closure_type(node: matched, types: types) }
      as LambdaTypeNode -> { visit_lambda_type(node: matched, types: types) }
      as OptionTypeNode -> { visit_option_type(node: matched, types: types) }
      else -> { panic('The given TypeNode is not supported') }
    }

    return_type as Type
  }

  # Returns the type of an optional node used in a type signature.
  def visit_optional_type_node(node: ?TypeNode, types: TypeScope) -> ?Type {
    node.map do (node) { visit_type_node(node: node, types: types) }
  }

  def visit_constant(node: Constant, types: TypeScope) -> Type {
    let symbol = try types.lookup_type_as_value(node.name).get else {
      type_checker
        .diagnostics
        .undefined_constant(name: node.name, location: node.location)

      return node.resolved_type = ErrorType.new
    }

    node.symbol = symbol

    let type = symbol.type

    # When no type arguments are given, we want to keep the type as-is. For
    # example, referring to `Array` should return that exact type, instead of
    # returning a type instance of `Array`.
    if node.type_arguments.empty? { return node.resolved_type = type }

    constant_as_type_instance(type: type, node: node, types: types)
  }

  def visit_constant_as_type(node: Constant, types: TypeScope) -> Type {
    let type = match node.name {
      NEVER_TYPE -> { NeverType.new }
      SELF_TYPE -> { SelfType.new }
      ANY_TYPE -> { AnyType.new }
      else -> {
        let symbol = try types.lookup_type(node.name).get else {
          type_checker
            .diagnostics
            .undefined_constant(name: node.name, location: node.location)

          return node.resolved_type = ErrorType.new
        }

        node.symbol = symbol

        symbol.type
      }
    } as Type

    constant_as_type_instance(type: type, node: node, types: types)
  }

  def visit_option_type(node: OptionTypeNode, types: TypeScope) -> Type {
    let wrapped = visit_type_node(node: node.type, types: types)
    let opt_type = try type_checker.option_object.get else {
      type_checker.diagnostics.option_type_not_found(node.location)

      return node.resolved_type = ErrorType.new
    }

    node.resolved_type = opt_type.new_instance(Array.new(wrapped))
  }

  def visit_closure_type(
    node: ClosureTypeNode,
    types: TypeScope
  ) -> ClosureType {
    let block = ClosureType.new(BlockLayout.new(AnyType.new))

    visit_block_type(
      block: block,
      arguments: node.arguments,
      type_parameters: node.type_parameters,
      throw_type: node.throw_type,
      return_type: node.return_type,
      types: types
    )

    node.resolved_type = block
  }

  def visit_lambda_type(
    node: LambdaTypeNode,
    types: TypeScope
  ) -> LambdaType {
    let block = LambdaType.new(BlockLayout.new(AnyType.new))

    visit_block_type(
      block: block,
      arguments: node.arguments,
      type_parameters: node.type_parameters,
      throw_type: node.throw_type,
      return_type: node.return_type,
      types: types
    )

    node.resolved_type = block
  }

  def visit_block_type(
    block: BlockType,
    arguments: Array!(TypeNode),
    type_parameters: Array!(DefineTypeParameter),
    throw_type: ?TypeNode,
    return_type: ?TypeNode,
    types: TypeScope
  ) -> BlockType {
    define_arguments_for_block_type(
      nodes: arguments,
      block: block,
      types: types
    )

    define_type_parameters(
      nodes: type_parameters,
      table: block.type_parameters,
      types: types
    )

    throw_type.let do (node) {
      block.throw_type = visit_type_node(node: node, types: types)
    }

    return_type.let do (node) {
      block.return_type = visit_type_node(node: node, types: types)
    }

    block
  }

  def visit_define_type_parameter(
    node: DefineTypeParameter,
    table: SymbolTable!(TypeParameterType),
    types: TypeScope
  ) {
    let req = try visit_type_parameter_requirements(node, types).get else return
    let param = TypeParameterType.new(name: node.name, required_traits: req)

    table.define(name: param.name, type: param)

    node.resolved_type = param
  }

  def visit_type_parameter_requirements(
    node: DefineTypeParameter,
    types: TypeScope
  ) -> ?Array!(TraitInstance) {
    let required = Array.new

    for const in node.required_traits {
      match let type = visit_constant_as_type(node: const, types: types) {
        as TraitInstance -> { required.push(type) }
        else -> {
          type_checker
            .diagnostics
            .not_a_trait(name: const.name, location: const.location)

          return Option.none
        }
      }
    }

    Option.some(required)
  }

  def constant_as_type_instance(
    type: Type,
    node: Constant,
    types: TypeScope
  ) -> Type {
    # Not all types can be initialised, such as Never or an already initialised
    # type.
    if node.type_arguments.length.positive? and not type.initialise? {
      type_checker
        .diagnostics
        .invalid_initialise(name: type.type_name, location: node.location)

      return node.resolved_type = ErrorType.new
    }

    if type.number_of_type_parameters != node.type_arguments.length {
      type_checker.diagnostics.invalid_number_of_type_arguments(
        expected: type.number_of_type_parameters,
        given: node.type_arguments.length,
        location: node.location
      )

      return node.resolved_type = ErrorType.new
    }

    let type_arguments = node
      .type_arguments
      .iter
      .map do (node) { visit_type_node(node: node, types: types) }
      .to_array

    node.resolved_type = type.new_instance(type_arguments)
  }

  def define_type_parameters(
    nodes: Array!(DefineTypeParameter),
    table: SymbolTable!(TypeParameterType),
    types: TypeScope
  ) {
    for param_node in nodes {
      visit_define_type_parameter(node: param_node, table: table, types: types)
    }
  }

  # Defines the argument types for a block type.
  #
  # Since block types can't refer to their argument names, the names are
  # generated automatically.
  def define_arguments_for_block_type(
    nodes: Array!(TypeNode),
    block: BlockType,
    types: TypeScope
  ) {
    for (index, node) in nodes.iter.with_index {
      block.define_required_argument(
        name: index.to_string,
        type: visit_type_node(node: node, types: types)
      )
    }
  }

  def type_compatible?(
    type: Type,
    with: Type,
    scope: TypeCheckScope,
    location: SourceLocation
  ) -> Boolean {
    let builtins = type_checker.builtins

    if type.type_compatible?(with, builtins, scope) { return True }

    type_checker.diagnostics.wrong_type(
      expected: with.type_name,
      given: type.type_name,
      location: location
    )

    False
  }
}

# A compiler pass for type-checking expressions, such as numerical operations.
trait ExpressionTypePass: TypePass {
  def visit_expressions(
    node: Body,
    types: TypeScope,
    variables: VariableScope
  ) -> Type {
    let mut return_type: Type = type_checker.builtins.nil_singleton

    for child in node.children {
      return_type =
        visit_expression(node: child, types: types, variables: variables)
    }

    node.resolved_type = return_type
  }

  def visit_expression(
    node: Node,
    types: TypeScope,
    variables: VariableScope
  ) -> Type {
    match let matched = node {
      as IntegerLiteral -> { visit_integer_literal(matched) }
      as FloatLiteral -> { visit_float_literal(matched) }
      as StringLiteral -> { visit_string_literal(matched) }
      as Constant -> { visit_constant(node: matched, types: types) }
      as SelfObject -> { visit_self(node: matched, types: types) }
      as Identifier -> {
        visit_identifier(node: matched, types: types, variables: variables)
      }
      as Send when matched.instruction? -> {
        visit_instruction(node: matched, types: types, variables: variables)
      }
      as Send -> {
        visit_send(node: matched, types: types, variables: variables)
      }
      as Attribute -> {
        visit_attribute(node: matched, types: types, variables: variables)
      }
      as Global -> { visit_global(node: matched, types: types) }
      as DefineLocalVariable -> {
        visit_define_local(node: matched, types: types, variables: variables)
      }
      as AssignLocal -> {
        visit_assign_local(node: matched, types: types, variables: variables)
      }
      as AssignAttribute -> {
        visit_assign_attribute(node: matched, types: types, variables: variables)
      }
      as Return -> {
        visit_return(node: matched, types: types, variables: variables)
      }
      as Throw -> {
        visit_throw(node: matched, types: types, variables: variables)
      }
      as Try -> { visit_try(node: matched, types: types, variables: variables) }
      as TryPanic -> {
        visit_try_panic(node: matched, types: types, variables: variables)
      }
      as Match -> {
        visit_match(node: matched, types: types, variables: variables)
      }
      as BasicClosure -> {
        visit_basic_closure(node: matched, types: types, variables: variables)
      }
      as Closure -> {
        visit_closure(node: matched, types: types, variables: variables)
      }
      as Lambda -> {
        visit_lambda(node: matched, types: types, variables: variables)
      }
      as Constructor -> {
        visit_constructor(node: matched, types: types, variables: variables)
      }
      as Yield -> {
        visit_yield(node: matched, types: types, variables: variables)
      }
      as TypeCast -> {
        visit_type_cast(node: matched, types: types, variables: variables)
      }
      else -> { panic('The AST node is not supported in expressions') }
    } as Type
  }

  def visit_integer_literal(node: IntegerLiteral) -> Type {
    let type = type_checker.builtins.integer_type.new_instance

    node.resolved_type = type
  }

  def visit_float_literal(node: FloatLiteral) -> Type {
    let type = type_checker.builtins.float_type.new_instance

    node.resolved_type = type
  }

  def visit_string_literal(node: StringLiteral) -> Type {
    let type = type_checker.builtins.string_type.new_instance

    node.resolved_type = type
  }

  def visit_self(node: SelfObject, types: TypeScope) -> Type {
    let type = types.self_type

    node.resolved_type = type
  }

  def visit_identifier(
    node: Identifier,
    types: TypeScope,
    variables: VariableScope
  ) -> Type {
    let name = node.name
    let type = variables
      .lookup_with_parents(name)
      .map do (sym) {
        if not variables.symbols.contains?(sym) {
          types.block.let do (block) { block.captures }
        }

        node.symbol = sym
        sym.type
      }
      .else {
        types.lookup_method(name).map do (sym) {
          node.symbol = sym
          assign_throw_and_return_type(node: node, block: sym.type, types: types)
        }
      }
      .else {
        module.globals.get(name).map do (sym) {
          node.symbol = sym
          sym.type
        }
      }

    node.resolved_type = try type.get else {
      type_checker
        .diagnostics
        .undefined_identifier(name: name, location: node.location)

      ErrorType.new
    }
  }

  def visit_instruction(
    node: Send,
    types: TypeScope,
    variables: VariableScope
  ) -> Type {
    let name = node.message
    let loc = node.location

    # VM instructions are not part of the public API, and are an implementation
    # detail. To prevent users from using/abusing them, we only allow them to be
    # used in a limited number of places.
    if not module.name.std? {
      type_checker.diagnostics.instructions_not_available(node.location)

      return node.resolved_type = ErrorType.new
    }

    # We deliberately don't check if the given argument types are also expected.
    # The direct use of VM instructions is rare, and the amount of
    # complexity/boilerplate necessary to validate the arguments is significant.
    for arg in node.arguments {
      visit_expression(node: arg, types: types, variables: variables)
    }

    let builtins = type_checker.builtins

    # We don't expose all VM instructions to the runtime; only those that are
    # truly necessary.
    let rtype = match name {
      'set_attribute' -> { AnyType.new }
      'get_attribute' -> { AnyType.new }
      'get_true' -> { builtins.true_singleton }
      'get_false' -> { builtins.false_singleton }
      'get_nil' -> { builtins.nil_singleton }
      'get_nil_prototype' -> { builtins.nil_type }
      'get_module_prototype' -> { builtins.module_type }
      'get_string_prototype' -> { builtins.string_type }
      'get_integer_prototype' -> { builtins.integer_type }
      'get_float_prototype' -> { builtins.float_type }
      'get_trait_prototype' -> { builtins.trait_type }
      'get_array_prototype' -> { builtins.array_type }
      'get_block_prototype' -> { builtins.block_type }
      'get_hasher_prototype' -> { builtins.hasher_type }
      'get_prototype' -> { AnyType.new }
      'get_boolean_prototype' -> { builtins.boolean_type }
      'get_byte_array_prototype' -> { builtins.byte_array_type }
      'get_ffi_library_prototype' -> { builtins.ffi_library_type }
      'get_ffi_function_prototype' -> { builtins.ffi_function_type }
      'get_ffi_pointer_prototype' -> { builtins.ffi_pointer_type }
      'get_ip_socket_prototype' -> { builtins.ip_socket_type }
      'get_unix_socket_prototype' -> { builtins.unix_socket_type }
      'get_process_prototype' -> { builtins.process_type }
      'get_read_only_file_prototype' -> { builtins.read_only_file_type }
      'get_write_only_file_prototype' -> { builtins.write_only_file_type }
      'get_read_write_file_prototype' -> { builtins.read_write_file_type }
      'get_generator_prototype' -> { builtins.generator_type }
      'get_child_process_prototype' -> { builtins.child_process_type }
      'object_equals' -> { builtins.boolean_type.new_instance }
      'copy_blocks' -> { NeverType.new }
      'run_block' -> { AnyType.new }
      'integer_add' -> { builtins.integer_type.new_instance }
      'integer_div' -> { builtins.integer_type.new_instance }
      'integer_mul' -> { builtins.integer_type.new_instance }
      'integer_sub' -> { builtins.integer_type.new_instance }
      'integer_mod' -> { builtins.integer_type.new_instance }
      'integer_bitwise_and' -> { builtins.integer_type.new_instance }
      'integer_bitwise_or' -> { builtins.integer_type.new_instance }
      'integer_bitwise_xor' -> { builtins.integer_type.new_instance }
      'integer_shift_left' -> { builtins.integer_type.new_instance }
      'integer_shift_right' -> { builtins.integer_type.new_instance }
      'integer_smaller' -> { builtins.boolean_type.new_instance }
      'integer_greater' -> { builtins.boolean_type.new_instance }
      'integer_equals' -> { builtins.boolean_type.new_instance }
      'integer_greater_or_equal' -> { builtins.boolean_type.new_instance }
      'integer_smaller_or_equal' -> { builtins.boolean_type.new_instance }
      'float_add' -> { builtins.float_type.new_instance }
      'float_div' -> { builtins.float_type.new_instance }
      'float_mul' -> { builtins.float_type.new_instance }
      'float_sub' -> { builtins.float_type.new_instance }
      'float_mod' -> { builtins.float_type.new_instance }
      'float_smaller' -> { builtins.boolean_type.new_instance }
      'float_greater' -> { builtins.boolean_type.new_instance }
      'float_equals' -> { builtins.boolean_type.new_instance }
      'float_greater_or_equal' -> { builtins.boolean_type.new_instance }
      'float_smaller_or_equal' -> { builtins.boolean_type.new_instance }
      'array_length' -> { builtins.integer_type.new_instance }
      'array_at' -> { AnyType.new }
      'array_set' -> { AnyType.new }
      'array_remove' -> { AnyType.new }
      'string_size' -> { builtins.integer_type.new_instance }
      'string_length' -> { builtins.integer_type.new_instance }
      'string_equals' -> { builtins.boolean_type.new_instance }
      'string_concat' -> { builtins.string_type.new_instance }
      'string_byte' -> { builtins.integer_type.new_instance }
      'process_spawn' -> { builtins.process_type.new_instance }
      'process_send_message' -> { AnyType.new }
      'process_receive_message' -> { AnyType.new }
      'process_current' -> { builtins.process_type.new_instance }
      'process_suspend_current' -> { NeverType.new }
      'process_terminate_current' -> { NeverType.new }
      'process_set_blocking' -> { builtins.boolean_type.new_instance }
      'process_add_defer_to_caller' -> { AnyType.new }
      'process_set_pinned' -> { builtins.boolean_type.new_instance }
      'process_identifier' -> { builtins.integer_type.new_instance }
      'close' -> { NeverType.new }
      'panic' -> { NeverType.new }
      'exit' -> { NeverType.new }
      'byte_array_from_array' -> { builtins.byte_array_type.new_instance }
      'byte_array_set' -> { builtins.integer_type.new_instance }
      'byte_array_at' -> { builtins.integer_type.new_instance }
      'byte_array_remove' -> { builtins.integer_type.new_instance }
      'byte_array_length' -> { builtins.integer_type.new_instance }
      'byte_array_equals' -> { builtins.boolean_type.new_instance }
      'byte_array_to_string' -> { builtins.string_type.new_instance }
      'set_object_name' -> { builtins.string_type.new_instance }
      'module_load' -> { builtins.module_type.new_instance }
      'module_get' -> { builtins.module_type.new_instance }
      'generator_resume' -> { NeverType.new }
      'generator_value' -> { AnyType.new }
      'generator_yielded' -> { builtins.boolean_type.new_instance }
      else -> {
        type_checker.diagnostics.unknown_instruction(name: name, location: loc)
        ErrorType.new
      }
    } as Type

    node.resolved_type = rtype
  }

  def visit_send(
    node: Send,
    types: TypeScope,
    variables: VariableScope
  ) -> Type {
    let receiver = try {
      node
        .receiver.map do (node) { visit_expression(node, types, variables) }
        .get
    } else {
      types.self_type
    }

    if receiver.error? { return node.resolved_type = receiver }

    let name = node.message
    let block = if receiver.closure_or_lambda? and name == CALL_MESSAGE {
      receiver as BlockType
    } else {
      let sym = try receiver.lookup_method(name).get else {
        type_checker.diagnostics.undefined_message(
          type: receiver.type_name,
          name: name,
          location: node.location
        )

        return node.resolved_type = ErrorType.new
      }

      sym.type as BlockType
    }

    if block.external_function? and node.receiver.some? {
      type_checker.diagnostics.external_function_with_receiver(node.location)

      return node.resolved_type = ErrorType.new
    }

    node.block_type = block

    let message = Message.new(receiver: receiver, block: block)

    for node in node.arguments {
      match let matched = node {
        as KeywordArgument -> {
          visit_keyword_argument(
            node: matched,
            message: message,
            types: types,
            variables: variables
          )
        }
        else -> {
          visit_positional_argument(
            node: matched,
            message: message,
            types: types,
            variables: variables
          )
        }
      }
    }

    # Type parameters defined on the receiver may have been assigned to concrete
    # types. We need to persist these assignments for future use. Consider this
    # example:
    #
    #     let numbers = Array.new
    #
    #     numbers.push(10)
    #     numbers.push('foo')
    #
    # When the Array is first created, its type parameter T is not assigned. The
    # first push() assigns it to Int. By persisting this assignment in the
    # numbers array, we can correctly detect the second push() is invalid.
    message.type_parameter_types.copy_into_type(receiver)

    if message.not_enough_arguments? {
      type_checker.diagnostics.invalid_number_of_arguments(
        given: message.required_arguments,
        expected: message.minimum_arguments,
        location: node.location
      )

      return node.resolved_type = ErrorType.new
    }

    if message.too_many_arguments? {
      type_checker.diagnostics.invalid_number_of_arguments(
        given: message.total_arguments,
        expected: message.maximum_arguments,
        location: node.location
      )

      return node.resolved_type = ErrorType.new
    }

    let send_scope = TypeScope.new(
      module: types.module,
      self_type: receiver,
      block: types.block,
      parent: types.parent
    )

    if not block.available_to?(receiver, type_checker.builtins, send_scope) {
      type_checker.diagnostics.method_not_available(
        receiver: receiver.type_name,
        method: block.type_name,
        location: node.location
      )

      return node.resolved_type = ErrorType.new
    }

    assign_throw_and_return_type(node: node, block: block, types: message)
  }

  def visit_keyword_argument(
    node: KeywordArgument,
    message: Message,
    types: TypeScope,
    variables: VariableScope
  ) {
    let name = node.name.name
    let val = node.value
    let type = visit_expression(node: val, types: types, variables: variables)

    if not message.add_keyword_argument(name) {
      type_checker
        .diagnostics
        .duplicate_keyword_argument(argument: name, location: node.location)

      # Duplicate keyword arguments are not checked any further, as doing so
      # could lead to many additional (irrelevant) errors being produced.
      return
    }

    message.increment_argument_count

    let sym = try message.block.arguments.get(name).get else {
      type_checker
        .diagnostics
        .undefined_keyword_argument(argument: name, location: node.location)

      # If a keyword argument doesn't exist, there's no symbol to compare to or
      # argument counts to increment, so we bail out right away.
      return
    }

    type_compatible?(
      type: type,
      with: sym.type,
      scope: message,
      location: node.location
    )

    message.increment_required_arguments(sym.id)
  }

  def visit_positional_argument(
    node: Node,
    message: Message,
    types: TypeScope,
    variables: VariableScope
  ) {
    # Since we increment the number of arguments after visiting them, the total
    # number of arguments at this point equals the position of our positional
    # argument. Reusing this means we don't need to pass an additional `index`
    # argument to this method.
    let sym_opt = message.block.arguments.symbols.get(message.total_arguments)
    let type = visit_expression(node: node, types: types, variables: variables)

    message.increment_argument_count

    # When there is a rest argument, we want to type-check against the rest
    # argument type.
    #
    # When there is no rest argument, the excessive number of arguments is
    # handled in the method that visits the Send node.
    let sym = try sym_opt.get else {
      if not message.block.rest_argument? { return }

      message.block.arguments.symbols[-1]
    }

    type_compatible?(
      type: type,
      with: sym.type,
      scope: message,
      location: node.location
    )

    message.increment_required_arguments(sym.id)
  }

  def visit_try(node: Try, types: TypeScope, variables: VariableScope) -> Type {
    node.resolved_type = visit_expression(
      node: node.expression,
      types: types,
      variables: variables
    )

    node.resolved_throw_type = try_expression_throw_type(node.expression)

    if node.local_throw? {
      visit_local_try(node: node, types: types, variables: variables)
    } else {
      visit_nonlocal_try(node: node, types: types, variables: variables)
    }

    node.resolved_type.get
  }

  def visit_local_try(
    node: Try,
    types: TypeScope,
    variables: VariableScope
  ) {
    let throw_type = node.resolved_throw_type.get
    let block = try types.block.get else {
      type_checker.diagnostics.invalid_local_try(node.location)
      return
    }

    if not node.with_else? {
      block.throws

      if block.throw_type.some? and block.throw_type.get.infer? {
        block.throw_type = throw_type

        return
      }

      type_compatible?(
        type: throw_type,
        with: block.throw_type.get,
        scope: types,
        location: node.location
      )

      return
    }

    visit_try_else(node: node, types: types, variables: variables)
  }

  def visit_nonlocal_try(
    node: Try,
    types: TypeScope,
    variables: VariableScope
  ) {
    let throw_type = node.resolved_throw_type.get
    let block = try types.block_scope_boundary.get else {
      type_checker.diagnostics.invalid_try(node.location)
      return
    }

    if not node.with_else? {
      block.throws

      if block.throw_type.some? and block.throw_type.get.infer? {
        block.throw_type = throw_type

        return
      }

      let expected = try block.throw_type.get else {
        type_checker.diagnostics.unexpected_nonlocal_throw(
          type: throw_type.type_name,
          location: node.location
        )

        return
      }

      type_compatible?(
        type: throw_type,
        with: expected,
        scope: types,
        location: node.location
      )

      return
    }

    visit_try_else(node: node, types: types, variables: variables)
  }

  def visit_try_else(
    node: Try,
    types: TypeScope,
    variables: VariableScope
  ) {
    let try_type = node.resolved_type.get
    let throw_type = node.resolved_throw_type.get
    let else_vars = node.else_body.variable_scope.with_parent(variables)

    node.error_variable.let do (var) {
      else_vars.symbols.define(name: var, type: throw_type)
    }

    let else_type =
      visit_expressions(node: node.else_body, types: types, variables: else_vars)

    node.resolved_type = try_else_return_type(
      node: node,
      try_type: try_type,
      else_type: else_type,
      types: types,
    )
  }

  def visit_try_panic(
    node: TryPanic,
    types: TypeScope,
    variables: VariableScope
  ) -> Type {
    node.resolved_type = visit_expression(
      node: node.expression,
      types: types,
      variables: variables
    )

    node.resolved_throw_type = try_expression_throw_type(node.expression)
    node.resolved_type.get
  }

  def visit_attribute(
    node: Attribute,
    types: TypeScope,
    variables: VariableScope
  ) -> Type {
    let name = node.name
    let receiver = types.self_type
    let symbol = try receiver.lookup_attribute(name).get else {
      type_checker
        .diagnostics
        .undefined_attribute(
          type: receiver.type_name,
          attribute: name,
          location: node.location
        )

      return node.resolved_type = ErrorType.new
    }

    node.symbol = symbol
    node.resolved_type = symbol.type.internal_type
  }

  def visit_global(node: Global, types: TypeScope) -> Type {
    let name = node.name
    let type = module
      .lookup_method(name)
      .map do (sym) {
        node.symbol = sym
        assign_throw_and_return_type(node, block: sym.type, types)
      }
      .else {
        module.lookup_type(name).map do (sym) {
          node.symbol = sym
          sym.type
        }
      }

    node.resolved_type = try type.get else {
      type_checker
        .diagnostics
        .undefined_identifier(name: name, location: node.location)

      ErrorType.new
    }
  }

  def visit_define_local(
    node: DefineLocalVariable,
    types: TypeScope,
    variables: VariableScope
  ) -> Type {
    let name = node.name.name
    let target_type = visit_define_variable(
      value_node: node.value,
      type_node: node.value_type,
      types: types,
      variables: variables
    )

    if variables.symbols.get(name) {
      type_checker.diagnostics.redefine_local_variable(name, node.location)
    }
    else {
      variables.symbols.define(name, target_type, mutable: node.mutable?)
    }

    node.resolved_type = target_type
  }

  def visit_assign_local(
    node: AssignLocal,
    types: TypeScope,
    variables: VariableScope
  ) -> Type {
    let name = node.name.name
    let value_type =
      visit_expression(node: node.value, types: types, variables: variables)

    let symbol = try variables.lookup_with_parents(name).get else {
      type_checker
        .diagnostics
        .undefined_local_variable(name: name, location: node.location)

      return node.resolved_type = value_type
    }

    node.symbol = symbol
    node.resolved_type = value_type

    if not symbol.mutable? {
      type_checker
        .diagnostics
        .assign_immutable_local_variable(name, node.location)

      return value_type
    }

    if not type_compatible?(
      type: value_type,
      with: symbol.type,
      scope: types,
      location: node.location
    ) {
      return value_type
    }

    value_type
  }

  def visit_assign_attribute(
    node: AssignAttribute,
    types: TypeScope,
    variables: VariableScope
  ) -> Type {
    let name = node.name.name
    let existing_opt = types.self_type.lookup_attribute(name)
    let value_type =
      visit_expression(node: node.value, types: types, variables: variables)

    node.resolved_type = value_type

    let existing = try existing_opt.get else {
      type_checker.diagnostics.undefined_attribute(
        type: types.self_type.type_name,
        attribute: name,
        location: node.location
      )

      return value_type
    }

    node.symbol = existing

    if not type_compatible?(
      type: value_type,
      with: existing.type.internal_type,
      scope: types,
      location: node.location
    ) {
      return value_type
    }

    value_type
  }

  def visit_define_variable(
    value_node: Node,
    type_node: ?TypeNode,
    types: TypeScope,
    variables: VariableScope
  ) -> Type {
    let assigned_type =
      visit_expression(node: value_node, types: types, variables: variables)

    let defined_type = visit_optional_type_node(node: type_node, types: types)
    let mut target_type = try defined_type.get else assigned_type

    defined_type.let do (defined) {
      if defined.self_type? {
        type_checker.diagnostics.invalid_self_type(type_node.get.location)

        # Using Self in a variable makes no sense, so we overwrite the target
        # type with an error to prevent a cascade of type errors.
        target_type = ErrorType.new
      }
    }

    defined_type.let do (defined) {
      type_compatible?(
        type: assigned_type,
        with: defined,
        scope: types,
        location: value_node.location
      )
    }

    target_type
  }

  def visit_match(
    node: Match,
    types: TypeScope,
    variables: VariableScope
  ) -> Type {
    let input_binding = node.binding.map do (node) { node.name }
    let input_type = node.expression.map do (expr) {
      visit_expression(node: expr, types: types, variables: variables)
    }

    if node.cases.empty? {
      type_checker.diagnostics.match_without_cases(node.location)

      return node.resolved_type = ErrorType.new
    }

    if not node.else_branch {
      type_checker.diagnostics.match_not_exhaustive(node.location)

      return node.resolved_type = ErrorType.new
    }

    let case_types = Array.new

    for case in node.cases {
      let type = match let matched = case {
        as MatchExpressions -> {
          if input_type {
            visit_match_expressions_with_input(
              node: matched,
              input_type: input_type.get,
              input_binding: input_binding,
              types: types,
              variables: variables
            )
          }
          else {
            visit_match_expressions_without_input(
              node: matched,
              types: types,
              variables: variables
            )
          }
        }
        as MatchType -> {
          visit_match_type(
            node: matched,
            input_type: input_type,
            input_binding: input_binding,
            types: types,
            variables: variables
          )
        }
        else -> { panic('This MatchCase node is not supported') }
      }

      if type.error? { return node.resolved_type = type }
      case_types.push(type)
    }

    let else_type = visit_match_else(
      node: node.else_branch.get,
      input_type: input_type,
      input_binding: input_binding,
      types: types,
      variables: variables
    )

    node.resolved_type = match_return_type(
      case_types: case_types,
      else_type: else_type,
      scope: types,
      location: node.location
    )
  }

  def visit_match_expressions_with_input(
    node: MatchExpressions,
    input_type: Type,
    input_binding: ?String,
    types: TypeScope,
    variables: VariableScope
  ) -> Type {
    let body_vars = node.body.variable_scope.with_parent(variables)

    node.body.type_scope = types

    input_binding.let do (binding) {
      body_vars.symbols.define(name: binding, type: input_type)
    }

    let match_type = try type_checker.pattern_match_trait.get else {
      type_checker.diagnostics.match_trait_not_found(node.location)

      return node.resolved_type = ErrorType.new
    }

    let match_ins = match_type.new_instance(Array.new(input_type))

    for node in node.patterns {
      let builtins = type_checker.builtins
      let pattern_type =
        visit_expression(node: node, types: types, variables: body_vars)

      if not pattern_type.type_compatible?(with: match_ins, builtins, types) {
        type_checker.diagnostics.match_trait_not_implemented(
          type: pattern_type.type_name,
          match_trait: match_ins.type_name,
          location: node.location
        )
      }
    }

    node.guard.let do (guard) {
      visit_match_guard(node: guard, types: types, variables: body_vars)
    }

    node.resolved_type = visit_expressions(
      node: node.body,
      types: types,
      variables: body_vars
    )
  }

  def visit_match_expressions_without_input(
    node: MatchExpressions,
    types: TypeScope,
    variables: VariableScope
  ) -> Type {
    let body_vars = node.body.variable_scope.with_parent(variables)

    node.body.type_scope = types

    for node in node.patterns {
      require_boolean_type(
        type: visit_expression(node: node, types: types, variables: body_vars),
        location: node.location
      )
    }

    node.guard.let do (guard) {
      visit_match_guard(node: guard, types: types, variables: body_vars)
    }

    node.resolved_type = visit_expressions(
      node: node.body,
      types: types,
      variables: body_vars
    )
  }

  def visit_match_type(
    node: MatchType,
    input_type: ?Type,
    input_binding: ?String,
    types: TypeScope,
    variables: VariableScope
  ) -> Type {
    let pattern = node.pattern
    let match_type = try {
      types
        .lookup_type(pattern.name)
        .map do (sym) {
          pattern.symbol = sym
          sym.type.new_instance
        }
        .get
    } else {
      type_checker.diagnostics.undefined_constant(pattern.name, pattern.location)
      ErrorType.new
    }

    pattern.resolved_type = match_type

    let body_vars = node.body.variable_scope.with_parent(variables)

    node.body.type_scope = types

    if not input_type {
      type_checker.diagnostics.unavailable_type_match(node.location)
    }

    input_binding.let do (binding) {
      body_vars.symbols.define(name: binding, type: match_type)
    }

    node.guard.let do (guard) {
      visit_match_guard(node: guard, types: types, variables: body_vars)
    }

    node.resolved_type = visit_expressions(
      node: node.body,
      types: types,
      variables: body_vars
    )
  }

  def visit_match_else(
    node: MatchElse,
    input_type: ?Type,
    input_binding: ?String,
    types: TypeScope,
    variables: VariableScope
  ) -> Type {
    let body_vars = node.body.variable_scope.with_parent(variables)

    node.body.type_scope = types

    input_binding.let do (binding) {
      body_vars.symbols.define(name: binding, type: input_type.get)
    }

    node.resolved_type = visit_expressions(
      node: node.body,
      types: types,
      variables: body_vars
    )
  }

  def visit_match_guard(
    node: Node,
    types: TypeScope,
    variables: VariableScope
  ) {
    let guard_type =
      visit_expression(node: node, types: types, variables: variables)

    # Pattern matching guards must always return an instance of Boolean.
    # Requiring a Boolean means that during code generation we don't have to
    # make use of if_true/if/etc.
    require_boolean_type(type: guard_type, location: node.location)
  }

  def visit_constructor(
    node: Constructor,
    types: TypeScope,
    variables: VariableScope
  ) -> Type {
    let tname = node.name
    let type = if tname == SELF_TYPE {
      types.self_type
    } else {
      try types.lookup_type(tname).map do (sym) { sym.type }.get else {
        type_checker.diagnostics.undefined_constant(node.name, node.location)

        return node.resolved_type = ErrorType.new
      }
    }

    let class_type = match let matched = type {
      as ClassType -> { matched }
      else -> {
        type_checker
          .diagnostics
          .not_an_object(name: node.name, location: node.location)

        return node.resolved_type = ErrorType.new
      }
    }

    if class_type.builtin? {
      type_checker.diagnostics.unsupported_constructor(node.location)

      return node.resolved_type = ErrorType.new
    }

    let instance = class_type.new_instance
    let assigned = Set.new
    let scope = TypeScope.new(
      module: types.module,
      self_type: instance,
      block: types.block,
      parent: types.parent
    )

    for attr in node.attributes {
      let name = attr.name
      let loc = attr.location
      let sym = instance.lookup_attribute(name)
      let vtype =
        visit_expression(node: attr.value, types: types, variables: variables)

      if assigned.contains?(name) {
        type_checker
          .diagnostics
          .already_assigned_attribute(name: name, location: loc)
      } else if sym.none? {
        type_checker.diagnostics.undefined_attribute(
          type: class_type.type_name,
          attribute: name,
          location: loc
        )
      } else {
        type_compatible?(
          type: vtype,
          with: sym.get.type.public_type,
          scope: scope,
          location: loc
        )

        assigned.insert(name)
      }
    }

    for attr in class_type.attributes.symbols {
      if not assigned.contains?(attr.name) {
        type_checker.diagnostics.unassigned_attribute(attr.name, node.location)
      }
    }

    node.resolved_type = instance
  }

  def visit_type_cast(
    node: TypeCast,
    types: TypeScope,
    variables: VariableScope
  ) -> Type {
    let from =
      visit_expression(node: node.expression, types: types, variables: variables)

    let to = visit_type_node(node: node.cast_to, types: types)
    let builtins = type_checker.builtins

    # When casting, we want to allow casting of one trait to another. Take for
    # example a graph of Node (a trait) objects. When writing tests we may want
    # to get a Node, assert it's of type X (a trait that requires Node, or an
    # object that implements it), then cast it to X.
    #
    # To support this, we allow casting of `A` to `B` if `A` is compatible with
    # `B`, or if `B` is compatible with `A`; but not if neither cases are true.
    #
    # Some examples:
    #
    # | Source type | Target type | Result | Notes
    # |:------------|:------------|:-------|:----------------------------------
    # | String      | ToString    | OK     | String implements ToString
    # | ToString    | String      | OK     | Unsafe without a runtime check
    # | String      | Int     | not OK | Both are different objects
    # | Object      | String      | OK     | All objects implement Object
    # | ToString    | ToInt   | not OK | The traits have nothing in common
    if not from.type_compatible?(with: to, builtins, types)
      and not to.type_compatible?(with: from, builtins, types)
    {
      type_checker
        .diagnostics
        .invalid_cast(from.type_name, to.type_name, node.location)
    }

    node.resolved_type = to.substitute(RigidTypeScope.from_type_scope(types))
  }

  def visit_basic_closure(
    node: BasicClosure,
    types: TypeScope,
    variables: VariableScope
  ) -> Type {
    let layout = BlockLayout
      .new(return_type: InferType.new, throw_type: Option.some(InferType.new))

    let closure = ClosureType.new(layout)
    let body_vars = node.body.variable_scope.with_parent(variables)
    let body_types = node.body.type_scope = TypeScope.new(
      module: module,
      self_type: types.self_type,
      block: Option.some(closure),
      parent: Option.some(types)
    )

    let returned = visit_expressions(
      node: node.body,
      types: body_types,
      variables: body_vars
    )

    if closure.return_type.infer? { closure.return_type = returned }

    closure.throw_type.let do (type) {
      if type.infer? { closure.unset_throw_type }
    }

    node.resolved_type = closure
  }

  def visit_closure(
    node: Closure,
    types: TypeScope,
    variables: VariableScope
  ) -> Type {
    let layout = BlockLayout
      .new(return_type: InferType.new, throw_type: Option.some(InferType.new))

    let closure = ClosureType.new(layout)
    let body_types = node.body.type_scope = TypeScope.new(
      module: module,
      self_type: types.self_type,
      block: Option.some(closure),
      parent: Option.some(types)
    )

    define_anonymous_block_type(
      block: closure,
      arguments: node.arguments,
      type_parameters: node.type_parameters,
      throw_type: node.throw_type,
      return_type: node.return_type,
      body: node.body,
      types: body_types,
      variables: node.body.variable_scope.with_parent(variables),
      location: node.location
    )

    node.resolved_type = closure
  }

  def visit_lambda(
    node: Lambda,
    types: TypeScope,
    variables: VariableScope
  ) -> Type {
    let layout = BlockLayout
      .new(return_type: InferType.new, throw_type: Option.some(InferType.new))

    let lambda_type = LambdaType.new(layout)
    let body_types = node.body.type_scope = TypeScope.new(
      module: module,
      self_type: types.self_type,
      block: Option.some(lambda_type)
    )

    define_anonymous_block_type(
      block: lambda_type,
      arguments: node.arguments,
      type_parameters: node.type_parameters,
      throw_type: node.throw_type,
      return_type: node.return_type,
      body: node.body,
      types: body_types,
      variables: node.body.variable_scope,
      location: node.location
    )

    node.resolved_type = lambda_type
  }

  def visit_define_argument(
    node: DefineArgument,
    block: BlockType,
    types: TypeScope,
    rigid_types: RigidTypeScope,
    variables: VariableScope
  ) -> Type {
    match let matched = node {
      as DefineRequiredArgument -> {
        visit_define_required_argument(
          node: matched,
          block: block,
          types: types,
          rigid_types: rigid_types,
          variables: variables
        )
      }
      as DefineOptionalArgument -> {
        visit_define_optional_argument(
          node: matched,
          block: block,
          types: types,
          rigid_types: rigid_types,
          variables: variables
        )
      }
      as DefineUntypedArgument -> {
        visit_define_untyped_argument(
          node: matched,
          block: block,
          types: types,
          variables: variables
        )
      }
      as DefineRestArgument -> {
        visit_define_rest_argument(
          node: matched,
          block: block,
          types: types,
          rigid_types: rigid_types,
          variables: variables
        )
      }
      else -> { panic('This DefineArgument node is not supported') }
    }
  }

  def visit_define_required_argument(
    node: DefineRequiredArgument,
    block: BlockType,
    types: TypeScope,
    rigid_types: RigidTypeScope,
    variables: VariableScope
  ) -> Type {
    let name = node.name
    let arg_type = visit_type_node(node: node.value_type, types: types)
    let var_type = arg_type.substitute(rigid_types)

    block.define_required_argument(name: name, type: arg_type)
    variables.symbols.define(name: name, type: var_type)

    node.resolved_type = arg_type
  }

  def visit_define_optional_argument(
    node: DefineOptionalArgument,
    block: BlockType,
    types: TypeScope,
    rigid_types: RigidTypeScope,
    variables: VariableScope
  ) -> Type {
    let name = node.name
    let defined_type =
      visit_optional_type_node(node: node.value_type, types: types)

    let default_type = visit_expression(
      node: node.default_value,
      types: types,
      variables: variables
    )

    let arg_type = if defined_type {
      type_compatible?(
        type: default_type,
        with: defined_type.get,
        scope: types,
        location: node.default_value.location
      )

      defined_type.get
    } else {
      default_type
    }

    let var_type = arg_type.substitute(rigid_types)

    block.arguments.define(name: name, type: arg_type)
    variables.symbols.define(name: name, type: var_type)

    node.resolved_type = arg_type
  }

  def visit_define_rest_argument(
    node: DefineRestArgument,
    block: BlockType,
    types: TypeScope,
    rigid_types: RigidTypeScope,
    variables: VariableScope
  ) -> Type {
    let name = node.name
    let val_type = visit_type_node(node: node.value_type, types: types)
    let lvar_type = type_checker
      .builtins
      .array_type
      .new_instance(Array.new(val_type.substitute(rigid_types)))

    block.define_rest_argument(name: name, type: val_type)
    variables.symbols.define(name: name, type: lvar_type)

    node.resolved_type = val_type
  }

  def visit_define_untyped_argument(
    node: DefineUntypedArgument,
    block: BlockType,
    types: TypeScope,
    variables: VariableScope
  ) -> Type {
    let name = node.name
    let type = ErrorType.new

    # TODO: handle inferring when passing closures/lambdas as arguments
    type_checker.diagnostics.missing_argument_type(node.location)

    block.arguments.define(name: name, type: type)
    variables.symbols.define(name: name, type: type)

    node.resolved_type = type
  }

  def visit_return(
    node: Return,
    types: TypeScope,
    variables: VariableScope
  ) -> Type {
    let type = try {
      node
        .expression
        .map do (node) { visit_expression(node, types, variables) }
        .get
    } else {
      type_checker.builtins.nil_singleton
    }

    let surrounding_block = types.block_scope_boundary
    let block = try surrounding_block.get else {
      type_checker.diagnostics.invalid_return(node.location)

      return node.resolved_type = ErrorType.new
    }

    if block.return_type.infer? {
      block.return_type = type

      return node.resolved_type = NeverType.new
    }

    type_compatible?(
      type: type,
      with: block.return_type,
      scope: types,
      location: node.location
    )

    node.resolved_type = NeverType.new
  }

  def visit_throw(
    node: Throw,
    types: TypeScope,
    variables: VariableScope
  ) -> Type {
    let type =
      visit_expression(node: node.expression, types: types, variables: variables)

    if node.local_throw? {
      visit_local_throw(node: node, type: type, types: types)
    } else {
      visit_nonlocal_throw(node: node, type: type, types: types)
    }

    node.resolved_type = type
  }

  def visit_local_throw(node: Throw, type: Type, types: TypeScope) {
    let block = try types.block.get else {
      type_checker.diagnostics.invalid_local_throw(node.location)

      return
    }

    let throws = block.throw_type.get

    block.throws

    if throws.infer? {
      block.throw_type = type

      return
    }

    type_compatible?(
      type: type,
      with: throws,
      scope: types,
      location: node.location
    )
  }

  def visit_nonlocal_throw(node: Throw, type: Type, types: TypeScope) {
    let block = try types.block_scope_boundary.get else {
      type_checker.diagnostics.invalid_throw(node.location)

      return
    }

    if block.throw_type.some? and block.throw_type.get.infer? {
      block.throws
      block.throw_type = type

      return
    }

    let throws = try block.throw_type.get else {
      type_checker
        .diagnostics
        .unexpected_nonlocal_throw(type: type.type_name, location: node.location)

      return
    }

    block.throws

    type_compatible?(
      type: type,
      with: throws,
      scope: types,
      location: node.location
    )
  }

  def visit_yield(
    node: Yield,
    types: TypeScope,
    variables: VariableScope
  ) -> Type {
    let type =
      visit_expression(node: node.expression, types: types, variables: variables)

    node.resolved_type = type

    let block = try types.yield_boundary.get else {
      type_checker.diagnostics.invalid_yield(node.location)

      return type
    }

    let yield_type = try block.yield_type.get else {
      type_checker
        .diagnostics
        .unexpected_yield(type: type.type_name, location: node.location)

      return type
    }

    block.yields

    type_compatible?(
      type: type,
      with: yield_type,
      scope: types,
      location: node.location
    )

    type
  }

  def define_anonymous_block_type(
    block: BlockType,
    arguments: Array!(DefineArgument),
    type_parameters: Array!(DefineTypeParameter),
    throw_type: ?TypeNode,
    return_type: ?TypeNode,
    body: Body,
    types: TypeScope,
    variables: VariableScope,
    location: SourceLocation
  ) {
    define_type_parameters(
      nodes: type_parameters,
      table: block.type_parameters,
      types: types
    )

    let rigid_types = RigidTypeScope.from_type_scope(types)

    for arg in arguments {
      visit_define_argument(
        node: arg,
        block: block,
        types: types,
        rigid_types: rigid_types,
        variables: variables
      )
    }

    throw_type.let do (node) {
      block.throw_type = visit_type_node(node: node, types: types)
    }

    return_type.let do (node) {
      block.return_type = visit_type_node(node: node, types: types)
    }

    let returned =
      visit_expressions(node: body, types: types, variables: variables)

    block.throw_type.let do (type) {
      if type.infer? { block.unset_throw_type }
    }

    block.throw_type.let do (throws) {
      if not block.throws? {
        type_checker.diagnostics.missing_local_throw(
          type: throws.type_name,
          location: location
        )
      }
    }

    # For closures and lambdas, the return type is inferred according to the
    # last expression in the body.
    if block.return_type.infer? {
      block.return_type = returned
      return
    }

    if last_expression_is_return?(body) { return }

    type_compatible?(
      type: returned,
      with: block.return_type,
      scope: types,
      location: body.location_of_last_expression
    )
  }

  def last_expression_is_return?(body: Body) -> Boolean {
    match body.children.get(-1) {
      as Return -> { True }
      else -> { False }
    }
  }

  def require_boolean_type(type: Type, location: SourceLocation) {
    let bool_type = type_checker.builtins.boolean_type

    if type.object_instance_of?(bool_type) { return }

    type_checker.diagnostics.wrong_type(
      expected: bool_type.type_name,
      given: type.type_name,
      location: location
    )
  }

  def match_return_type(
    case_types: Array!(Type),
    else_type: Type,
    scope: TypeScope,
    location: SourceLocation
  ) -> Type {
    let first = case_types[0]
    let builtins = type_checker.builtins

    for type in case_types {
      if not type.type_compatible?(with: first, builtins, scope) {
        return AnyType.new
      }
    }

    if else_type.type_compatible?(with: first, builtins, scope) {
      first
    } else {
      AnyType.new
    }
  }

  def try_else_return_type(
    node: Try,
    try_type: Type,
    else_type: Type,
    types: TypeScope
  ) -> Type {
    if try_type.error? or else_type.error? { return ErrorType.new }

    if type_compatible?(
      type: else_type,
      with: try_type,
      scope: types,
      location: node.else_body.location
    ) {
      try_type
    } else {
      ErrorType.new
    }
  }

  def valid_instruction_arguments?(node: Send, required: Int) -> Boolean {
    let given = node.arguments.length
    let loc = node.location

    if given < required {
      type_checker.diagnostics.invalid_number_of_arguments(
        given: given,
        expected: required,
        location: loc
      )

      return False
    }

    if given > required {
      type_checker.diagnostics.invalid_number_of_arguments(
        given: given,
        expected: required,
        location: loc
      )

      return False
    }

    True
  }

  def any_type_array -> ClassInstance {
    type_checker.builtins.array_type.new_instance(Array.new(AnyType.new))
  }

  def assign_throw_and_return_type(
    node: TryExpressionNode,
    block: BlockType,
    types: TypeCheckScope
  ) -> Type {
    let builtins = type_checker.builtins
    let throws = block.throw_type.map do (type) { type.substitute(types) }
    let returns = block
      .resolve_return_type(throw_type: throws, builtins: builtins, scope: types)

    throws.let do (throws) {
      if not block.yield_type { node.resolved_throw_type = throws }
    }

    check_error_handling(node: node, block: block, throw_type: throws)

    node.resolved_type = returns
  }

  def try_expression_throw_type(expression: Node) -> Type {
    match let expr = expression {
      as TryExpressionNode when expr.resolved_throw_type.some? -> {
        expr.resolved_throw_type.get
      }
      else -> {
        type_checker.diagnostics.expression_never_throws(expr.location)
        ErrorType.new
      }
    }
  }

  def check_error_handling(
    node: TryExpressionNode,
    block: BlockType,
    throw_type: ?Type
  ) {
    # If the throw type is explicitly set to Never, we treat it the same as
    # there not being a throw type. We support this so generic types can define
    # a type parameter as the throw type, which the user can then set to Never;
    # removing the need for error handling where desired.
    #
    # Generator methods don't throw themselves, it's the resume method that
    # throws. As such we'll allow the omission of `try` for generator methods.
    if node.inside_try?
      or throw_type.none?
      or throw_type.get.never?
      or block.yield_type.some?
    {
      return
    }

    type_checker
      .diagnostics
      .missing_try(type: throw_type.get.type_name, location: node.location)
  }
}

# A compiler pass for preparing other passes.
class Prepare {
  # The module to prepare.
  @module: ModuleType

  # The type checker that is running this pass.
  @type_checker: TypeChecker

  static def new(module: ModuleType, type_checker: TypeChecker) -> Self {
    Self { @module = module, @type_checker = type_checker }
  }
}

impl Pass for Prepare {
  def run(ast: Body) -> Boolean {
    @type_checker.add_module(@module)

    # Each module itself is exposed using this symbol.
    #
    # This is defined in the `globals` table so other modules can't import this
    # constant, as that would conflict with their own definition of this
    # constant.
    @module.globals.define(name: THIS_MODULE, type: @module)

    ast.type_scope = TypeScope.new(@module)

    @type_checker.continue?
  }
}

# A compiler pass that type-checks all imported modules.
class TypeCheckImports {
  # The module to prepare.
  @module: ModuleType

  # The type checker that is running this pass.
  @type_checker: TypeChecker

  static def new(module: ModuleType, type_checker: TypeChecker) -> Self {
    Self { @module = module, @type_checker = type_checker }
  }

  def visit_import(node: Import) {
    let name = node.module_name

    if @type_checker.module(name) { return }

    let ast = try @type_checker.syntax_tree(name).get else return

    @type_checker.check(name, ast)
  }
}

impl Pass for TypeCheckImports {
  def run(ast: Body) -> Boolean {
    for node in ast.imports {
      visit_import(node)
    }

    @type_checker.continue?
  }
}

# A compiler pass for defining the types of all imported symbols.
class DefineImportedSymbolTypes {
  # The module for which to define the types.
  @module: ModuleType

  # The type checker that is running this pass.
  @type_checker: TypeChecker

  static def new(module: ModuleType, type_checker: TypeChecker) -> Self {
    Self { @module = module, @type_checker = type_checker }
  }

  def visit_import(node: Import) {
    let name = node.module_name
    let module = try @type_checker.module(name).get else {
      # We don't need to add an error, as that will have already been when
      # parsing all modules.
      return
    }

    if node.import_all? {
      import_all(import_from: module, location: node.location)
      return
    }

    for symbol in node.symbols {
      if symbol.expose? and symbol.import_self? {
        import_self(import_from: module, symbol: symbol)
      } else if symbol.expose? {
        import_symbol(import_from: module, symbol: symbol)
      }
    }
  }

  def import_all(import_from: ModuleType, location: SourceLocation) {
    let globals = @module.globals

    for sym in import_from.constants.symbols {
      define_import_type(
        table: globals,
        name: sym.name,
        type: sym.type,
        location: location
      )
    }

    for sym in import_from.methods.symbols {
      define_import_type(
        table: globals,
        name: sym.name,
        type: sym.type,
        location: location
      )
    }
  }

  def import_self(import_from: ModuleType, symbol: ImportSymbol) {
    let name =
      try symbol.alias.map do (a) { a.name }.get else import_from.name.tail

    define_import_type(
      table: @module.globals,
      name: name,
      type: import_from,
      location: symbol.location
    )
  }

  def import_symbol(import_from: ModuleType, symbol: ImportSymbol) {
    let name = try symbol.alias.map do (a) { a.name }.get else symbol.name

    import_from.constants.get(symbol.name).let do (constant) {
      define_import_type(
        table: @module.globals,
        name: name,
        type: constant.type,
        location: symbol.location
      )

      return
    }

    import_from.methods.get(symbol.name).let do (method) {
      define_import_type(
        table: @module.globals,
        name: name,
        type: method.type,
        location: symbol.location
      )

      return
    }

    @type_checker.diagnostics.undefined_import_symbol(
      module: import_from.name.to_string,
      name: symbol.name,
      location: symbol.location
    )
  }

  def define_import_type(
    table: SymbolTable!(Type),
    name: String,
    type: Type,
    location: SourceLocation
  ) {
    if table.get(name) {
      @type_checker.diagnostics.import_existing_symbol(name, location)

      return
    }

    table.define(name: name, type: type)
  }
}

impl Pass for DefineImportedSymbolTypes {
  def run(ast: Body) -> Boolean {
    for child in ast.children {
      match let node = child {
        as Import -> { visit_import(node) }
        else -> {}
      }
    }

    @type_checker.continue?
  }
}

# A compiler pass for defining type signatures of types.
#
# This pass will define any objects and traits, and their type parameters.
class DefineTypeSignatures {
  # The module for which to define the types.
  @module: ModuleType

  # The type checker that is running this pass.
  @type_checker: TypeChecker

  static def new(module: ModuleType, type_checker: TypeChecker) -> Self {
    Self { @module = module, @type_checker = type_checker }
  }

  def visit_define_class(node: DefineClass, types: TypeScope) -> ClassType {
    let type = ClassType.new(node.name)

    define_type_parameters(
      nodes: node.type_parameters,
      table: type.type_parameters,
      types: types
    )

    define_if_not_exists(name: node.name, type: type, location: node.location)

    node.body.type_scope = TypeScope.new(module: @module, self_type: type)
    node.resolved_type = type
  }

  def visit_define_trait(node: DefineTrait, types: TypeScope) -> TraitType {
    let type = TraitType.new(node.name)

    # The Object trait is available to all object instances, so we add it as a
    # default trait for our newly defined trait type.
    type_checker
      .object_trait
      .let do (default) { type.default_traits.push(default.new_instance) }

    define_type_parameters(
      nodes: node.type_parameters,
      table: type.type_parameters,
      types: types
    )

    define_if_not_exists(name: node.name, type: type, location: node.location)

    node.body.type_scope = TypeScope.new(module: @module, self_type: type)
    node.resolved_type = type
  }

  def define_if_not_exists(
    name: String,
    type: Type,
    location: SourceLocation
  ) {
    if @module.defines?(name) {
      type_checker.diagnostics.redefine_constant(name: name, location: location)

      return
    }

    @module.define_constant(name: name, type: type)
  }
}

impl Pass for DefineTypeSignatures {
  def run(ast: Body) -> Boolean {
    let types = ast.type_scope.get

    for child in ast.children {
      match let node = child {
        as DefineClass -> { visit_define_class(node: node, types: types) }
        as DefineTrait -> { visit_define_trait(node: node, types: types) }
        else -> {}
      }
    }

    @type_checker.continue?
  }
}

impl TypePass for DefineTypeSignatures {
  def type_checker -> TypeChecker {
    @type_checker
  }

  def module -> ModuleType {
    @module
  }
}

# A compiler pass that defines the types of instance attributes of objects.
#
# This pass expects that the `DefineTypeSignatures` pass ran first and may panic
# if this isn't the case.
class DefineAttributeTypes {
  # The module for which to define the types.
  @module: ModuleType

  # The type checker that is running this pass.
  @type_checker: TypeChecker

  static def new(module: ModuleType, type_checker: TypeChecker) -> Self {
    Self { @module = module, @type_checker = type_checker }
  }

  def visit_define_class(node: DefineClass, types: TypeScope) -> ClassType {
    let type = node.resolved_type.get
    let new_types = node.body.type_scope.get

    for child in node.body.children {
      match let node = child {
        as DefineAttribute -> {
          visit_define_attribute(node: node, class_type: type, types: new_types)
        }
        else -> {}
      }
    }

    type
  }

  def visit_define_attribute(
    node: DefineAttribute,
    class_type: ClassType,
    types: TypeScope
  ) -> Type {
    let type = visit_type_node(node: node.value_type, types: types)
    let attr = class_type.define_attribute(name: node.name, type: type)

    node.resolved_type = attr.type.internal_type
  }
}

impl Pass for DefineAttributeTypes {
  def run(ast: Body) -> Boolean {
    let types = ast.type_scope.get

    for child in ast.children {
      match let node = child {
        as DefineClass -> { visit_define_class(node: node, types: types) }
        else -> {}
      }
    }

    @type_checker.continue?
  }
}

impl TypePass for DefineAttributeTypes {
  def type_checker -> TypeChecker {
    @type_checker
  }

  def module -> ModuleType {
    @module
  }
}

# Compiler pass for type-checking types and expressions, except those defined in
# method bodies.
class TypeCheck {
  # The module for which to define the types.
  @module: ModuleType

  # The type checker that is running this pass.
  @type_checker: TypeChecker

  static def new(module: ModuleType, type_checker: TypeChecker) -> Self {
    Self { @module = module, @type_checker = type_checker }
  }

  def visit_define_constant(
    node: DefineConstant,
    types: TypeScope,
    variables: VariableScope
  ) -> Type {
    let name = node.name.name
    let target_type = visit_define_variable(
      value_node: node.value,
      type_node: node.value_type,
      types: types,
      variables: variables
    )

    if @module.defines?(name) {
      type_checker.diagnostics.redefine_constant(name, node.location)
    } else {
      @module.define_constant(name, target_type)
    }

    node.resolved_type = target_type
  }

  def visit_define_class(node: DefineClass, types: TypeScope) -> Type {
    let type = node.resolved_type.get
    let new_scope = node.body.type_scope.get

    for child in node.body.children {
      match let matched = child {
        as DefineMethod -> {
          store_method_in_object(
            type: type,
            method: visit_define_method(node: matched, types: new_scope),
            types: types,
            location: child.location
          )
        }
        else -> {
          # The only other nodes possible at the AST level are attributes, which
          # are handled in an earlier pass.
        }
      }
    }

    type
  }

  def visit_define_trait(node: DefineTrait, types: TypeScope) -> Type {
    let type = node.resolved_type.get
    let new_scope = node.body.type_scope.get

    for child in node.body.children {
      match let matched = child {
        as DefineMethod -> {
          store_method_in_trait(
            type: type,
            method: visit_define_method(node: matched, types: new_scope),
            table: type.default_methods,
            location: child.location
          )
        }
        as DefineRequiredMethod -> {
          store_method_in_trait(
            type: type,
            method: visit_define_required_method(
              node: matched,
              types: new_scope
            ),
            table: type.required_methods,
            location: child.location
          )
        }
        else -> {
          # Trait bodies can only define methods, so any other node can just be
          # ignored.
        }
      }
    }

    type
  }

  def visit_define_external_function(
    node: DefineExternalFunction,
    types: TypeScope
  ) -> MethodType {
    let temp_scope = VariableScope.new
    let rigid_types = RigidTypeScope.new(types.self_type)
    let layout = BlockLayout.new(type_checker.builtins.nil_type.new_instance)
    let method = MethodType.new(name: node.name, layout: layout, external: True)
    let method_types =
      node.type_scope = type_scope_for_method(method: method, types: types)

    for arg in node.arguments {
      visit_define_required_argument(
        node: arg,
        block: method,
        types: method_types,
        rigid_types: rigid_types,
        variables: temp_scope
      )
    }

    node.throw_type.let do (node) {
      method.throw_type = visit_type_node(node: node, types: method_types)
    }

    node.return_type.let do (node) {
      method.return_type = visit_type_node(node: node, types: method_types)
    }

    method
  }

  def visit_define_method(node: DefineMethod, types: TypeScope) -> MethodType {
    let layout = BlockLayout.new(type_checker.builtins.nil_type.new_instance)
    let method = MethodType
      .new(name: node.name, layout: layout, static_method: node.static_method?)

    let method_type_scope =
      node.body.type_scope = type_scope_for_method(method: method, types: types)

    let type = define_method_type(
      method: method,
      arguments: node.arguments,
      type_parameters: node.type_parameters,
      type_parameter_bounds: node.type_parameter_bounds,
      throw_type: node.throw_type,
      return_type: node.return_type,
      yield_type: node.yield_type,
      types: method_type_scope,
      variables: node.body.variable_scope
    )

    node.resolved_type = type
  }

  def visit_define_method_in_trait_implementation(
    node: DefineMethod,
    implementation: TraitImplementation,
    types: TypeScope
  ) -> MethodType {
    let layout = BlockLayout.new(type_checker.builtins.nil_type.new_instance)
    let method = MethodType
      .new(name: node.name, layout: layout, static_method: node.static_method?)

    let method_type_scope =
      node.body.type_scope = type_scope_for_method(method: method, types: types)

    method.type_parameter_bounds.merge(implementation.bounds)

    let type = define_method_type(
      method: method,
      arguments: node.arguments,
      type_parameters: node.type_parameters,
      type_parameter_bounds: node.type_parameter_bounds,
      throw_type: node.throw_type,
      return_type: node.return_type,
      yield_type: node.yield_type,
      types: method_type_scope,
      variables: node.body.variable_scope
    )

    node.resolved_type = type
  }

  def visit_define_required_method(
    node: DefineRequiredMethod,
    types: TypeScope
  ) -> MethodType {
    # Default arguments in required methods make no sense, as they will never be
    # used by implementations of the required method.
    #
    # We don't handle this at the parser level, because when parsing arguments
    # we don't yet know if the method will be required or not.
    for arg in node.arguments {
      if arg.default_value? {
        type_checker
          .diagnostics
          .required_method_with_default_argument(arg.location)
      }
    }

    # The VariableScope is not used after processing the node as required
    # methods have no bodies. We still create a scope here since synax-wise a
    # required method can have argument defaults, and processing those requires
    # a VariableScope.
    let temp_scope = VariableScope.new
    let layout = BlockLayout.new(type_checker.builtins.nil_type.new_instance)
    let method = MethodType.new(name: node.name, layout: layout)

    let method_type_scope =
      node.type_scope = type_scope_for_method(method: method, types: types)

    node.resolved_type = define_method_type(
      method: method,
      arguments: node.arguments,
      type_parameters: node.type_parameters,
      type_parameter_bounds: node.type_parameter_bounds,
      throw_type: node.throw_type,
      return_type: node.return_type,
      yield_type: node.yield_type,
      types: method_type_scope,
      variables: temp_scope
    )
  }

  def visit_implement_trait(node: ImplementTrait, types: TypeScope) -> Type {
    let trait_name = node.trait_name
    let class_name = node.class_name

    let class_type =
      match let matched = visit_constant(node: class_name, types: types) {
        as ClassType -> { matched }
        as ErrorType -> { return matched }
        else -> {
          type_checker.diagnostics.invalid_trait_implementation(
            name: class_name.name,
            location: class_name.location
          )

          return ErrorType.new
        }
      }

    # When implementing a trait, the trait should have access to the type
    # parameters of the object that implements said trait. This is achieved by
    # processing the object name first, and using a new type scope for the trait
    # name.
    let new_scope = node.body.type_scope = TypeScope
      .new(module: @module, self_type: class_type)

    let trait_instance = match
      let matched = visit_constant_as_type(node: trait_name, types: new_scope)
    {
      as TraitInstance -> { matched }
      as ErrorType -> { return matched }
      else -> {
        type_checker
          .diagnostics
          .not_a_trait(name: trait_name.name, location: trait_name.location)

        return ErrorType.new
      }
    }

    let implementation = TraitImplementation.new(trait_instance)

    if not visit_trait_implementation_bounds(
      nodes: node.type_parameter_bounds,
      class_type: class_type,
      implementation: implementation,
      types: new_scope
    ) {
      # If the bounds are not valid, the rest of the implementation could
      # produce many errors, so we return right away.
      return ErrorType.new
    }

    let mut valid = True

    for default in trait_instance.instance_of.default_methods.symbols {
      let name = default.name
      let existing =
        class_type.instance_methods.get(name).map do (sym) { sym.type }

      # Default methods may be implemented ahead of the trait. If so, we allow
      # this as long as the existing implementation is compatible with the one
      # provided by the trait.
      existing.let do (existing) {
        if not existing.type_compatible?(
          with: default.type,
          builtins: type_checker.builtins,
          scope: types
        ) {
          valid = False

          type_checker
            .diagnostics
            .default_method_not_compatible(
              expected: default.type.type_name,
              given: existing.type_name,
              location: node.location
            )
        }
      }

      # Default methods don't have bounds copied. Since default methods are
      # defined ahead of the implementation, they don't depend on/need any
      # bounds defined when implementing the trait. Instead, any additional
      # bounds they may need are to be set at the method level.
      #
      # This is best explained with a simple example:
      #
      #     trait List!(T) {
      #       def to_string -> String when T: ToString {
      #         # ...
      #       }
      #     }
      #
      #     impl List!(T) for Array when T: ToInt {
      #       # ...
      #     }
      #
      # Here `List.to_string` only depends on `T` implementing `ToString`,
      # _not_ `ToInt`. Thus, merging the bounds would actually prevent
      # us from using `to_string` for any `T` that _only_ implements
      # `ToString`.
      if not existing {
        class_type.instance_methods.define(name, default.type)
      }
    }

    # The implementation is added first, so that methods added in the body can
    # pass the type of `self`/`Self` to anything that expects the trait we are
    # implementing.
    class_type.add_trait_implementation(implementation)

    for child in node.body.children {
      match let matched = child {
        as DefineMethod -> {
          let method = visit_define_method_in_trait_implementation(
            node: matched,
            implementation: implementation,
            types: new_scope
          )

          if not store_implemented_method_in_object(
            type: class_type,
            trait_instance: trait_instance,
            method: method,
            scope: new_scope,
            location: child.location
          ) {
            valid = False
          }
        }
        else -> {
          # The parser only allows instance methods to occur here, so there are
          # no other node types that we need to handle.
        }
      }
    }

    if not valid
      or not required_traits_implemented?(node, class_type, trait_instance, new_scope)
      or not required_methods_implemented?(node, class_type, trait_instance, new_scope)
    {
      class_type.remove_trait_implementation(implementation)
    }

    class_type
  }

  def visit_reopen_object(node: ReopenObject, types: TypeScope) -> Type {
    let name = node.name
    let type = match let matched = visit_constant(node: name, types: types) {
      as ClassType -> { matched }
      as ErrorType -> { return matched }
      else -> {
        type_checker
          .diagnostics
          .not_an_object(name: name.name, location: name.location)

        return ErrorType.new
      }
    }

    let new_scope =
      node.body.type_scope = TypeScope.new(module: @module, self_type: type)

    for child in node.body.children {
      match let matched = child {
        as DefineMethod -> {
          store_method_in_object(
            type: type,
            method: visit_define_method(node: matched, types: new_scope),
            types: types,
            location: child.location
          )
        }
        else -> {
          # When reopening an object, the only possible nodes are DefineMethod
          # nodes; thus we ignore other node types.
        }
      }
    }

    ErrorType.new
  }

  def visit_trait_implementation_bounds(
    nodes: Array!(DefineTypeParameter),
    class_type: ClassType,
    implementation: TraitImplementation,
    types: TypeScope
  ) -> Boolean {
    nodes.iter.all? do (bound) {
      let type =
        class_type.lookup_type_parameter(bound.name).map do (sym) { sym.type }

      define_type_parameter_bound(
        node: bound,
        parameter: type,
        type_parameter_bounds: implementation.bounds,
        types: types
      )
    }
  }

  def visit_method_bounds(
    nodes: Array!(DefineTypeParameter),
    method: MethodType,
    receiver: Type,
    types: TypeScope
  ) -> Boolean {
    nodes.iter.all? do (bound) {
      if method.lookup_type_parameter(bound.name) {
        type_checker.diagnostics.useless_method_bound(bound.location)

        return False
      }

      let type =
        receiver.lookup_type_parameter(bound.name).map do (sym) { sym.type }

      define_type_parameter_bound(
        node: bound,
        parameter: type,
        type_parameter_bounds: method.type_parameter_bounds,
        types: types
      )
    }
  }

  def define_type_parameter_bound(
    node: DefineTypeParameter,
    parameter: ?TypeParameterType,
    type_parameter_bounds: TypeParameterBounds,
    types: TypeScope
  ) -> Boolean {
    let param = try parameter.get else {
      type_checker
        .diagnostics
        .undefined_type_parameter(name: node.name, location: node.location)

      return False
    }

    # When one or more required traits produce an error, a diagnostic will
    # already have been added; thus we just return without doing anything else.
    let required =
      try visit_type_parameter_requirements(node, types).get else return False

    if not type_parameter_bounds.define(param, required) {
      type_checker.diagnostics.duplicate_bound(node.name, node.location)

      return False
    }

    True
  }

  def required_methods_implemented?(
    node: ImplementTrait,
    class_type: ClassType,
    trait_instance: TraitInstance,
    scope: TypeScope,
  ) -> Boolean {
    let builtins = @type_checker.builtins

    for symbol in trait_instance.instance_of.required_methods.symbols {
      let required = symbol.type
      let implemented =
        try class_type.instance_methods.get(required.name).get else {
          type_checker.diagnostics.required_method_not_implemented(
            method: required.type_name,
            location: node.location
          )

          return False
        }

      if not implemented.type.type_compatible?(with: required, builtins, scope)
      {
        type_checker.diagnostics.required_method_not_compatible(
          given: implemented.type.type_name,
          expected: required.type_name,
          location: node.method_node(required.name).get.location
        )

        return False
      }
    }

    True
  }

  def required_traits_implemented?(
    node: ImplementTrait,
    class_type: ClassType,
    trait_instance: TraitInstance,
    scope: TypeScope
  ) -> Boolean {
    let builtins = @type_checker.builtins

    trait_instance.instance_of.required_traits.iter.all? do (required) {
      if class_type.implements_trait?(required, builtins, scope) {
        True
      } else {
        type_checker.diagnostics.required_trait_not_implemented(
          required: required.type_name,
          depending: trait_instance.type_name,
          location: node.location
        )

        False
      }
    }
  }

  def define_method_type(
    method: MethodType,
    arguments: Array!(DefineArgument),
    type_parameters: Array!(DefineTypeParameter),
    type_parameter_bounds: Array!(DefineTypeParameter),
    throw_type: ?TypeNode,
    return_type: ?TypeNode,
    yield_type: ?TypeNode,
    types: TypeScope,
    variables: VariableScope
  ) -> MethodType {
    define_type_parameters(
      nodes: type_parameters,
      table: method.type_parameters,
      types: types
    )

    let rigid_types = RigidTypeScope.from_type_scope(types)

    for arg in arguments {
      visit_define_argument(
        node: arg,
        block: method,
        types: types,
        rigid_types: rigid_types,
        variables: variables
      )
    }

    throw_type.let do (node) {
      method.throw_type = visit_type_node(node: node, types: types)
    }

    return_type.let do (node) {
      method.return_type = visit_type_node(node: node, types: types)
    }

    method.yield_type = visit_optional_type_node(node: yield_type, types: types)

    visit_method_bounds(
      nodes: type_parameter_bounds,
      method: method,
      receiver: types.self_type,
      types: types
    )

    method
  }

  def type_scope_for_method(method: MethodType, types: TypeScope) -> TypeScope {
    let self_type = if method.static_method? {
      types.self_type
    } else {
      types.self_type.new_instance
    }

    TypeScope
      .new(module: @module, self_type: self_type, block: Option.some(method))
  }

  def store_method_in_module(
    type: ModuleType,
    method: MethodType,
    location: SourceLocation
  ) {
    let name = method.name

    if type.methods.get(name) {
      type_checker.diagnostics.redefine_module_method(name, location)

      return
    }

    type.define_method(name: name, type: method)
  }

  def store_method_in_trait(
    type: TraitType,
    method: MethodType,
    table: SymbolTable!(MethodType),
    location: SourceLocation
  ) {
    let name = method.name

    if type.required_methods.get(name) {
      type_checker.diagnostics.redefine_required_method(name, location)

      return
    }

    if type.default_methods.get(name) {
      type_checker.diagnostics.redefine_default_method(name, location)

      return
    }

    table.define(name: name, type: method)
  }

  def store_method_in_object(
    type: ClassType,
    method: MethodType,
    types: TypeCheckScope,
    location: SourceLocation
  ) -> Boolean {
    let name = method.name
    let table = if method.static_method? {
      type.static_methods
    } else {
      type.instance_methods
    }

    let existing = table.get(name).map do (sym) { sym.type }

    if method.static_method? and type.instance_methods.defines?(name) {
      type_checker
        .diagnostics
        .redefine_instance_method(name: name, location: location)

      return False
    }

    if method.instance_method? and type.static_methods.defines?(name)  {
      type_checker
        .diagnostics
        .redefine_static_method(name: name, location: location)

      return False
    }

    # Existing methods can only be redefined if the new definition is compatible
    # with the existing one.
    if existing.some?
      and not method.type_compatible?(
        with: existing.get,
        builtins: type_checker.builtins,
        scope: types
      )
    {
      type_checker.diagnostics.invalid_redefined_method(
        expected: existing.get.type_name,
        given: method.type_name,
        location: location
      )

      return False
    }

    table.define(name: name, type: method)
    True
  }

  def store_implemented_method_in_object(
    type: ClassType,
    trait_instance: TraitInstance,
    method: MethodType,
    scope: TypeScope,
    location: SourceLocation
  ) -> Boolean {
    let name = method.name

    if type.static_methods.defines?(name) {
      type_checker.diagnostics.redefine_static_method(name, location)

      return False
    }

    let default = trait_instance
      .instance_of
      .default_methods
      .get(name)
      .map do (sym) { sym.type }

    # Default methods can be redefined when implementing a trait. We don't allow
    # redefining other instance methods, as doing so could lead to the wrong
    # implementation of a method being used.
    if type.instance_methods.defines?(name) and default.none? {
      type_checker.diagnostics.redefine_instance_method(name, location)

      return False
    }

    let builtins = @type_checker.builtins

    # Default methods can only be redefined if their new version is compatible
    # with the implementation provided by the trait.
    default.let do (default) {
      if not method.type_compatible?(with: default, builtins, scope) {
        type_checker.diagnostics.default_method_not_compatible(
          expected: default.type_name,
          given: method.type_name,
          location: location
        )

        return False
      }
    }

    type.instance_methods.define(name: name, type: method)
    True
  }
}

impl Pass for TypeCheck {
  def run(ast: Body) -> Boolean {
    let types = ast.type_scope.get
    let vars = ast.variable_scope

    for node in ast.children {
      match let matched = node {
        as DefineClass -> { visit_define_class(node: matched, types: types) }
        as DefineTrait -> { visit_define_trait(node: matched, types: types) }
        as DefineMethod -> {
          store_method_in_module(
            type: @module,
            method: visit_define_method(node: matched, types: types),
            location: matched.location
          )
        }
        as DefineExternalFunction -> {
          store_method_in_module(
            type: @module,
            method: visit_define_external_function(node: matched, types: types),
            location: matched.location
          )
        }
        as DefineConstant -> {
          visit_define_constant(node: matched, types: types, variables: vars)
        }
        as ImplementTrait -> {
          visit_implement_trait(node: matched, types: types)
        }
        as ReopenObject -> { visit_reopen_object(node: matched, types: types) }
        as Import -> {
          # Imports are processed in a separate pass, and their results can't be
          # used in expressions (e.g. as the value of an assignment); so we can
          # just ignore them here.
        }
        else -> { visit_expression(node: node, types: types, variables: vars) }
      }
    }

    @type_checker.continue?
  }
}

impl TypePass for TypeCheck {
  def type_checker -> TypeChecker {
    @type_checker
  }

  def module -> ModuleType {
    @module
  }
}

impl ExpressionTypePass for TypeCheck {}

# Compiler pass for type-checking the bodies of methods.
class TypeCheckMethods {
  # The module for which to define the types.
  @module: ModuleType

  # The type checker that is running this pass.
  @type_checker: TypeChecker

  static def new(module: ModuleType, type_checker: TypeChecker) -> Self {
    Self { @module = module, @type_checker = type_checker }
  }

  def visit_define_class(node: DefineClass, types: TypeScope) {
    visit_define_method_nodes(node.body)
  }

  def visit_define_trait(node: DefineTrait, types: TypeScope) {
    visit_define_method_nodes(node.body)
  }

  def visit_reopen_object(node: ReopenObject, types: TypeScope) {
    visit_define_method_nodes(node.body)
  }

  def visit_implement_trait(node: ImplementTrait, types: TypeScope) {
    visit_define_method_nodes(node.body)
  }

  def visit_define_method(node: DefineMethod, types: TypeScope) {
    let method = node.resolved_type.get
    let body_types = node.body.type_scope.get
    let body_vars = node.body.variable_scope
    let body = node.body
    let declared = method.return_type
    let returned =
      visit_expressions(node: body, types: body_types, variables: body_vars)

    method.throw_type.let do (throws) {
      if not method.throws? {
        type_checker
          .diagnostics
          .missing_method_throw(throws.type_name, node.location)
      }
    }

    method.yield_type.let do (yields) {
      if not method.yields? {
        type_checker.diagnostics.missing_yield(yields.type_name, node.location)
      }
    }

    # Methods without explicit return types ignore whatever is returned, so no
    # type-checking is necessary. And if the last expression is a return, it's
    # type-checked separately.
    if node.return_type.none? or last_expression_is_return?(body) { return }

    if method.yield_type.some? and node.return_type.some? {
      type_checker.diagnostics.cant_yield_and_return(node.location)
    }

    type_compatible?(
      type: returned,
      with: declared,
      scope: body_types,
      location: body.location_of_last_expression
    )
  }

  def visit_define_method_nodes(node: Body) {
    let types = node.type_scope.get

    for child in node.children {
      match let matched = child {
        as DefineMethod -> { visit_define_method(node: matched, types: types) }
        else -> {
          # All other nodes are ignored in this pass. Required methods are also
          # ignored, as they don't have any bodies to process.
        }
      }
    }
  }
}

impl Pass for TypeCheckMethods {
  def run(ast: Body) -> Boolean {
    let types = ast.type_scope.get

    for node in ast.children {
      match let matched = node {
        as DefineClass -> { visit_define_class(node: matched, types: types) }
        as DefineTrait -> { visit_define_trait(node: matched, types: types) }
        as DefineMethod -> { visit_define_method(node: matched, types: types) }
        as ImplementTrait -> {
          visit_implement_trait(node: matched, types: types)
        }
        as ReopenObject -> { visit_reopen_object(node: matched, types: types) }
        else -> {
          # All other nodes are ignored in this pass, as they can't contain any
          # methods.
        }
      }
    }

    @type_checker.continue?
  }
}

impl TypePass for TypeCheckMethods {
  def type_checker -> TypeChecker {
    @type_checker
  }

  def module -> ModuleType {
    @module
  }
}

impl ExpressionTypePass for TypeCheckMethods {}

# A type used for defining and checking types of Inko modules.
class TypeChecker {
  # The modules that have been type-checked thus far (or are in the process of
  # being type-checked), mapped using their fully qualified names.
  @modules: Map!(ModuleName, ModuleType)

  # The ASTs of every module that has been parsed.
  @syntax_trees: Map!(ModuleName, Body)

  # Diagnostics produced while defining and checking types.
  @diagnostics: Diagnostics

  # A collection of built-in types
  @builtins: Builtins

  # The `dependencies` argument specifies all the direct and indirect
  # dependencies of the module. Dependencies are also type-checked.
  static def new(
    diagnostics: Diagnostics,
    dependencies: Array!(ParsedModule)
  ) -> Self {
    let syntax_trees = Map.new

    for module in dependencies { syntax_trees[module.name] = module.ast }

    Self {
      @modules = Map.new,
      @syntax_trees = syntax_trees,
      @diagnostics = diagnostics,
      @builtins = Builtins.new
    }
  }

  def add_module(module: ModuleType) -> ModuleType {
    @modules[module.name] = module
  }

  def syntax_tree(name: ModuleName) -> ?Body {
    @syntax_trees.get(name)
  }

  def module(name: ModuleName) -> ?ModuleType {
    @modules.get(name)
  }

  def trait_from_module(module: ModuleName, constant: String) -> ?TraitType {
    module(module)
      .then do (mod) { mod.constants.get(constant) }
      .then do (sym) {
        match let matched = sym.type {
          as TraitType -> { Option.some(matched) }
          else -> { Option.none }
        }
      }
  }

  def object_trait -> ?TraitType {
    trait_from_module(module: BOOTSTRAP_MODULE, constant: OBJECT_TRAIT)
  }

  def pattern_match_trait -> ?TraitType {
    trait_from_module(module: OPERATORS_MODULE, constant: MATCH_TRAIT)
  }

  def option_object -> ?ClassType {
    module(OPTION_MODULE)
      .then do (mod) { mod.constants.get(OPTION_TYPE) }
      .then do (sym) {
        match let matched = sym.type {
          as ClassType -> { Option.some(matched) }
          else -> { Option.none }
        }
      }
  }

  def diagnostics -> Diagnostics {
    @diagnostics
  }

  def builtins -> Builtins {
    @builtins
  }

  def continue? -> Boolean {
    @diagnostics.errors?.false?
  }

  def check(name: ModuleName, ast: Body) {
    check_module(module: ModuleType.new(name), ast: ast)
  }

  # Type-checks a single `ModuleType` and its corresponding AST.
  def check_module(module: ModuleType, ast: Body) {
    Prepare.new(module, type_checker: self).run(ast)
      and TypeCheckImports.new(module, type_checker: self).run(ast)
      and DefineImportedSymbolTypes.new(module, type_checker: self).run(ast)
      and DefineTypeSignatures.new(module, type_checker: self).run(ast)
      and DefineAttributeTypes.new(module, type_checker: self).run(ast)
      and TypeCheck.new(module, type_checker: self).run(ast)
      and TypeCheckMethods.new(module, type_checker: self).run(ast)
  }
}
