# Networking types for TCP/UDP communication.
import std::conversion::(ToFloat, ToString)
import std::io::(Close, Error, Read, Write)
import std::net::bits::(
  self, MAXIMUM_LISTEN_BACKLOG, SOCK_DGRAM, SOCK_RAW, SOCK_SEQPACKET,
  SOCK_STREAM, Socket as RawSocket
)
import std::net::ip::(IpAddress, Ipv4Address, ToIpAddress, parse as parse_ip)
import std::operators::Equal
import std::time::Duration

# A low-level, non-blocking IPv4 or IPv6 socket.
#
# Low-level sockets allow for more fine-grained control over how sockets should
# be constructed and used, at the cost of a slightly less ergonomic API
# compared to more high-level types such as `UdpSocket`.
let Socket = _INKOC.get_ip_socket_prototype

_INKOC.set_object_name(Socket, 'Socket')

impl Object for Socket {}

# The socket type for socket streams.
let STREAM = SOCK_STREAM

# The socket type for datagram sockets.
let DGRAM = SOCK_DGRAM

# The socket type for sequential packet sockets.
let SEQPACKET = SOCK_SEQPACKET

# The socket type for raw sockets.
let RAW = SOCK_RAW

extern def socket_allocate_ipv4(type: ref Int) !! Int -> Socket
extern def socket_allocate_ipv6(type: ref Int) !! Int -> Socket
extern def socket_accept_ip(socket: ref Socket) !! Int -> Socket

# An IPv4 or IPv6 socket address.
class SocketAddress {
  # The IPv4/IPv6 address of this socket address.
  @ip: IpAddress

  # The port number of this socket address.
  @port: Int

  static def new(ip: IpAddress, port: Int) -> Self {
    Self { @ip = ip, @port = port }
  }

  # Returns the IPv4/IPv6 address associated with `self`.
  def ip -> ref IpAddress {
    @ip
  }

  # Returns the port number associated with `self`.
  def port -> Int {
    @port.clone
  }
}

impl Equal for SocketAddress {
  # Returns `True` if `self` and `other` are the same.
  def ==(other: ref Self) -> Boolean {
    @ip == other.ip and @port == other.port
  }
}

impl Socket {
  # Creates a new IPv4 socket.
  #
  # # Examples
  #
  #     import std::net::socket::(DGRAM, Socket)
  #
  #     try! Socket.ipv4(DGRAM)
  static def ipv4(kind: Int) !! Error -> Self {
    try socket_allocate_ipv4(kind) else (error) throw Error.new(error)
  }

  # Creates a new IPv6 socket.
  #
  # # Examples
  #
  #     import std::net::socket::(DGRAM, Socket)
  #
  #     try! Socket.ipv6(DGRAM)
  static def ipv6(kind: Int) !! Error -> Self {
    try socket_allocate_ipv6(kind) else (error) throw Error.new(error)
  }

  # Binds this socket to the specified address.
  #
  # # Examples
  #
  # Binding a socket:
  #
  #     import std::net::socket::(Socket, DGRAM)
  #
  #     let socket = try! Socket.ipv4(DGRAM)
  #
  #     try! socket.bind(ip: '0.0.0.0', port: 9999)
  def bind(ip: ToIpAddress, port: Int) !! Error {
    let addr =
      try ip.to_ip_address else (e) throw Error.invalid_input(e.to_string)

    try bits.bind(self, addr.to_string, port)
  }

  # Connects this socket to the specified address.
  #
  # # Examples
  #
  # Connecting a socket:
  #
  #     import std::net::socket::(Socket, DGRAM)
  #
  #     let listener = try! Socket.ipv4(STREAM)
  #     let client = try! Socket.ipv4(STREAM)
  #
  #     try! socket.bind(ip: '0.0.0.0', port: 9999)
  #     try! socket.listen
  #     try! client.connect(ip: '0.0.0.0', port: 9999)
  def connect(ip: ToIpAddress, port: Int) !! Error {
    let addr =
      try ip.to_ip_address else (e) throw Error.invalid_input(e.to_string)

    try bits.connect(self, addr.to_string, port)
  }

  # Marks this socket as being ready to accept incoming connections using
  # `accept()`.
  #
  # # Examples
  #
  # Marking a socket as a listener:
  #
  #     import std::net::socket::(Socket, STREAM)
  #
  #     let socket = try! Socket.ipv4(STREAM)
  #
  #     try! socket.bind(ip: '0.0.0.0', port: 9999)
  #     try! socket.listen
  def listen !! Error -> Int {
    try bits.listen(self, MAXIMUM_LISTEN_BACKLOG)
  }

  # Accepts a new incoming connection from this socket.
  #
  # This method will not return until a connection is available.
  #
  # # Examples
  #
  # Accepting a connection and reading data from the connection:
  #
  #     import std::net::socket::(Socket, STREAM)
  #
  #     let listener = try! Socket.ipv4(STREAM)
  #     let stream = try! Socket.ipv4(STREAM)
  #
  #     try! listener.bind(ip: '0.0.0.0', port: 9999)
  #     try! listener.listen
  #
  #     try! stream.connect(ip: '0.0.0.0', port: 9999)
  #     try! stream.write_string('ping')
  #
  #     let client = try! listener.accept
  #
  #     try! client.read_string(4) # => 'ping'
  def accept !! Error -> Socket {
    try socket_accept_ip(self) else (error) throw Error.new(error)
  }

  # Sends a `String` to the given address.
  #
  # The return value is the number of bytes sent.
  #
  # # Examples
  #
  #     import std::net::socket::(Socket, DGRAM)
  #
  #     let socket = try! Socket.ipv4(DGRAM)
  #
  #     try! socket.bind(ip: '0.0.0.0', port: 9999)
  #     try! socket.send_string_to(string: 'hello', ip: '0.0.0.0', port: 9999)
  def send_string_to(
    string: String,
    ip: ToIpAddress,
    port: Int
  ) !! Error -> Int {
    let addr =
      try ip.to_ip_address else (e) throw Error.invalid_input(e.to_string)

    try bits.send_string_to(self, string, addr.to_string, port)
  }

  # Sends a `ByteArray` to the given address.
  #
  # The return value is the number of bytes sent.
  #
  # # Examples
  #
  #     import std::net::socket::(Socket, DGRAM)
  #
  #     let socket = try! Socket.ipv4(DGRAM)
  #     let bytes = 'hello'.to_byte_array
  #
  #     try! socket.bind(ip: '0.0.0.0', port: 9999)
  #     try! socket.send_bytes_to(bytes: bytes, ip: '0.0.0.0', port: 9999)
  def send_bytes_to(
    bytes: ref ByteArray,
    ip: ToIpAddress,
    port: Int
  ) !! Error -> Int {
    let addr =
      try ip.to_ip_address else (e) throw Error.invalid_input(e.to_string)

    try bits.send_bytes_to(self, bytes, addr.to_string, port)
  }

  # Receives a single datagram message on the socket, returning the address the
  # message was sent from.
  #
  # The message is read into the given `ByteArray`, and up to `size` bytes will
  # be read.
  #
  # # Examples
  #
  # Sending a message to ourselves and receiving it:
  #
  #     import std::net::socket::(Socket, DGRAM)
  #
  #     let socket = try! Socket.ipv4(DGRAM)
  #     let bytes = ByteArray.new
  #
  #     try! socket.send_to(message: 'hello', ip: '0.0.0.0', port: 9999)
  #
  #     let received_from = try! socket.receive_from(bytes: bytes, size: 5)
  #
  #     bytes.to_string # => 'hello'
  #     received_from.ip.to_string # => '0.0.0.0'
  #     received_from.port # => 9999
  def receive_from(
    bytes: ref ByteArray,
    size: Int
  ) !! Error -> SocketAddress {
    let (addr: String, port: Int) =
      try bits.receive_from(socket: self, bytes: bytes, size: size)

    SocketAddress.new(ip: try! parse_ip(addr), port: port)
  }

  # Returns the local address of this socket.
  def local_address !! Error -> SocketAddress {
    let (addr: String, port: Int) = try bits.local_address(self)

    SocketAddress.new(ip: try! parse_ip(addr), port: port)
  }

  # Returns the peer address of this socket.
  def peer_address !! Error -> SocketAddress {
    let (addr: String, port: Int) = try bits.peer_address(self)

    SocketAddress.new(ip: try! parse_ip(addr), port: port)
  }

  # Returns the value of the `IP_TTL` option.
  def ttl !! Error -> Int {
    try bits.get_ttl(self)
  }

  # Sets the value of the `IP_TTL` option.
  def ttl=(value: Int) !! Error -> Int {
    try bits.set_ttl(self, value)
  }

  # Returns the value of the `IPV6_V6ONLY` option.
  def only_ipv6? !! Error -> Boolean {
    try bits.get_only_v6(self)
  }

  # Sets the value of the `IPV6_V6ONLY` option.
  def only_ipv6=(value: Boolean) !! Error -> Boolean {
    try bits.set_only_v6(self, value)
  }

  # Returns the value of the `TCP_NODELAY` option.
  def no_delay? !! Error -> Boolean {
    try bits.get_nodelay(self)
  }

  # Sets the value of the `TCP_NODELAY` option.
  def no_delay=(value: Boolean) !! Error -> Boolean {
    try bits.set_nodelay(self, value)
  }

  # Returns the value of the `SO_BROADCAST` option.
  def broadcast? !! Error -> Boolean {
    try bits.get_broadcast(self)
  }

  # Sets the value of the `SO_BROADCAST` option.
  def broadcast=(value: Boolean) !! Error -> Boolean {
    try bits.set_broadcast(self, value)
  }

  # Returns the value of the `SO_LINGER` option.
  def linger !! Error -> Duration {
    let seconds = try bits.get_linger(self)

    Duration.new(seconds)
  }

  # Sets the value of the `SO_LINGER` option.
  def linger=(value: ToFloat) !! Error -> Float {
    try bits.set_linger(self, value.to_float)
  }

  # Returns the value of the `SO_RCVBUF` option.
  def receive_buffer_size !! Error -> Int {
    try bits.get_recv_size(self)
  }

  # Sets the value of the `SO_RCVBUF` option.
  def receive_buffer_size=(value: Int) !! Error -> Int {
    try bits.set_recv_size(self, value)
  }

  # Returns the value of the `SO_SNDBUF` option.
  def send_buffer_size !! Error -> Int {
    try bits.get_send_size(self)
  }

  # Sets the value of the `SO_SNDBUF` option.
  def send_buffer_size=(value: Int) !! Error -> Int {
    try bits.set_send_size(self, value)
  }

  # Returns the value of the system's keepalive time.
  def keepalive !! Error -> Duration {
    let seconds = try bits.get_keepalive(self)

    Duration.new(seconds)
  }

  # Sets the value of the keepalive timeout (e.g. `SO_KEEPALIVE` on Unix
  # systems).
  def keepalive=(value: ToFloat) !! Error -> Float {
    try bits.set_keepalive(self, value.to_float)
  }

  # Returns the value of the `IP_MULTICAST_LOOP` option.
  def ipv4_multicast_loop? !! Error -> Boolean {
    try bits.get_multicast_loop_v4(self)
  }

  # Sets the value of the `IP_MULTICAST_LOOP` option.
  def ipv4_multicast_loop=(value: Boolean) !! Error -> Boolean {
    try bits.set_multicast_loop_v4(self, value)
  }

  # Returns the value of the `IPV6_MULTICAST_LOOP` option.
  def ipv6_multicast_loop? !! Error -> Boolean {
    try bits.get_multicast_loop_v6(self)
  }

  # Sets the value of the `IPV6_MULTICAST_LOOP` option.
  def ipv6_multicast_loop=(value: Boolean) !! Error -> Boolean {
    try bits.set_multicast_loop_v6(self, value)
  }

  # Returns the value of the `IP_MULTICAST_TTL` option.
  def ipv4_multicast_ttl !! Error -> Int {
    try bits.get_multicast_ttl_v4(self)
  }

  # Sets the value of the `IP_MULTICAST_TTL` option.
  def ipv4_multicast_ttl=(value: Int) !! Error -> Int {
    try bits.set_multicast_ttl_v4(self, value)
  }

  # Returns the value of the `IPV6_MULTICAST_HOPS` option.
  def ipv6_multicast_hops !! Error -> Int {
    try bits.get_multicast_hops_v6(self)
  }

  # Sets the value of the `IPV6_MULTICAST_HOPS` option.
  def ipv6_multicast_hops=(value: Int) !! Error -> Int {
    try bits.set_multicast_hops_v6(self, value)
  }

  # Returns the value of the `IP_MULTICAST_IF` option.
  def ipv4_multicast_interface !! Error -> Ipv4Address {
    let address_string =
      try bits.get_multicast_if_v4(self)

    # This will only panic if the VM hands out an incorrect IPv4 address, which
    # would be a bug.
    try! Ipv4Address.parse(address_string.to_byte_array)
  }

  # Sets the value of the `IP_MULTICAST_IF` option.
  def ipv4_multicast_interface=(value: ref ToString) !! Error -> String {
    try bits.set_multicast_if_v4(self, value.to_string)
  }

  # Returns the value of the `IPV6_MULTICAST_IF` option.
  def ipv6_multicast_interface !! Error -> Int {
    try bits.get_multicast_if_v6(self)
  }

  # Sets the value of the `IPV6_MULTICAST_IF` option.
  def ipv6_multicast_interface=(value: Int) !! Error -> Int {
    try bits.set_multicast_if_v6(self, value)
  }

  # Returns the value of the `IPV6_UNICAST_HOPS` option.
  def ipv6_unicast_hops !! Error -> Int {
    try bits.get_unicast_hops_v6(self)
  }

  # Sets the value of the `IPV6_UNICAST_HOPS` option.
  def ipv6_unicast_hops=(value: Int) !! Error -> Int {
    try bits.set_unicast_hops_v6(self, value)
  }

  # Returns the value of the `SO_REUSEADDR` option.
  def reuse_address !! Error -> Boolean {
    try bits.get_reuse_address(self)
  }

  # Sets the value of the `SO_REUSEADDR` option.
  def reuse_address=(value: Boolean) !! Error -> Boolean {
    try bits.set_reuse_address(self, value)
  }

  # Returns the value of the `SO_REUSEPORT` option.
  #
  # Not all platforms may support this option, in which case the returned value
  # will be `False`.
  def reuse_port !! Error -> Boolean {
    try bits.get_reuse_port(self)
  }

  # Sets the value of the `SO_REUSEPORT` option.
  #
  # Not all platforms may support this option, in which case the supplied
  # argument will be ignored.
  def reuse_port=(value: Boolean) !! Error -> Boolean {
    try bits.set_reuse_port(self, value)
  }

  # Shuts down the reading half of this socket.
  def shutdown_read !! Error {
    try bits.shutdown_read(self)
  }

  # Shuts down the writing half of this socket.
  def shutdown_write !! Error {
    try bits.shutdown_write(self)
  }

  # Shuts down both the reading and writing half of this socket.
  def shutdown !! Error {
    try bits.shutdown(self)
  }
}

impl RawSocket for Socket {}

impl Read for Socket {
  def read(into: ref ByteArray, size: Int) !! Error -> Int {
    try bits.read_bytes(self, into, size)
  }
}

impl Write for Socket {
  def write_bytes(bytes: ref ByteArray) !! Error -> Int {
    try bits.write_bytes(self, bytes)
  }

  def write_string(string: ref ToString) !! Error -> Int {
    try bits.write_string(self, string.to_string)
  }

  def flush {
    # Sockets can't be flushed, so this method is just a noop.
  }
}

impl Close for Socket {
  move def close {
    _INKOC.close(self)
  }
}

# A UDP socket.
#
# A `UdpSocket` can be used to easily create a bound UDP socket from an IP
# address and a port. Optionally a `UdpSocket` can be connected to another
# socket using `UdpSocket::connect`.
class UdpSocket {
  # The raw `Socket` wrapped by this `UdpSocket`.
  @socket: Socket

  # Creates a new `UdpSocket`, bound to the given address.
  #
  # # Examples
  #
  # Creating a new bound UDP socket:
  #
  #     import std::net::socket::UdpSocket
  #
  #     try! UdpSocket.new(ip: '0.0.0.0', port: 0)
  #
  # You can also supply an existing `IpAddress`:
  #
  #     import std::net::socket::UdpSocket
  #     import std::net::ip::Ipv4Address
  #
  #     try! UdpSocket.new(ip: Ipv4Address.new(0, 0, 0, 0), port: 0)
  static def new(ip: ToIpAddress, port: Int) !! Error -> Self {
    let ip_addr =
      try ip.to_ip_address else (e) throw Error.invalid_input(e.to_string)

    let socket =
      if ip_addr.v6? { try Socket.ipv6(DGRAM) } else { try Socket.ipv4(DGRAM) }

    try socket.bind(ip: ip_addr, port: port)

    Self { @socket = socket }
  }

  # Connects `self` to the remote addres.s
  #
  # Connecting a `UdpSocket` allows sending and receiving data using the
  # methods from `std::io::Read` and `std::io::Write`, instead of having to use
  # `UdpSocket.receive_from` and `UdpSocket.send_to`.
  #
  # # Examples
  #
  # Connecting a UDP socket:
  #
  #     import std::net::socket::UdpSocket
  #
  #     let socket1 = try! UdpSocket.new(ip: '0.0.0.0', port: 40_000)
  #     let socket2 = try! UdpSocket.new(ip: '0.0.0.0', port: 41_000)
  #
  #     try! socket1.connect(ip: '0.0.0.0', port: 41_000)
  def connect(ip: ToIpAddress, port: Int) !! Error {
    try @socket.connect(ip: ip, port: port)
  }

  # Sends a `String` to the given address.
  #
  # See the documentation of `Socket.send_string_to` for more information.
  #
  # # Examples
  #
  #     import std::net::socket::UdpSocket
  #
  #     let socket = try! UdpSocket.new(ip: '0.0.0.0', port: 9999)
  #
  #     try! socket.send_string_to(string: 'hello', ip: '0.0.0.0', port: 9999)
  def send_string_to(
    string: String,
    ip: ToIpAddress,
    port: Int
  ) !! Error -> Int {
    try @socket.send_string_to(string, ip, port)
  }

  # Sends a `ByteArray` to the given address.
  #
  # See the documentation of `Socket.send_bytes_to` for more information.
  #
  # # Examples
  #
  #     import std::net::socket::UdpSocket
  #
  #     let socket = try! UdpSocket.new(ip: '0.0.0.0', port: 9999)
  #     let bytes = 'hello'.to_byte_array
  #
  #     try! socket.send_bytes_to(bytes: bytes, ip: '0.0.0.0', port: 9999)
  def send_bytes_to(
    bytes: ref ByteArray,
    ip: ToIpAddress,
    port: Int
  ) !! Error -> Int {
    try @socket.send_bytes_to(bytes, ip, port)
  }

  # Receives a single datagram message on the socket, returning the address the
  # message was sent from.
  #
  # See the documentation of `Socket.receive_from` for more information.
  def receive_from(
    bytes: ref ByteArray,
    size: Int
  ) !! Error -> SocketAddress {
    try @socket.receive_from(bytes: bytes, size: size)
  }

  # Returns the local address of this socket.
  #
  # See the documentation of `Socket.local_address` for more information.
  def local_address !! Error -> SocketAddress {
    try @socket.local_address
  }

  # Returns the underlying `Socket` object.
  #
  # This method can be used to set additional low-level socket options, without
  # `UdpSocket` having to re-define all these methods.
  def socket -> ref Socket {
    @socket
  }
}

impl Read for UdpSocket {
  def read(into: ref ByteArray, size: Int) !! Error -> Int {
    try @socket.read(into, size)
  }
}

impl Write for UdpSocket {
  def write_bytes(bytes: ref ByteArray) !! Error -> Int {
    try @socket.write_bytes(bytes)
  }

  def write_string(string: ref ToString) !! Error -> Int {
    try @socket.write_string(string.to_string)
  }

  def flush {
    @socket.flush
  }
}

impl Close for UdpSocket {
  move def close {
    @socket.close
  }
}

# A TCP socket connected to another TCP socket.
class TcpStream {
  # The raw `Socket` wrapped by this `TcpStream`.
  @socket: Socket

  # Creates a new `TcpStream` that is connected to the TCP socket at the given
  # IP address and port.
  #
  # # Examples
  #
  # Connecting a `TcpStream`:
  #
  #     import std::net::socket::(TcpListener, TcpStream)
  #
  #     let listener = try! TcpListener.new(ip: '127.0.0.1', port: 40_000)
  #
  #     try! TcpStream.new(ip: '127.0.0.1', port: 40_000)
  static def new(ip: ToIpAddress, port: Int) !! Error -> Self {
    let ip_addr =
      try ip.to_ip_address else (e) throw Error.invalid_input(e.to_string)

    let socket =
      if ip_addr.v6? { try Socket.ipv6(STREAM) } else { try Socket.ipv4(STREAM) }

    try socket.connect(ip: ip_addr, port: port)

    Self { @socket = socket }
  }

  # Returns the local address of this socket.
  #
  # See the documentation of `Socket.local_address` for more information.
  def local_address !! Error -> SocketAddress {
    try @socket.local_address
  }

  # Returns the peer address of this socket.
  #
  # See the documentation of `Socket.peer_address` for more information.
  def peer_address !! Error -> SocketAddress {
    try @socket.peer_address
  }

  # Returns the underlying `Socket` object.
  #
  # This method can be used to set additional low-level socket options, without
  # `TcpStream` having to re-define all these methods.
  def socket -> ref Socket {
    @socket
  }

  # Shuts down the reading half of this socket.
  def shutdown_read !! Error {
    try @socket.shutdown_read
  }

  # Shuts down the writing half of this socket.
  def shutdown_write !! Error {
    try @socket.shutdown_write
  }

  # Shuts down both the reading and writing half of this socket.
  def shutdown !! Error {
    try @socket.shutdown
  }
}

impl Read for TcpStream {
  def read(into: ref ByteArray, size: Int) !! Error -> Int {
    try @socket.read(into, size)
  }
}

impl Write for TcpStream {
  def write_bytes(bytes: ref ByteArray) !! Error -> Int {
    try @socket.write_bytes(bytes)
  }

  def write_string(string: ref ToString) !! Error -> Int {
    try @socket.write_string(string.to_string)
  }

  def flush {
    @socket.flush
  }
}

impl Close for TcpStream {
  move def close {
    @socket.close
  }
}

# A TCP socket server that can accept incoming connections.
class TcpListener {
  # The raw `Socket` wrapped by this `TcpListener`.
  @socket: Socket

  # Creates a new `TcpListener` bound to and listening on the given IP address
  # and port.
  #
  # A `TcpListener` uses `SO_REUSEADDR` and `SO_REUSEPORT` to allow for fast
  # rebinding of sockets. `SO_REUSEPORT` is only used on platforms that support
  # it.
  #
  # The `only_ipv6` argument is ignored when binding to an IPv4 address.
  #
  # # Examples
  #
  # Creating a `TcpListener`:
  #
  #     import std::net::socket::TcpListener
  #
  #     try! TcpListener.new(ip: '0.0.0.0', port: 40_000)
  static def new(
    ip: ToIpAddress,
    port: Int,
  ) !! Error -> Self {
    let ip_addr =
      try ip.to_ip_address else (e) throw Error.invalid_input(e.to_string)

    let socket =
      if ip_addr.v6? { try Socket.ipv6(STREAM) } else { try Socket.ipv4(STREAM) }

    try socket.reuse_address = True
    try socket.reuse_port = True

    try socket.bind(ip: ip_addr, port: port)
    try socket.listen

    Self { @socket = socket }
  }

  # Accepts a new incoming connection from `self`.
  #
  # This method does not return until a connection is available.
  #
  # # Examples
  #
  # Accepting a new connection:
  #
  #     import std::net::socket::(TcpListener, TcpStream)
  #
  #     let listener = try! TcpListener.new(ip: '127.0.0.1', port: 40_000)
  #     let client = try! TcpStream.new(ip: '127.0.0.1', port: 40_000)
  #
  #     client.write_string('ping')
  #
  #     let connection = try! listener.accept
  #
  #     try! connection.read_string(4) # => 'ping'
  def accept !! Error -> TcpStream {
    TcpStream { @socket = try @socket.accept }
  }

  # Returns the local address of this socket.
  #
  # See the documentation of `Socket.local_address` for more information.
  def local_address !! Error -> SocketAddress {
    try @socket.local_address
  }

  # Returns the underlying `Socket` object.
  #
  # This method can be used to set additional low-level socket options, without
  # `TcpListener` having to re-define all these methods.
  def socket -> ref Socket {
    @socket
  }
}

impl Close for TcpListener {
  move def close {
    @socket.close
  }
}
