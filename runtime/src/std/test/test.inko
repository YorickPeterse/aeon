# Types and methods for writing unit tests.
#
# This module defines the various internal types and methods used by
# `std::test`.
import std::ansi::(self, BOLD, CYAN, GREEN, RED)
import std::conversion::ToString
import std::debug::(self, StackFrame)
import std::mirror::(self, BlockMirror, ObjectMirror)
import std::option::Option
import std::process::(self, Process)
import std::stdio::stdout
import std::time::Duration

# The minimum amount of time (in seconds) the test suite should run, before
# displaying the execution time in seconds.
let TIME_IN_SECONDS_THRESHOLD = 1.0

# The default number of processes to run concurrently.
let DEFAULT_CONCURRENCY = 32

# Formats the given object as a `String`.
def inspect(value: ref Any) -> String {
  mirror.reflect(value).inspect
}

# Returns the call frame of an assertion failure.
def failure_location -> StackFrame {
  try! debug.stacktrace(skip: 3, limit: 0).pop.get
}

# A type for formatting the results of tests.
trait Formatter {
  # Displays the result of a passed test.
  def passed(test: ref TestResult)

  # Displays the result of a failed test.
  def failed(test: ref TestResult)

  # Displays all of the failed tests after the test suite has finished.
  def failures(tests: ref Array!(TestResult))

  # Displays a summary of the tests executed, after all tests finished.
  def finished(duration: Duration)
}

# A formatter that displays tests similar to a progress bar.
#
# The produced output is inspired by existing test frameworks such as RSpec and
# ExUnit. Output is colorised using ANSI escape sequences, though this can be
# disabled if necessary.
#
# Passed tests are displayed as a ".", while failed tests are displayed as "F".
# All output is written to STDOUT.
class ProgressFormatter {
  # The total number of tests run.
  @tests: Int

  # The number of failed tests.
  @failed: Int

  # When set to `True`, certain parts of the output will be wrapped in ANSI
  # escape sequences.
  @colors: Boolean

  static def new(colors: Boolean) -> Self {
    Self { @tests = 0, @failed = 0, @colors = colors }
  }

  # Returns the location of a test failure.
  def format_location(location: ref StackFrame) -> String {
    `{location.path}:{location.line}`
  }

  # Returns the unit of time to use for displaying the test suite execution
  # time.
  def duration_unit(duration: ref Duration) -> String {
    if duration.to_seconds > TIME_IN_SECONDS_THRESHOLD {
      'seconds'
    } else {
      'milliseconds'
    }
  }

  # Returns the duration of the test suite as a Float.
  #
  # If the test suite took more than 1 second to execute, then the returned
  # value is in seconds. If the suite took less than 1 second, then the value is
  # in milliseconds instead.
  def duration_time(duration: ref Duration) -> Float {
    let time = duration.to_seconds

    if time > TIME_IN_SECONDS_THRESHOLD {
      time
    } else {
      duration.to_milliseconds
    }
  }

  # Returns a `String` containing some statistics about the test suite.
  def test_suite_statistics -> String {
    let stats = `{@tests} tests, {@failed} failures`

    if @failed.positive? { red(stats) } else { green(stats) }
  }

  def green(string: String) -> String {
    color(string, GREEN)
  }

  def red(string: String) -> String {
    color(string, RED)
  }

  def cyan(string: String) -> String {
    color(string, CYAN)
  }

  def bold(string: String) -> String {
    color(string, BOLD)
  }

  def color(string: String, code: String) -> String {
    if @colors { ansi.wrap(string, code) } else { string.to_string }
  }
}

impl Formatter for ProgressFormatter {
  def passed(test: ref TestResult) {
    @tests += 1

    stdout.write_string(green('.'))
  }

  def failed(test: ref TestResult) {
    @failed += 1
    @tests += 1

    stdout.write_string(red('F'))
  }

  # Displays a list of all the failed tests.
  def failures(tests: ref Array!(TestResult)) {
    stdout.write_string("\n\nFailures:")

    for (index, failed) in tests.iter.with_index {
      let failure = try! failed.failure.get_ref
      let output = `

  Group:            {failed.test.group_description}
  Test:             {bold(failed.test.description.clone)}
  Test location:    {cyan(format_location(failed.test.defined_at))}
  Failure location: {cyan(format_location(failure.failed_at))}
  Failure:          {red(failure.description.clone)}`

      stdout.write_string(output)
    }
  }

  # Displays a summary of the test suite, once the suite has finished running.
  def finished(duration: Duration) {
    let output = `

Finished running in {duration_time(duration)} {duration_unit(duration)}
{test_suite_statistics}`

    stdout.print(output)
  }
}

# An assertion that failed.
class Failure {
  # The description of the assertion failure.
  @description: String

  # The location on which the failure happened.
  @failed_at: StackFrame

  static def new(description: String, failed_at: StackFrame) -> Self {
    Self { @description = description, @failed_at = failed_at }
  }

  # Returns the message describing the failure.
  def description -> String {
    @description.clone
  }

  # Returns the location of the assertion failure.
  def failed_at -> ref StackFrame {
    @failed_at
  }
}

# The result of a single unit test.
class TestResult {
  # The test that was run.
  @test: Test

  # The test failure, if any.
  #
  # If the failure is a None, it means the test passed.
  @failure: ?Failure

  static def new(test: Test, failure: ?Failure) -> Self {
    Self { @test = test, @failure = failure }
  }

  # Returns the test that was run.
  def test -> ref Test {
    @test
  }

  # Returns the test failure, if any.
  def failure -> ref ?Failure {
    @failure
  }
}

# A request to run a unit test.
class TestRequest {
  # The test to run.
  @test: Test

  # The process to send the results back to.
  @reply_to: Process

  static def new(test: Test, reply_to: Process) -> Self {
    Self { @test = test, @reply_to = reply_to }
  }

  # Runs the test request, and sends the results back to a process.
  move def run {
    try @test.code.call else (error) {
      @reply_to.send(TestResult.new(@test, failure: Option.some(error)))
      return
    }

    @reply_to.send(TestResult.new(@test, failure: Option.none))
  }
}

# A single unit test to run in a process.
class Test {
  # The description of the test.
  @description: String

  # The description of the test group this test belongds to.
  @group_description: String

  # The code to run for this test.
  @code: fn !! Failure

  static def new(
    description: String,
    group_description: String,
    code: fn !! Failure
  ) -> Self {
    Self {
      @description = description,
      @group_description = group_description,
      @code = code
    }
  }

  # Returns the description of the test.
  def description -> String {
    @description.clone
  }

  # Returns the group description of the test.
  def group_description -> String {
    @group_description.clone
  }

  # Returns the code to run.
  def code -> ref fn !! Failure {
    @code
  }

  # Returns the location of the test definition.
  def defined_at -> StackFrame {
    let mirror = BlockMirror.new(@code)

    StackFrame.new(path: mirror.path, name: mirror.name, line: mirror.line)
  }

  # Schedules the test for execution in a separate process.
  move def schedule {
    let runner = process.spawn {
      match let request = process.receive {
        as TestRequest -> { request.run }
        else -> {}
      }
    }

    runner.send(TestRequest.new(self, reply_to: process.current))
  }
}

# A group of tests related to one another.
class Group {
  # The description of the test group.
  @description: String

  # The collection of tests to add new tests to.
  @tests: ref Array!(Test)

  static def new(description: String, tests: ref Array!(Test)) -> Self {
    Self { @description = description, @tests = tests }
  }

  # Add a new test to this group.
  def test(description: String, code: fn !! Failure) {
    let test = Test.new(
      description: description,
      group_description: @description.clone,
      code: code
    )

    @tests.push(test)
  }
}
