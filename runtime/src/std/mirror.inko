# ObjectMirror based reflection for objects
#
# This module provides a reflection API based on the concept of
# [Mirrors](https://en.wikipedia.org/wiki/Mirror_(programming)). Mirrors are not
# exposed unless this module is imported.
#
# The use of mirrors for reflection provides several benefits:
#
# 1. Reflection is decoupled from the objects reflected upon.
# 2. Objects won't be polluted with reflection specific attributes.
# 3. It's possible to reflect on remote objects (e.g. an object in another
#    process or on another computer).
# 4. One can remove the mirror system entirely if desired, whereas removing
#    random methods defined on `Object` is much harder.
#
# Let's illustrate the differences between a mirror based API and the usual
# reflection APIs found in most languages. Say we have a class based language
# and we want to obtain the class of an object. In most languages we would
# achieve this by writing code along the lines of the following:
#
#     some_object.class
#
# Here the "class" message would return whatever the class is of the receiving
# object. Another example would be dynamically retrieving an attribute by its
# name. Typically this is done as follows:
#
#     some_object.get_attribute('my_attribute')
#
# In both cases the methods are exposed directly to the object.
#
# When using mirrors there are two steps required to perform reflection:
#
# 1. Create a mirror for a certain object.
# 2. Use the mirror's API to perform reflection.
#
# For our first example this means we'd end up with code along the lines of the
# following:
#
#     reflect(some_object).class
#
# Here the `reflect` method would return some kind of mirror and the `class`
# message would return the class of the object reflected upon. Translating the
# second example to a mirror based approach results in similar code:
#
#     reflect(some_object).get_attribute('my_attribute')
#
# # Using Mirrors
#
# Using mirrors in Inko is straightforward. Let's say we want to obtain the
# value of an attribute using the mirror API. We can do so as follows:
#
#     import std::mirror
#
#     class Person {
#       @name: String
#
#       static def new(name: String) -> Self {
#         Self { @name = name }
#       }
#     }
#
#     let person = Person.new('alice')
#
#     mirror.reflect(person).get_attribute('@name') # => 'Alice'
#
# You can also use mirrors to format objects in a human-readable way. This is
# useful when debugging or using a REPL:
#
#     import std::mirror
#
#     class Person {
#       @name: String
#
#       static def new(name: String) -> Self {
#         Self { @name = name }
#       }
#     }
#
#     let person = Person.new('alice')
#
#     reflect(person).inspect # => 'Person { @name = "Alice" }'
#
# # Performance
#
# Like most reflection systems mirrors do come with overhead. In particular, a
# mirror has to be allocated every time you need one. As such we recommend
# against using mirrors/reflection in performance critical code.
import std::format::(DefaultFormatter, Format, Formatter)
import std::fs::path::Path
import std::hash::Hash
import std::map::Map
import std::module::Module
import std::operators::Equal
import std::option::Option
import std::pair::(Triple, Pair)
import std::set::Set

# The default name to use for objects that don't have an explicit name.
let DEFAULT_OBJECT_NAME = 'Object'

# The name of the attribute that contains the name of an object.
let OBJECT_NAME_ATTRIBUTE = '@_object_name'

# The name of the attribute that stores all the implemented traits.
let IMPLEMENTED_TRAITS_ATTRIBUTE = '@_implemented_traits'

extern def block_name(block: ref Block) -> String
extern def block_file(block: ref Block) -> String
extern def block_line(block: ref Block) -> Int
extern def block_arguments(block: ref Block) -> Array!(String)
extern def module_name(module: ref Module) -> String
extern def module_source_path(module: ref Module) -> String
extern def object_attribute_names(object: ref Any) -> Array!(Any)
extern def string_format_debug(string: ref String) -> String

# An object for reflecting upon another object.
trait Mirror: Format {
  # Returns the object reflected upon.
  def subject -> ref Any

  # Returns `True` if the subject is the exact same object as the given
  # argument.
  #
  # This method works for any two objects, and doesn't depend on the
  # `same_object?` and `==` methods.
  def subject_same_object?(other: ref Any) -> Boolean {
    _INKOC.object_equals(subject, other)
  }

  # Returns the object the subject is an instance of.
  #
  # # Examples
  #
  # Obtaining the object a subject is an instance of:
  #
  #     import std::mirror::ObjectMirror
  #
  #     ObjectMirror.new('hello').instance_of # => String
  def instance_of -> Any {
    _INKOC.get_prototype(subject)
  }

  # Returns the value of an attribute.
  #
  # Since attributes may not be set this method can return a value of any type.
  #
  # # Examples
  #
  # Getting the value of an undefined attribute:
  #
  #     import std::mirror::ObjectMirror
  #
  #     class Dummy {}
  #
  #     let obj = Dummy {}
  #     let mirror = ObjectMirror.new(obj)
  #
  #     mirror.get_attribute(obj, 'name') # => Nil
  #
  # Getting the value of an existing attribute:
  #
  #     import std::mirror::ObjectMirror
  #
  #     class Dummy {
  #       @name: String
  #     }
  #
  #     let obj = Dummy { @name = 'Alice' }
  #     let mirror = ObjectMirror.new(obj)
  #
  #     mirror.get_attribute('name') # => 'Alice'
  def get_attribute(name: String) -> Any {
    # TODO: use get_attribute_by_name()
    _INKOC.get_attribute(subject, name)
  }

  # Returns the names of all the attributes defined directly on the subject.
  #
  # # Examples
  #
  # Getting the attributes of an object:
  #
  #     import std::mirror::ObjectMirror
  #
  #     class Person {
  #       @name: String
  #
  #       static def new(name: String) -> Self {
  #         Self { @name = name }
  #       }
  #     }
  #
  #     let person = Person.new('Alice')
  #     let mirror = ObjectMirror.new(person)
  #
  #     mirror.attributes # => Array.new('@name')
  def attributes -> Array!(String) {
    object_attribute_names(subject) as Array!(String)
  }

  # Returns `True` if the subject is an instance of the given object.
  #
  # # Examples
  #
  # Checking if a `String` is an instance of `String`:
  #
  #     import std::mirror::ObjectMirror
  #
  #     let string_mirror = ObjectMirror.new('hello')
  #
  #     string_mirror.instance_of?(String) # => True
  #     string_mirror.instance_of?(Int) # => False
  def instance_of?(other: ref Any) -> Boolean {
    let mut proto = _INKOC.get_prototype(subject)

    loop {
      if _INKOC.object_equals(proto, other) { return True }

      proto = _INKOC.get_prototype(proto) as Object

      if _INKOC.object_equals(proto, Nil) { return False }
    }
  }

  # Returns `True` if the subject implements the given trait.
  #
  # # Examples
  #
  # Checking if an object implements a trait:
  #
  #     import std::mirror::ObjectMirror
  #
  #     trait Trait1 {}
  #     trait Trait2 {}
  #
  #     class ExampleObject impl Trait1 {}
  #
  #     let mirror = ObjectMirror.new(ExampleObject.new)
  #
  #     mirror.implements_trait?(Trait1) # => True
  #     mirror.implements_trait?(Trait2) # => False
  def implements_trait?(find: ref Trait) -> Boolean {
    let mut subject = subject

    loop {
      let traits = _INKOC.get_attribute(subject, IMPLEMENTED_TRAITS_ATTRIBUTE)

      if traits {
        let exists = _INKOC.get_attribute(traits, find)

        if _INKOC.object_equals(exists, True) { return True }
      }

      subject = _INKOC.get_prototype(subject)

      # If an object does not have a prototype (e.g. Object), Nil will be
      # returned. Since we don't know the difference between "has no prototype"
      # and "the prototype is Nil", we will just bail out once we hit Nil as the
      # prototype. This works fine for Nil itself, because there is only a
      # single instance of it.
      if _INKOC.object_equals(subject, Nil) { return False }
    }
  }

  # Returns the traits implemented by the subject.
  #
  # # Examples
  #
  # Obtaining the implemented traits of an object:
  #
  #     import std::conversion::ToString
  #     import std::mirror::ObjectMirror
  #
  #     class Person impl ToString {
  #       def to_string -> String {
  #         'Alice'
  #       }
  #     }
  #
  #     ObjectMirror.new(Person).implemented_traits # => Array.new(ToString)
  def implemented_traits -> Array!(Trait) {
    let impl_set = get_attribute(IMPLEMENTED_TRAITS_ATTRIBUTE) as Any

    if _INKOC.object_equals(impl_set, Nil) { return Array.new }

    object_attribute_names(impl_set) as Array!(Trait)
  }

  # Returns the names of all instance attributes defined directly on the
  # subject.
  #
  # Getting the attributes of an object:
  #
  #     import std::mirror::ObjectMirror
  #
  #     class Person {
  #       @name: String
  #
  #       static def new(name: String) -> Self {
  #         Self { @name = name }
  #       }
  #     }
  #
  #     let person = Person.new('Alice')
  #
  #     ObjectMirror.new(person).attributes # => Array.new('@name')
  #     ObjectMirror.new(Person).attributes # => Array.new('@_object_name')
  def instance_attributes -> Array!(String) {
    attributes.into_iter.select do (name) { name.starts_with?('@') }.to_array
  }

  # Formats the mirrored object in a human-readable format for debugging
  # purposes.
  def inspect -> String {
    let fmt = DefaultFormatter.new

    format(fmt)
    fmt.to_string
  }
}

# An object that can be mirrored.
#
# This trait can be implemented by objects wishing to provide a custom mirror.
trait Mirrored {
  # Returns a mirror for `self`.
  def mirror -> Mirror
}

# A generic mirror for a regular object.
class ObjectMirror!(T) {
  # The object that is being mirrored.
  @subject: ref T

  static def new(subject: ref T) -> Self {
    Self { @subject = subject }
  }

  # Sets the attribute of an object to the given value, returning the stored
  # value.
  #
  # # Examples
  #
  # Setting an attribute:
  #
  #     import std::mirror::ObjectMirror
  #
  #     let mut obj = Object.new
  #
  #     ObjectMirror.new(obj).set_attribute('name', 'Alice') # => 'Alice'
  def set_attribute!(V)(name: String, value: V) -> V {
    _INKOC.set_attribute(@subject, name, value)
  }

  # Returns the name of the subject.
  #
  # # Examples
  #
  # Returning the name of an object:
  #
  #     import std::mirror::ObjectMirror
  #
  #     class Person {}
  #
  #     ObjectMirror.new(Person).name # => 'Person'
  def name -> String {
    match let name = get_attribute(OBJECT_NAME_ATTRIBUTE) {
      as String -> { name }
      else -> { DEFAULT_OBJECT_NAME }
    }
  }
}

impl Format for ObjectMirror {
  def format(formatter: ref Formatter) {
    let attributes = instance_attributes

    formatter.push(name)

    if attributes.empty? { return }

    formatter.push(' {')

    for (index, attr_name) in attributes.into_iter.with_index {
      if index.positive? { formatter.push(',') }

      formatter.push(` {attr_name} = `)

      formatter.descend {
        reflect(get_attribute(attr_name)).format(formatter)
      }
    }

    formatter.push(' }')
  }
}

impl Mirror for ObjectMirror {
  def subject -> ref T {
    @subject
  }
}

# A mirror for a `Block`.
class BlockMirror {
  # The block that is being mirrored.
  @subject: ref Block

  static def new(subject: ref Block) -> Self {
    Self { @subject = subject }
  }

  # Returns the file path of the file the block is defined in.
  #
  # # Examples
  #
  # Returning the file path of a method:
  #
  #     import std::mirror::BlockMirror
  #
  #     let method = def example {}
  #     let mirror = BlockMirror.new(method)
  #
  #     mirror.path # => Path
  def path -> Path {
    Path.new(block_file(@subject))
  }

  # Returns the line number the block is defined on.
  #
  # # Examples
  #
  # Returning the line number of a method:
  #
  #     import std::mirror::BlockMirror
  #
  #     let method = def example {}
  #     let mirror = BlockMirror.new(method)
  #
  #     mirror.line # => 3
  def line -> Int {
    block_line(@subject)
  }

  # Returns the argument names of the block.
  #
  # # Examples
  #
  # Returning the argument names of a method:
  #
  #     import std::mirror::BlockMirror
  #
  #     let method = def example(number) {}
  #     let mirror = BlockMirror.new(method)
  #
  #     mirror.argument_names # => Array.new('@subject', 'number')
  def argument_names -> Array!(String) {
    block_arguments(@subject)
  }

  # Returns the name of the block.
  #
  # # Examples
  #
  # Returning the name of a method:
  #
  #     import std::mirror::BlockMirror
  #
  #     let method = def example {}
  #     let mirror = BlockMirror.new(method)
  #
  #     mirror.name # => 'example'
  def name -> String {
    block_name(@subject)
  }
}

impl Format for BlockMirror {
  def format(formatter: ref Formatter) {
    formatter.push('Block')
  }
}

impl Mirror for BlockMirror {
  def subject -> ref Block {
    @subject
  }
}

# A mirror for a `Module`.
class ModuleMirror {
  @subject: ref Module

  static def new(subject: ref Module) -> Self {
    Self { @subject = subject }
  }

  # Returns the name of the module.
  def name -> String {
    module_name(@subject)
  }

  # Returns the path of the source file that defined the module.
  def source_path -> Path {
    Path.new(module_source_path(@subject))
  }
}

impl Format for ModuleMirror {
  def format(formatter: ref Formatter) {
    formatter.push(`Module \{ {name} }`)
  }
}

impl Mirror for ModuleMirror {
  def subject -> ref Module {
    @subject
  }
}

# A mirror for an `Array`.
class ArrayMirror!(T) {
  # The `Array` that is mirrored.
  @subject: ref Array!(T)

  static def new(subject: ref Array!(T)) -> Self {
    Self { @subject = subject }
  }
}

impl Format for ArrayMirror {
  def format(formatter: ref Formatter) {
    formatter.push('Array')

    if @subject.empty? { return }

    formatter.push(' { ')

    for (index, value) in @subject.iter.with_index {
      if index.positive? { formatter.push(', ') }

      formatter.descend { reflect(value).format(formatter) }
    }

    formatter.push(' }')
  }
}

impl Mirror for ArrayMirror {
  def subject -> ref Array!(T) {
    @subject
  }
}

# A mirror for a `ByteArray`.
class ByteArrayMirror {
  # The `ByteArray` that is mirrored.
  @subject: ref ByteArray

  static def new(subject: ref ByteArray) -> Self {
    Self { @subject = subject }
  }
}

impl Format for ByteArrayMirror {
  def format(formatter: ref Formatter) {
    formatter.push(`ByteArray \{ {@subject.length} bytes }`)
  }
}

impl Mirror for ByteArrayMirror {
  def subject -> ref ByteArray {
    @subject
  }
}

# A mirror for a `Map`
class MapMirror!(K: Hash + Equal, V) {
  # The `Map` that is mirrored.
  @subject: ref Map!(K, V)

  static def new!(K: Hash + Equal, V)(
    subject: ref Map!(K, V)
  ) -> MapMirror!(K, V) {
    Self { @subject = subject }
  }
}

impl Format for MapMirror {
  def format(formatter: ref Formatter) {
    let mut index = 0

    formatter.push('Map')

    if @subject.empty? { return }

    formatter.push(' { ')

    for (key, value) in @subject {
      if index.positive? { formatter.push(', ') }

      formatter.descend { reflect(key).format(formatter) }
      formatter.push(': ')
      formatter.descend { reflect(value).format(formatter) }

      index += 1
    }

    formatter.push(' }')
  }
}

impl Mirror for MapMirror {
  def subject -> ref Map!(K, V) {
    @subject
  }
}

# A mirror for a `Set`.
class SetMirror!(V: Hash + Equal) {
  # The `Set` that is mirrored.
  @subject: ref Set!(V)

  static def new!(V: Hash + Equal)(subject: ref Set!(V)) -> SetMirror!(V) {
    Self { @subject = subject }
  }
}

impl Format for SetMirror {
  def format(formatter: ref Formatter) {
    let mut index = 0

    formatter.push('Set')

    if @subject.empty? { return }

    formatter.push(' { ')

    for value in @subject {
      if index.positive? { formatter.push(', ') }

      formatter.descend { reflect(value).format(formatter) }

      index += 1
    }

    formatter.push(' }')
  }
}

impl Mirror for SetMirror {
  def subject -> ref Set!(V) {
    @subject
  }
}

# A mirror for a `Pair`.
class PairMirror!(A, B) {
  # The `Pair` that is mirrored
  @subject: ref Pair!(A, B)

  static def new!(A, B)(subject: ref Pair!(A, B)) -> PairMirror!(A, B) {
    Self { @subject = subject }
  }
}

impl Format for PairMirror {
  def format(formatter: ref Formatter) {
    formatter.push('Pair { ')
    formatter.descend { reflect(@subject.0).format(formatter) }
    formatter.push(', ')
    formatter.descend { reflect(@subject.1).format(formatter) }
    formatter.push(' }')
  }
}

impl Mirror for PairMirror {
  def subject -> ref Pair!(A, B) {
    @subject
  }
}

# A mirror for a `Triple`.
class TripleMirror!(A, B, C) {
  # The `Triple` that is mirrored
  @subject: ref Triple!(A, B, C)

  static def new!(A, B, C)(
    subject: ref Triple!(A, B, C)
  ) -> TripleMirror!(A, B, C) {
    Self { @subject = subject }
  }
}

impl Format for TripleMirror {
  def format(formatter: ref Formatter) {
    formatter.push('Triple { ')
    formatter.descend { reflect(@subject.0).format(formatter) }
    formatter.push(', ')
    formatter.descend { reflect(@subject.1).format(formatter) }
    formatter.push(', ')
    formatter.descend { reflect(@subject.2).format(formatter) }
    formatter.push(' }')
  }
}

impl Mirror for TripleMirror {
  def subject -> ref Triple!(A, B, C) {
    @subject
  }
}

# A mirror for an `Int`.
class IntegerMirror {
  # The `Int` that is mirrored.
  @subject: Int

  static def new(subject: Int) -> Self {
    Self { @subject = subject }
  }
}

impl Format for IntegerMirror {
  def format(formatter: ref Formatter) {
    formatter.push(@subject.to_string)
  }
}

impl Mirror for IntegerMirror {
  def subject -> ref Int {
    @subject
  }
}

# A mirror for a `Float`.
class FloatMirror {
  # The `Float` that is mirrored.
  @subject: Float

  static def new(subject: Float) -> Self {
    Self { @subject = subject }
  }
}

impl Format for FloatMirror {
  def format(formatter: ref Formatter) {
    formatter.push(@subject.to_string)
  }
}

impl Mirror for FloatMirror {
  def subject -> ref Float {
    @subject
  }
}

# A mirror for a `String`.
class StringMirror {
  # The `String` that is mirrored.
  @subject: String

  static def new(subject: String) -> Self {
    Self { @subject = subject }
  }
}

impl Format for StringMirror {
  def format(formatter: ref Formatter) {
    formatter.push(string_format_debug(@subject))
  }
}

impl Mirror for StringMirror {
  def subject -> ref String {
    @subject
  }
}

# A mirror for a `Boolean`
class BooleanMirror {
  # The `Boolean` that is mirrored.
  @subject: Boolean

  static def new(subject: Boolean) -> Self {
    Self { @subject = subject }
  }
}

impl Format for BooleanMirror {
  def format(formatter: ref Formatter) {
    formatter.push(@subject.to_string)
  }
}

impl Mirror for BooleanMirror {
  def subject -> ref Boolean {
    @subject
  }
}

# A mirror for `Nil`
class NilMirror {
  # The `Nil` that is mirrored.
  @subject: Nil

  static def new(subject: Nil) -> Self {
    Self { @subject = subject }
  }
}

impl Format for NilMirror {
  def format(formatter: ref Formatter) {
    formatter.push('Nil')
  }
}

impl Mirror for NilMirror {
  def subject -> ref Nil {
    @subject
  }
}

# A mirror for an `Option`.
class OptionMirror!(T) {
  @subject: ref ?T

  static def new!(T)(subject: ref ?T) -> OptionMirror!(T) {
    Self { @subject = subject }
  }
}

impl Format for OptionMirror {
  def format(formatter: ref Formatter) {
    let val = try @subject.get_ref else {
      formatter.push('None')
      return
    }

    formatter.push('Some(')
    formatter.descend { reflect(val).format(formatter) }
    formatter.push(')')
  }
}

impl Mirror for OptionMirror {
  def subject -> ref ?T {
    @subject
  }
}

# Returns a mirror for the given object.
#
# If an object implements the `Mirrored` trait, the implementation is used to
# determine what mirror to return. If the trait isn't implemented, a mirror is
# returned based on the `subject` argument type.
def reflect(subject: ref Any) -> Mirror {
  match let matched = subject {
    as Int -> { IntegerMirror.new(matched.clone) }
    as Float -> { FloatMirror.new(matched.clone) }
    as String -> { StringMirror.new(matched.clone) }
    as Boolean -> { BooleanMirror.new(matched.clone) }
    as NilType -> { NilMirror.new(matched.clone) }
    as Array -> { ArrayMirror.new(matched) }
    as ByteArray -> { ByteArrayMirror.new(matched) }
    as Map -> { MapMirror.new(matched) }
    as Set -> { SetMirror.new(matched) }
    as Pair -> { PairMirror.new(matched) }
    as Triple -> { TripleMirror.new(matched) }
    as Block -> { BlockMirror.new(matched) }
    as Module -> { ModuleMirror.new(matched) }
    as Option -> { OptionMirror.new(matched) }
    as Mirrored -> { matched.mirror }
    else -> { ObjectMirror.new(subject) }
  } as Mirror
}
