# An ordered, contiguous growable sequence of values.
#
# Arrays (sometimes called vectors or lists) can be used to store values of the
# same type in order. Arrays are mutable and allow you to add new values or
# remove existing values.
#
# # Indexing
#
# Like most programming languages Arrays indexes are zero based, with the first
# value being located at index 0.
#
# It's possible to use a negative index (e.g. -2) when accessing or setting
# indexes, in which case the value will be accessed starting at the back of the
# Array. This means that -1 will access the last value, -2 the value before
# that, etc.
import std::clone::Clone
import std::conversion::ToArray
import std::hash::(Hash, Hasher)
import std::index::(Index, SetIndex)
import std::length::Length
import std::loop::(repeat)
import std::operators::Equal
import std::option::Option

extern def array_clear(array: ref Array!(Any))

impl Array {
  # Returns a new Array containing the given values.
  #
  # # Examples
  #
  # Creating an empty Array:
  #
  #     Array.new
  #
  # Creating an Array with values:
  #
  #     Array.new(10, 20, 30)
  static def new!(V)(*values: V) -> Array!(V) {
    values
  }

  # Returns an array filled with a certain amount of values.
  #
  # The `amount` argument specifies how many times the `value` argument must
  # exist in the array.
  #
  # # Examples
  #
  # Creating an `Array` with four integers:
  #
  #     Array.filled(amount: 4, value: 0) # => Array.new(0, 0, 0, 0)
  #
  # # Panics
  #
  # This method panics if the amount is a negative number.
  static def filled!(V: Clone)(amount: Int, value: ref V) -> Array!(V) {
    if amount.negative? {
      _INKOC.panic('The fill amount must be equal to or greater than zero')
    }

    let array = new

    repeat(amount) do (_) { array.push(value.clone) }
    array
  }

  # Removes all values of this Array, then returns self.
  #
  # # Examples
  #
  #     let array = Array.new(10, 20, 30)
  #
  #     array.clear
  #     array.empty? # => True
  def clear {
    array_clear(self)
  }

  # Pushes a value to the back of the Array.
  #
  # # Examples
  #
  # Pushing a value into an Array:
  #
  #     let array = Array.new
  #
  #     array.push(10) # => Nil
  #     array[0]       # => 10
  def push(value: T) {
    self[length] = value
  }

  # Removes a value from the back of the Array, returning the removed value.
  #
  # If no value was found, a None is returned instead.
  #
  # # Examples
  #
  # Popping an existing value:
  #
  #     let array = Array.new(10)
  #
  #     array.pop    # => Option.some(10)
  #     array.empty? # => True
  #
  # Popping a value when the Array is empty:
  #
  #     let array = Array.new
  #
  #     array.pop # => Option.none
  def pop -> ?T {
    if empty? { Option.none } else { Option.some(remove_at(length - 1)) }
  }

  # Removes the value at the given index, returning the removed value.
  #
  # # Examples
  #
  # Removing an existing value will result in the value being removed from the
  # Array and returned:
  #
  #     let array = Array.new(10)
  #
  #     array.remove_at(0) # => 10
  #     array.empty?       # => True
  #
  # # Panics
  #
  # This method panics when the index is out of bounds.
  def remove_at(index: Int) -> T {
    _INKOC.array_remove(self, index) as T
  }

  # Returns `True` if `self` contains the given value.
  #
  # # Examples
  #
  # Checking if an `Array` contains a value:
  #
  #     Array.new(10, 20, 30).contains?(10) # => True
  def contains?(value: ref T) -> Boolean when T: Equal {
    let mut index = 0
    let max = length

    while index < max {
      if self[index] == value { return True }

      index += 1
    }

    False
  }

  # Returns the value at the given index, returning None if the index is out of
  # bounds.
  #
  # # Examples
  #
  # Retrieving an existing value:
  #
  #     let numbers = Array.new(10, 20)
  #
  #     numbers.get(0) # => Option.some(10)
  #
  # Retrieving a value from a non-existing index:
  #
  #     let numbers = Array.new(10, 20)
  #
  #     numbers.get(5) # => Option.none
  def get(index: Int) -> ?ref T {
    try Option.some(ref(_INKOC.array_at(self, index) as T)) else Option.none
  }

  # Inserts the value at the given index, returning the old value.
  #
  # # Panics
  #
  # This method panics when the index is out of bounds.
  def swap(index: Int, value: T) -> T {
    let old_value =
      try _INKOC.array_at(self, index) else (err) _INKOC.panic(err as String)

    _INKOC.array_set(self, index, value)
    old_value as T
  }
}

impl Length for Array {
  # Returns the number of values in this Array.
  #
  # # Examples
  #
  # Getting the length of an empty Array:
  #
  #     Array.new.length # => 0
  #
  # Getting the length of an Array with values:
  #
  #     Array.new(10).length # => 1
  def length -> Int {
    _INKOC.array_length(self)
  }
}

impl Index!(Int, ref T) for Array {
  # Returns the value at the given index.
  #
  # # Examples
  #
  # Retrieving a value by its index:
  #
  #     let array = Array.new(10, 20, 30)
  #
  #     array[1] # => 20
  #
  # We can also use a negative index to access a value from the back of the
  # Array:
  #
  #     let array = Array.new(10, 20, 30)
  #
  #     array[-2] # => 20
  #
  # # Panics
  #
  # This method panics when the index is out of bounds.
  def [](index: Int) -> ref T {
    ref try {
      _INKOC.array_at(self, index)
    } else (err) {
      _INKOC.panic(err as String)
    } as T
  }
}

impl SetIndex!(Int, T) for Array {
  # Stores a value at the given index, then returns it.
  #
  # # Examples
  #
  # Setting an index to a value:
  #
  #     let array = Array.new
  #
  #     array[0] = 10 # => 10
  #     array         # => Array.new(10)
  #
  # We can also use negative indexes:
  #
  #     let array = Array.new(10)
  #
  #     array[-1] = 20 # => 20
  #     array          # => Array.new(20)
  #
  # # Panics
  #
  # This method panics if the index is out of bounds.
  def []=(index: Int, value: T) {
    _INKOC.array_set(self, index, value)
  }
}

impl Clone for Array {
  def clone -> Self when T: Clone {
    let copy = Array.new
    let mut index = 0
    let max = length

    while index < max {
      copy.push(self[index].clone)
      index += 1
    }

    copy
  }
}

impl ToArray!(T) for Array {
  # Returns a copy of the array and all of its values.
  #
  # # Examples
  #
  # "Converting" an array to an array:
  #
  #     Array.new(10).to_array # => Array.new(10)
  def to_array -> Array!(T) when T: Clone {
    clone
  }
}

impl Equal for Array {
  # Returns `True` if `self` and the given `Array` are identical.
  #
  # # Examples
  #
  # Comparing two identical arrays:
  #
  #     Array.new(10, 20, 30) == Array.new(10, 20, 30) # => True
  #
  # Comparing two arrays with a different length:
  #
  #     Array.new(10) == Array.new(10, 20) # => False
  #
  # Comparing two arrays with the same length but with different values:
  #
  #     Array.new(10, 20) == Array.new(20, 10) # => False
  def ==(other: ref Self) -> Boolean when T: Equal {
    if length != other.length { return False }

    let mut index = 0
    let max = length

    while index < max {
      let ours = self[index]
      let theirs = other[index]

      if ours != theirs { return False }

      index += 1
    }

    True
  }
}

impl Hash for Array {
  def hash(hasher: ref Hasher) when T: Hash {
    let mut index = 0
    let max = length

    while index < max {
      self[index].hash(hasher)
      index += 1
    }
  }
}
