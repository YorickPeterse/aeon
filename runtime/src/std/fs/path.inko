# Cross-platform paths to files and directories.
#
# This module provides several types: the `Path` class, and the traits `ToPath`
# and `IntoPath`.
#
# A `Path` represents a file system path. `ToPath` is used to create a new
# `Path` from an existing type, without moving it. `IntoPath` also creates a
# `Path`, but moves its receiver.
#
# # Using ToPath and IntoPath for generic path inputs
#
# Sometimes you may have a method that should accept multiple types as input
# paths, such as a `String`, a `Path`, and possibly other types.
#
# One approach is to define a method like so:
#
#     import std::fs::path::ToPath
#
#     def example(input: ToPath) {
#       let path = input.to_path
#     }
#
# This method accepts any type that can be converted to a `Path`. This approach
# comes with a drawback: `ToPath` always returns a new `Path`, even if the input
# already is a `Path`. This can be avoided by using `IntoPath` instead:
#
#     import std::fs::path::IntoPath
#
#     def example(input: IntoPath) {
#       let path = input.into_path
#     }
#
# The `IntoPath` trait moves the type its used on, so no extra allocations are
# necessary if the input already is a `Path`. This allows use of our `example`
# method like so:
#
#     example('foo')
#     example(Path.new('foo'))
#
# If the input `Path` is reused, one can clone it before passing it to the
# `IntoPath` argument:
#
#     let path = Path.new('foo')
#
#     example(path.clone)
#     example(path.to_path)
#
# In general, it's best to use `IntoPath` for arguments instead of `ToPath`.
import std::clone::Clone
import std::conversion::ToString
import std::fs::path::bits::(self, SEPARATOR as _SEPARATOR)
import std::io::(Error, Size)
import std::operators::Equal
import std::os
import std::process::(blocking)
import std::string_buffer::StringBuffer
import std::time::DateTime

extern def file_size(path: ref String) !! Int -> Int
extern def path_created_at(path: ref String) !! Int -> Int
extern def path_modified_at(path: ref String) !! Int -> Int
extern def path_accessed_at(path: ref String) !! Int -> Int
extern def path_is_file(path: ref String) -> Boolean
extern def path_is_directory(path: ref String) -> Boolean
extern def path_exists(path: ref String) -> Boolean
extern def time_offset -> Int

# The primary separator of path components.
let SEPARATOR = _SEPARATOR

# A path to a file or directory.
#
# A `Path` can be used to retrieve information about a path to a file or
# directory such as the size or file type. `Path` objects can be created by
# either using `Path.new` or by sending `to_path` to a `String`.
#
# # Examples
#
# Creating a new `Path` using a `String`:
#
#     import std::fs::path::Path
#
#     Path.new('/tmp/hello.txt')
#
# Converting a `String` to a `Path`:
#
#     import std::fs::path::Path
#
#     '/tmp/hello.txt'.to_path
class Path {
  # The raw file path.
  @path: String

  static def new(path: String) -> Self {
    Self { @path = path }
  }

  # Returns `True` if the path points to a file.
  def file? -> Boolean {
    blocking { path_is_file(@path) }
  }

  # Returns `True` if the path points to a directory.
  def directory? -> Boolean {
    blocking { path_is_directory(@path) }
  }

  # Returns `True` if the path points to an existing file or directory.
  def exists? -> Boolean {
    blocking { path_exists(@path) }
  }

  # Returns the creation time of `self`.
  #
  # # Examples
  #
  # Obtaining the creation time of a `Path`:
  #
  #     import std::fs::path::Path
  #
  #     let path = Path.new('README.md')
  #
  #     try! path.created_at # => DateTime { ... }
  def created_at !! Error -> DateTime {
    let time = try blocking {
      try path_created_at(@path) else (err) throw Error.new(err)
    }

    DateTime.from_timestamp(time: time, utc_offset: time_offset)
  }

  # Returns the modification time of `self`.
  #
  # # Examples
  #
  # Obtaining the modification time of a `Path`:
  #
  #     import std::fs::path::Path
  #
  #     let path = Path.new('README.md')
  #
  #     try! path.modified_at # => DateTime { ... }
  def modified_at !! Error -> DateTime {
    let time = try blocking {
      try path_modified_at(@path) else (err) throw Error.new(err)
    }

    DateTime.from_timestamp(time: time, utc_offset: time_offset)
  }

  # Returns the access time of `self`.
  #
  # # Examples
  #
  # Obtaining the access time of a `Path`:
  #
  #     import std::fs::path::Path
  #
  #     let path = Path.new('README.md')
  #
  #     try! path.accessed_at # => DateTime { ... }
  def accessed_at !! Error -> DateTime {
    let time = try blocking {
      try path_accessed_at(@path) else (err) throw Error.new(err)
    }

    DateTime.from_timestamp(time: time, utc_offset: time_offset)
  }

  # Returns `True` if this `Path` is an absolute path.
  #
  # # Examples
  #
  # Checking if a `Path` is absolute:
  #
  #     import std::fs::path::Path
  #
  #     Path.new('foo').absolute?  # => False
  #     Path.new('/foo').absolute? # => True
  def absolute? -> Boolean {
    bits.absolute?(@path.clone)
  }

  # Returns `True` if this `Path` is a relative path.
  #
  # # Examples
  #
  # Checking if a `Path` is relative:
  #
  #     import std::fs::path::Path
  #
  #     Path.new('foo').relative?  # => True
  #     Path.new('../').relative?  # => True
  #     Path.new('/foo').relative? # => False
  def relative? -> Boolean {
    absolute?.false?
  }

  # Joins `self` and the given path together to form a new `Path`.
  #
  # # Examples
  #
  # Joining a `Path` with a `String`:
  #
  #     import std::fs::path::Path
  #
  #     Path.new('foo/bar').join('baz').to_string # => 'foo/bar/baz'
  #
  # Joining a `Path` with another `Path`:
  #
  #     import std::fs::path::Path
  #
  #     Path.new('foo/bar').join(Path.new('bar')).to_string # => 'foo/bar/baz'
  def join(path: ref ToString) -> Path {
    let path_str = path.to_string
    let new_path = if bits.absolute?(path_str) {
      path_str
    } else if @path.ends_with?(SEPARATOR) {
      `{@path}{path_str}`
    } else {
      `{@path}{SEPARATOR}{path_str}`
    }

    Path.new(new_path)
  }

  # Returns a `Path` to the directory of the current `Path`.
  #
  # This method does not touch the filesystem, and thus does not resolve paths
  # like `..` and symbolic links to their real paths.
  #
  # # Examples
  #
  # Obtaining the directory of a path:
  #
  #     import std::fs::path::Path
  #
  #     Path.new('/foo/bar').directory # => Path.new('/foo')
  #
  # Obtaining the directory of the root directory:
  #
  #     import std::fs::path::Path
  #
  #     Path.new('/').directory # Path.new('/')
  def directory -> Path {
    let length = bits.bytes_before_last_separator(@path.clone)

    if length.negative? { return Path.new('.') }

    Path.new(@path.slice_bytes(start: 0, length: length).drain_to_string)
  }
}

impl Equal for Path {
  # Returns `True` if `self` is equal to the given `Path`.
  #
  # # Examples
  #
  # Comparing two paths:
  #
  #     import std::fs::path::Path
  #
  #     let path1 = Path.new('foo')
  #     let path2 = Path.new('foo')
  #
  #     path1 == path2 # => True
  def ==(other: ref Self) -> Boolean {
    to_string == other.to_string
  }
}

impl ToString for Path {
  # Converts a `Path` to a `String`.
  #
  # # Examples
  #
  # Converting a `Path`:
  #
  #     import std::fs::path::Path
  #
  #     let path = Path.new('/dev/null')
  #
  #     path.to_string # => '/dev/null'
  def to_string -> String {
    @path.clone
  }
}

impl Size for Path {
  # Returns the size of the path in bytes.
  #
  # # Examples
  #
  # Getting the size of a path:
  #
  #     import std::fs::path::Path
  #
  #     let path = Path.new('/dev/null')
  #
  #     try! path.size # => 0
  def size !! Error -> Int {
    try blocking {
      try file_size(@path) else (err) throw Error.new(err)
    }
  }
}

impl Clone for Path {
  def clone -> Self {
    Path.new(@path.clone)
  }
}

# Trait for converting an object to a `Path`.
trait ToPath {
  # Converts `Self` to a `Path`.
  def to_path -> Path
}

impl ToPath for Path {
  def to_path -> Path {
    clone
  }
}

impl ToPath for String {
  def to_path -> Path {
    Path.new(self.clone)
  }
}

# A type that can be moved into a `Path`.
trait IntoPath {
  move def into_path -> Path
}

impl IntoPath for Path {
  move def into_path -> Path {
    self
  }
}

impl IntoPath for String {
  move def into_path -> Path {
    Path.new(self)
  }
}
