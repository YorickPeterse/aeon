# Unit testing of Inko source code
#
# This module provides simple unit testing facilities. Each test is run in a
# separate process, with an upper limit on the number of tests that are run
# concurrently.
#
# # Writing unit tests
#
# Here's how to write a simple unit test:
#
#     import std::test::*
#
#     def tests(t: ref Tests) {
#       t.group('The description of a test group') do (g) {
#         g.test('The description of a test') {
#           try assert_equal(10, 10)
#         }
#       }
#     }
#
# The `tests` method is used for registering tests. This method is called
# automatically when running the `inko test` command. Creating a test file
# without a `tests` method results in a compiler error when running `inko test`.
#
# The `t` argument is of type `ref Tests`, which is used for configuring the
# test runner and registering test groups and tests.
#
# Assertion methods are imported from `std::test`, and require the use of `try`.
#
# # Unit test files
#
# Unit test files must be prefixed with `test_` and use the extension `.inko`.
# The root directory of your unit tests can be called whatever you like, but the
# convention is to call it "tests". This directory must contain a "test"
# directory, which in turn contains all your unit tests. The "test" directory
# can also contain subdirectories.
#
# Here's an example of what a tests directory may look like:
#
#     tests
#     └── test
#         └── std
#             ├── fs
#             │   ├── path
#             │   │   └── test_bits.inko
#             │   ├── test_bits.inko
#             │   ├── test_dir.inko
#             │   ├── test_file.inko
#             │   └── test_path.inko
#             ├── net
#             │   ├── test_ip.inko
#             │   ├── test_socket.inko
#             │   └── test_unix.inko
#             └── test
#                 ├── test_assert.inko
#                 ├── test_config.inko
#                 ├── test_error.inko
#                 ├── test_formatters.inko
#                 ├── test_runner.inko
#                 ├── test_test_group.inko
#                 └── test_test.inko
#
# The root namespace of all unit tests is `test`.
#
# # Configuration
#
# To configure unit tests, create a module called "config.inko" in the "test"
# directory, without the "test_" prefix. This module is imported before all unit
# tests have been registered.
#
# Using this module, you can configure tests like so:
#
#     import std::test::Tests
#
#     def setup(t: ref Tests) {
#       t.concurrency = 16
#     }
import std::debug
import std::env
import std::mirror::(ObjectMirror)
import std::operators::(Equal, Greater)
import std::os::Command
import std::process
import std::test::test::(
  DEFAULT_CONCURRENCY, Failure, Formatter, Group, ProgressFormatter, Test,
  TestResult, failure_location, inspect
)
import std::time::Instant
import std::vm

# A type used for registering and running unit tests.
class Tests {
  # The number of tests to run concurrently.
  @concurrency: Int

  # The formatter to use for displaying test results.
  @formatter: Formatter

  # If the current program should exit when there are test failures.
  @exit_on_failure: Boolean

  # All unit tests to run.
  @tests: Array!(Test)

  static def new -> Self {
    Self {
      @concurrency = DEFAULT_CONCURRENCY,
      @formatter = ProgressFormatter.new(colors: True),
      @tests = Array.new,
      @exit_on_failure = True
    }
  }

  # Returns the number of tests to run concurrently.
  def concurrency -> Int {
    @concurrency.clone
  }

  # Sets the number of tests to run concurrently.
  def concurrency=(value: Int) {
    @concurrency = value
  }

  # Returns the `Formatter` to use for displaying test results.
  def formatter -> ref Formatter {
    @formatter
  }

  # Sets the `Formatter` to use for displaying test results.
  def formatter=(value: Formatter) {
    @formatter = value
  }

  # Sets whether the program should exit when there are test failures.
  def exit_on_failure=(value: Boolean) {
    @exit_on_failure = value
  }

  # Returns whether the program should exit when there are test failures.
  def exit_on_failure? -> Boolean {
    @exit_on_failure.clone
  }

  # Adds a new group of unit tests.
  def group(description: String, body: do (Group)) {
    body.call(Group.new(description, @tests))
  }

  # Runs all the tests.
  move def run {
    let start_time = Instant.now
    let failures = Array.new

    for tests in @tests.into_iter.chunks(concurrency) {
      let mut pending = tests.length

      for test in tests.into_iter { test.schedule }

      while pending > 0 {
        match let result = process.receive {
          as TestResult when result.failure.none? -> {
            @formatter.passed(result)
          }
          as TestResult when result.failure.some? -> {
            @formatter.failed(result)
            failures.push(result)
          }
          else -> {}
        }

        pending -= 1
      }
    }

    let failed = failures.length.positive?

    if failed { @formatter.failures(failures) }

    @formatter.finished(start_time.elapsed)

    if failed and @exit_on_failure { vm.exit(1) }
  }
}

# Asserts that the given arguments are equal to each other.
def assert_equal!(T: Equal)(given: ref T, expected: ref T) !! Failure {
  if given == expected { return }

  let error = `Expected {inspect(given)} to equal {inspect(expected)}`

  throw Failure.new(error, failure_location)
}

# Asserts that the given arguments are not equal to each other.
def assert_not_equal!(T: Equal)(given: ref T, expected: ref T) !! Failure {
  if given != expected { return }

  let error = `Expected {inspect(given)} not to equal {inspect(expected)}`

  throw Failure.new(error, failure_location)
}

# Asserts that the given arguments are the exact same objects.
def assert_same_object!(T: Object)(given: ref T, expected: ref T) !! Failure {
  if given.same_object?(expected) { return }

  let error = `Expected {inspect(given)} to be the exact same \
    object as {inspect(expected)}`

  throw Failure.new(error, failure_location)
}

# Asserts that the first argument is greater than the second argument.
def assert_greater!(T: Greater)(given: ref T, minimum: ref T) !! Failure {
  if given > minimum { return }

  let error = `Expected {inspect(given)} to be greater than {inspect(minimum)}`

  throw Failure.new(error, failure_location)
}

# Asserts that the given value is something that evaluates to be truthy.
def assert_true(value: ref Object) !! Failure {
  if value { return }

  throw Failure.new(`Expected {inspect(value)} to be truthy`, failure_location)
}

# Asserts that the given value is something that evaluates to be falsy.
def assert_false(value: ref Object) !! Failure {
  if not value { return }

  throw Failure.new(`Expected {inspect(value)} to be falsy`, failure_location)
}

# Asserts that the given Inko code produces a panic.
#
# This method takes a String and runs it in a separate OS process.
def assert_panic(program: String) !! Failure {
  let exe = try! env.executable
  let cmd = Command
    .new(exe)
    .argument('run')
    .argument('-e')
    .argument(program)
    .ignore_stdin
    .ignore_stdout
    .pipe_stderr

  let child = try! cmd.spawn

  try! child.wait

  let err = try! child.stderr.read_string

  if err.starts_with?('Stack trace') { return }

  throw Failure.new(`The program didn't panic: {err}`, failure_location)
}

# Asserts that the given closure throws a value.
def assert_throw!(E)(block: move do !! E) !! Failure {
  try block.call else return

  throw Failure.new("This block is expected to throw", failure_location)
}

# Asserts that the given closure doesn't throw a value.
def assert_no_throw!(E)(block: move do !! E) !! Failure {
  try block.call else {
    throw Failure.new(
      "This block isn't expected to throw",
      try! debug.stacktrace(skip: 3, limit: 0).pop.get
    )
  }
}

# Asserts that an object is an instance of another object.
def assert_instance_of(given: ref Any, expected: ref Any) !! Failure {
  let giv_mirror = ObjectMirror.new(given)

  if giv_mirror.instance_of?(expected) { return }

  let exp_mirror = ObjectMirror.new(expected)

  throw Failure.new(
    `Expected {giv_mirror.name} to be an instance of {exp_mirror.name}`,
    failure_location
  )
}
