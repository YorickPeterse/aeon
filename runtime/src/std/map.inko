# A hash map using linear probing and Robin Hood bucket stealing.
import std::hash::(Hash, Hasher)
import std::index::(Index, SetIndex)
import std::length::Length
import std::loop::(repeat)
import std::operators::Equal
import std::option::Option
import std::process::(panic)
import std::random::(incremental_integer)
import std::pair::(Pair as RegularPair)

# The load factor of a `Map` before it should be resized.
let LOAD_FACTOR = 0.75

# A key-value pair with a pre-computed hash.
class Pair!(K: Hash + Equal, V) {
  # The key that was hashed.
  @key: K

  # The value of the key.
  @value: V

  # The hash value of the key.
  @hash: Int

  # The distance of this pair relative to its desired index.
  @distance: Int

  static def new!(KK: Hash + Equal, VV)(
    key: KK,
    value: VV,
    hash: Int
  ) -> Pair!(KK, VV) {
    Self {
      @key = key,
      @value = value,
      @hash = hash,
      @distance = 0
    }
  }

  def distance -> Int {
    @distance.clone
  }

  def rehash? -> Boolean {
    @distance == -1
  }

  def prepare_for_rehash {
    @distance = -1
  }

  def reset_distance {
    @distance = 0
  }

  def increase_distance {
    @distance += 1
  }

  def reduce_distance {
    @distance -= 1
  }

  def replace_with?(other: ref Self) -> Boolean {
    distance < other.distance
  }

  def same_key?(key: ref K) -> Boolean {
    @key == key
  }

  def key -> ref K {
    @key
  }

  def value -> ref V {
    @value
  }

  def hash -> Int {
    @hash.clone
  }

  def hash=(hash: Int) {
    @hash = hash
  }
}

impl Equal for Pair {}

# An unordered hash map using linear probing and Robin Hood bucket stealing.
#
# The keys in a `Map` can be any object that implements the `Hash` and `Equal`
# traits. The values can be of any type, as long as all values are of the same
# type.
#
# A `Map` is unordered, meaning that keys can be returned in a (seemingly)
# random order.
#
# `Map` uses linear probing for finding values and Robin Hood hashing.
# Removals are performed using backwards shift deletion. For more information
# on these algorithms you can refer to the following resources:
#
# * http://codecapsule.com/2013/11/11/robin-hood-hashing/
# * http://codecapsule.com/2013/11/17/robin-hood-hashing-backward-shift-deletion/
# * https://www.sebastiansylvan.com/post/robin-hood-hashing-should-be-your-default-hash-table-implementation/
class Map!(K: Hash + Equal, V) {
  # The hasher to use.
  @hasher: Hasher

  # The buckets to store pairs in. Each bucket can only contain a single
  # pair.
  #
  # The size of this Array is always a power of 2.
  @buckets: Array!(?Pair!(K, V))

  # The number of key-value pairs stored in this `Map`.
  @length: Int

  # The number of values to store before a resize is necessary. We store this
  # value explicitly so we don't have to allocate floats every time we want to
  # check if we need to resize.
  @resize_threshold: Int

  # Returns a new empty Map.
  #
  # # Examples
  #
  # Creating a new Map:
  #
  #     Map.new
  static def new -> Self {
    Self {
      @hasher = Hasher.default,
      @buckets = Array.new(Option.none, Option.none),
      @length = 0,
      @resize_threshold = 2
    }
  }

  # Returns a `Map` using two arrays: one containing the keys and one
  # containing the values.
  #
  # # Examples
  #
  # Creating a `Map` from two arrays:
  #
  #     Map.from_array(Array.new('name'), Array.new('Alice'))
  static def from_array!(K: Hash + Equal, V)(
    keys: Array!(K),
    values: Array!(V)
  ) -> Map!(K, V) {
    let mut map = Map.new
    let max_index = values.length - 1

    if keys.length != values.length {
      panic('An equal number of keys and values must be specified')
    }

    for (index, key) in keys.iter.with_index {
      if index > max_index { return map }

      map[key] = values[index]
    }

    map
  }

  # Returns the buckets of this `Map`.
  def buckets -> ref Array!(?Pair!(K, V)) {
    @buckets
  }

  # Removes the given key, returning its value if the key was present in the
  # map.
  #
  # # Examples
  #
  # Removing a non-existing key:
  #
  #     let mut map = Map.new
  #
  #     map.remove('name') # => Option.none
  #
  # Removing an existing key:
  #
  #     let mut map = Map.new
  #
  #     map['name'] = 'Alice'
  #
  #     map.remove('name') # => Option.some('Alice')
  def remove(key: ref K) -> ?V {
    bucket_index(key).map do (index) {
      let pair = try! @buckets.swap(index, Option.none).get

      @length -= 1

      backwards_shift(index + 1)
      pair.value
    }
  }

  # Returns an `Iterator` that iterates over all key-value pairs in this
  # `Map`.
  #
  # # Examples
  #
  # Iterating over all the key-value pairs:
  #
  #     let mut map = Map.new
  #
  #     map['name'] = 'Alice'
  #
  #     for (key, value) in map.iter {
  #       key   # => 'name'
  #       value # => 'Alice'
  #     }
  def iter => ref RegularPair!(K, V) {
    for bucket in @buckets {
      if not bucket { next }

      let pair = try! bucket.get_ref

      yield RegularPair.new(pair.key, pair.value)
    }
  }

  # Returns an `Iterator` that iterates over all key-value pairs in this
  # `Map`, yielding them by value.
  #
  # # Examples
  #
  #     let mut map = Map.new
  #
  #     map['name'] = 'Alice'
  #
  #     for (key, value) in map.into_iter {
  #       key   # => 'name'
  #       value # => 'Alice'
  #     }
  move def into_iter => RegularPair!(K, V) {
    for bucket in @buckets.into_iter {
      if not bucket { next }

      let pair = try! bucket.get

      yield RegularPair.new(pair.key, pair.value)
    }
  }

  # Returns an `Iterator` visiting all the keys in this `Map`.
  #
  # # Examples
  #
  # Iterating over the keys in a `Map`:
  #
  #     let mut map = Map.new
  #
  #     map['name'] = 'Alice'
  #
  #     for key in map.keys {
  #       key # => 'name'
  #     }
  def keys => ref K {
    for (key, _) in self { yield key }
  }

  # Returns an `Iterator` visiting all the values in this `Map`.
  #
  # # Examples
  #
  # Iterating over the values in a `Map`:
  #
  #     let mut map = Map.new
  #
  #     map['name'] = 'Alice'
  #
  #     for value in map.values {
  #       value # => 'Alice'
  #     }
  def values => ref V {
    for (_, value) in self { yield value }
  }

  # Returns `True` if `self` contains the key `key`.
  #
  # # Examples
  #
  # Checking if a `Map` defines a key:
  #
  #     let map = Map.new
  #
  #     map['name'] = 'Alice'
  #
  #     map.key?('name') # => True
  #     map.key?('city') # => False
  def key?(key: ref K) -> Boolean {
    bucket_index(key).some?
  }

  # Resizes and rehashes the buckets.
  def rehash {
    for bucket in @buckets {
      (try bucket.get_ref else next).prepare_for_rehash
    }

    # This doubles the size of the Array, filling new slots with empty buckets.
    repeat(@buckets.length) do (_) { @buckets.push(Option.none) }

    @resize_threshold = (LOAD_FACTOR * @buckets.length.to_float).to_int

    for (index, bucket) in @buckets.iter.with_index {
      let pair = try bucket.get_ref else next

      # It's possible that a previous rehash already moved our pair to its
      # desired bucket. In that case we just leave it as-is.
      if not pair.rehash? { next }

      rehash_pair(try! @buckets.swap(index, Option.none).get)
    }
  }

  # Rehashes an existing pair into the list of buckets.
  def rehash_pair(pair: Pair!(K, V)) {
    let mut hash = pair.hash
    let mut insert = pair

    insert.reset_distance

    loop {
      let index = desired_bucket(hash)
      let existing = try @buckets[index].get_ref else {
        @buckets[index] = Option.some(insert)
        return
      }

      if existing.replace_with?(insert) {
        insert = try! @buckets.swap(index, Option.some(insert)).get
      }

      hash += 1
      insert.increase_distance
    }
  }

  # Hashes the supplied key using the internal hasher of this `Map`.
  def hash_key(key: ref K) -> Int {
    key.hash(@hasher)
    @hasher.to_hash
  }

  # Inserts a new pair into `self`.
  #
  # The `Pair` to insert must be pre-hashed using the `Hasher` used internally
  # by this `Map`, otherwise it might not be retrieved later.
  def insert_pair(pair: Pair!(K, V)) {
    let mut hash = pair.hash
    let mut insert = pair

    loop {
      let index = desired_bucket(hash)
      let existing = try @buckets[index].get_ref else {
        @length += 1
        @buckets[index] = Option.some(insert)
        return
      }

      if existing.same_key?(insert.key) {
        @buckets[index] = Option.some(insert)
        return
      }

      if existing.replace_with?(insert) {
        insert = try! @buckets.swap(index, Option.some(insert)).get
      }

      hash += 1
      insert.increase_distance
    }
  }

  # Returns the desired bucket index for the given hash.
  def desired_bucket(hash: Int) -> Int {
    hash % @buckets.length
  }

  # Returns the index of the bucket the key resides in.
  def bucket_index(key: ref K) -> ?Int {
    let mut hash = hash_key(key)
    let mut attempts = @buckets.length

    while attempts.positive? {
      let index = desired_bucket(hash)
      let pair = try @buckets[index].get_ref else { return Option.none }

      if pair.same_key?(key) { return Option.some(index) }

      hash += 1
      attempts -= 1
    }

    # All buckets are used, but none of them use the provided key.
    Option.none
  }

  # Shifts all pairs to the left starting at the given bucket index.
  def backwards_shift(start_at: Int) {
    let mut index = start_at
    let max = @buckets.length

    while index < max {
      let pair = try @buckets[index].get_ref else { return }

      if pair.distance.zero? { return }

      let old_pair = @buckets.swap(index, Option.none)

      try! { old_pair.get_ref }.reduce_distance

      @buckets[index - 1] = old_pair
      index += 1
    }
  }

  # Returns the value for the given key.
  #
  # # Examples
  #
  # Getting the value of a non-existing key:
  #
  #     let map = Map.new
  #
  #     map.get('name') # => Option.none
  #
  # Getting the value of an existing key:
  #
  #     let mut map = Map.new
  #
  #     map['name'] = 'Alice'
  #
  #     map.get('name') # => Option.some('Alice')
  def get(key: ref K) -> ?ref V {
    bucket_index(key).then do (index) {
      @buckets[index].as_ref.map do (pair) { pair.value }
    }
  }

  # Merges two `Map` objects together.
  #
  # # Examples
  #
  #     let map1 = Map.new
  #     let map2 = Map.new
  #
  #     map1['name'] = 'Alice'
  #     map2['city'] = 'Amsterdam'
  #
  #     map1.merge(map2)
  #
  #     map1['name'] # => 'Alice'
  #     map2['city'] # => 'Amsterdam'
  def merge(other: Self) {
    for (key, value) in other.into_iter { self[key] = value }
  }
}

impl Equal for Map {
  # Returns `True` if `self` and the given `Map` are identical to each
  # other.
  #
  # # Examples
  #
  # Comparing two `Map` instances:
  #
  #     let map1 = Map.new
  #     let map2 = Map.new
  #
  #     map1['name'] = 'Alice'
  #     map2['name'] = 'Alice'
  #
  #     map1 == map2 # => True
  def ==(other: ref Self) -> Boolean when V: Equal {
    if length != other.length { return False }

    for (key, value) in self {
      if not other.key?(key) or value != other[key] { return False }
    }

    True
  }
}

impl Index!(K, ref V) for Map {
  # Returns the value for the given key
  #
  # # Examples
  #
  # Getting the value of an existing key:
  #
  #     let mut map = Map.new
  #
  #     map['name'] = 'Alice'
  #
  #     map['name'] # => 'Alice'
  #
  # # Panics
  #
  # This method panics if the key doesn't exist.
  def [](key: ref K) -> ref V {
    try get(key).get else { panic("The key doesn't exist") }
  }
}

impl SetIndex!(K, V) for Map {
  # Inserts the key and value in this `Map`, returning the inserted value.
  #
  # # Examples
  #
  # Inserting a new key-value pair:
  #
  #     let mut map = Map.new
  #
  #     map['name'] = 'Alice' # => 'Alice'
  def []=(key: K, value: V) {
    if @length >= @resize_threshold { rehash }

    let hash = hash_key(key)

    insert_pair(Pair.new(key: key, value: value, hash: hash))
  }
}

impl Length for Map {
  # Returns the number of key-value pairs in this map.
  #
  # # Examples
  #
  # Using an empty map:
  #
  #     let map = Map.new
  #
  #     map.length # => 0
  #
  # Using a map with one key-value pair:
  #
  #     let map = Map.new
  #
  #     map['name'] = 'Alice'
  #
  #     map.length # => 1
  def length -> Int {
    @length.clone
  }
}

impl Hash for Map {}
