# Optional values that can be nested.
#
# Optional values are used whenever a value may be present or not. For example,
# we may want to retrieve a value from an `Array` using an index that may be out
# of bounds, without triggering a panic.
#
# Optional values differ from nullable/nilable types in that they can be nested.
# That is, `Option!(Option!(T))` and `Option!(T)` are two different types, but
# `T | null` and `T | null | null` are the same.
#
# Imagine for a moment we have a `find()` method that finds a value in an
# `Array`. If the value is not present, nil is returned. Thus the return type is
# `?T`:
#
#     def find!(T)(values: Array!(T), value: T) -> ?T {
#       # ...
#     }
#
# Now let's say we use it like this:
#
#     def example(values: Array!(?Int)) {
#       let nil = find(values: values, value: Nil)
#     }
#
# If `nil` is assigned to `Nil`, how do we know that is because the value is
# present, versus the value not being present? Working around this usually
# requires that we use a different approach, such as finding the index of a
# value. The problem with this is that this isn't always clear to the developer,
# and can lead to unexpected and difficult to debug bugs.
#
# When using an Option, this is not a problem:
#
#     def find!(T)(values: Array!(T), value: T) -> Option!(T) {
#       # ...
#     }
#
#     def example(values: Array!(Option!(Int))) {
#       let none = find(values: values, value: Option.none)
#     }
#
# Here `none` is of type `Option!(Option!(Int))`. If a `None` isn't present,
# we'll be given a `None`. But if a `None` is present, we'd instead be given a
# `Some(None)`.
#
# While nesting `Option` types isn't something you'd make use of yourself
# directly, it makes it easier to implement iterators and collections; or really
# any kind of data type that may operate on optional data.
import std::clone::Clone
import std::operators::Equal

# A generic optional value.
#
# An Option can wrap a value, in which case we call it a Some. An Option that
# doesn't contain a value is called a None.
class Option!(T) {
  # The wrapped value.
  #
  # For a None, this is a special value that signals we're dealing with a None
  # and not a Some value.
  @value: T

  # Returns an Option wrapping the given value.
  #
  # # Examples
  #
  # Wrapping an `Int`:
  #
  #     Option.some(10) # => Option.some(10)
  static def some!(T)(value: T) -> ?T {
    Self { @value = value }
  }

  # Returns a None.
  #
  # A None signals the lack of a value.
  #
  # # Examples
  #
  # Obtaining a None:
  #
  #     Option.none
  static def none -> ?T {
    Self { @value = _INKOC.get_null as T }
  }

  # Calls the supplied block if `self` if a Some, passing a reference to the
  # wrapped value to the block.
  #
  # Using this method you can easily act upon a Some (without consuming it),
  # instead of having to write something like this:
  #
  #     if some_option.some? {
  #       try! { some_option.value_as_ref.get }.foo
  #     }
  #
  # Instead, you'd write:
  #
  #     some_option.let do (value) { value.foo }
  #
  # # Examples
  #
  #     Option.some(10).let do (num) {
  #       num # => ref 10
  #     }
  def let(block: move do (ref T)) {
    if some? { block.call(@value) }
  }

  # Returns a new `Option` that wraps a reference to the current option's value.
  #
  # # Examples
  #
  #     Option.some(10).as_ref # => Option.some(ref 10)
  #     Option.none.as_ref     # => Option.none
  def as_ref -> ?ref T {
    if some? { Option.some(@value) } else { Option.none }
  }

  # Returns the wrapped value.
  #
  # This method throws when used on a `None` value.
  #
  # # Examples
  #
  # Getting the value of a Some:
  #
  #     try! Option.some(10).get # => 10
  move def get !! String -> T {
    if some? { return @value }

    throw "Option.get can't be used on a None value"
  }

  # Returns a reference to the wrapped value.
  #
  # This method throws when used on a `None` value.
  #
  # # Examples
  #
  #     try! Option.some(10).get_ref # => ref 10
  def get_ref !! String -> ref T {
    if some? { return @value }

    throw "Option.get_ref can't be used on a None value"
  }

  # Maps an `Option!(T)` to an `Option!(U)` by wrapping the value returned by
  # the provided closure.
  #
  # The closure is to return a value to be wrapped in a Some. If used on a
  # `None`, `None` itself is returned.
  #
  # # Examples
  #
  # Mapping an Option to a new Option:
  #
  #     Option.some(10).map do (num) { num * 2 } # => Option.some(20)
  #
  # Mapping a None:
  #
  #     let option: Option!(Int) = Option.none
  #
  #     option.map do (x) { x * 2 } # => Option.none
  move def map!(R)(block: move do (T) -> R) -> ?R {
    if some? { Option.some(block.call(@value)) } else { Option.none }
  }

  # Maps an `Option!(T)` to an `Option!(U)` using the `Option` returned by the
  # provided closure.
  #
  # The closure is to return a new `Option`. If used on a `None`, `None` itself
  # is returned.
  #
  # This process is sometimes referred to as a "flat map". Inko uses the name
  # "then" because this reads more nicely when chaining multiple instances of
  # this method together.
  move def then!(R)(block: move do (T) -> ?R) -> ?R {
    if some? { block.call(@value) } else { Option.none }
  }

  # Calls the supplied block if `self` is a None, returning the Option provided
  # by the `block` argument.
  #
  # If `self` is a Some, the Some itself is returned.
  move def else(block: move do -> ?T) -> ?T {
    if some? { self } else { block.call }
  }

  # Returns `True` if `self` is a Some value.
  def truthy? -> Boolean {
    some?
  }

  # Returns `True` for a Some, `False` otherwise.
  #
  # # Examples
  #
  #     Option.some(10).some? # => True
  #     Option.none.some?     # => False
  def some? -> Boolean {
    _INKOC.object_equals(none?, False)
  }

  # Returns `True` for a `None`, `False` otherwise.
  #
  # # Examples
  #
  #     Option.some(10).none? # => False
  #     Option.none.none?     # => True
  def none? -> Boolean {
    _INKOC.object_equals(@value, _INKOC.get_null)
  }
}

impl Equal for Option {
  # Returns `True` if `self` and the given `Option` are equal.
  #
  # Two options are considered equal to each other if:
  #
  # 1. They are both None
  # 2. They are both some, and the wrapped values are equal to each other
  #
  # # Examples
  #
  # Comparing two Some values:
  #
  #     Option.some(10) == Option.some(10) # => True
  #     Option.some(10) == Option.some(20) # => False
  #
  # Comparing a Some and a None:
  #
  #     Option.some(10) == Option.none # => False
  #
  # Comparing two None values:
  #
  #     Option.none == Option.none # => True
  def ==(other: ref Self) -> Boolean when T: Equal {
    if some? and other.some? { return @value == try! other.get_ref }
    if none? and other.none? { return True }

    False
  }
}

impl Clone for Option {
  def clone -> Self when T: Clone {
    let value = if some? { @value.clone } else { _INKOC.get_null as T }

    Option { @value = value }
  }
}
