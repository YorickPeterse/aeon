import std::compiler::ast::blocks::*
import std::compiler::ast::body::Body
import std::compiler::ast::control_flow::*
import std::compiler::ast::literals::*
import std::compiler::ast::node::*
import std::compiler::ast::objects::*
import std::compiler::ast::operators::*
import std::compiler::ast::pattern_matching::*
import std::compiler::ast::send::*
import std::compiler::ast::types::(
  ClosureType as ClosureTypeNode, LambdaType as LambdaTypeNode
)
import std::compiler::ast::variables::*
import std::compiler::diagnostics::Diagnostics
import std::compiler::module_name::ModuleName
import std::compiler::module_parser::ParsedModule
import std::compiler::parser::Parser
import std::compiler::source_location::SourceLocation
import std::compiler::symbol_table::SymbolTable
import std::compiler::type_checker::*
import std::compiler::types::*
import std::mirror
import std::process
import std::test::*
import std::test::test::(Failure, failure_location)

def location -> SourceLocation {
  SourceLocation.new(file: 'test.inko', line_range: 1..1, column: 1)
}

def parse(input: String) -> Body {
  try! Parser.new(input: input, file: 'test.inko', parse_comments: False).parse
}

def parse_type(type: String) -> Node {
  let node = parse(`let x: {type} = 10`).children[0] as DefineLocalVariable

  node.value_type.get
}

def new_module(name: String) -> ModuleType {
  ModuleType.new(ModuleName.new(Array.new(name)))
}

def new_std_module(name: String) -> ModuleType {
  ModuleType.new(ModuleName.new(Array.new('std', name)))
}

def new_type_checker -> TypeChecker {
  TypeChecker.new(diagnostics: Diagnostics.new, dependencies: Array.new)
}

def assert_instance_of(type: Type, instance_of: Type) !! Failure {
  try assert_true(mirror.reflect(type).instance_of?(instance_of))
}

def assert_object_instance(type: Type, instance_of: ClassType) !! Failure {
  match let matched = type {
    as ClassInstance when matched.instance_of.same_object?(instance_of) -> {}
    else -> {
      throw Failure.new(
        `Expected {matched.type_name} to be an instance of {instance_of.type_name}`,
        failure_location
      )
    }
  }
}

def assert_trait_instance(type: Type, instance_of: TraitType) !! Failure {
  try assert_instance_of(type, TraitInstance)
  try assert_equal((type as TraitInstance).instance_of, instance_of)
}

def setup_match_types(type_checker: TypeChecker, module: ModuleType) {
  let builtins = type_checker.builtins
  let op_mod = ModuleType.new(OPERATORS_MODULE)

  type_checker.add_module(op_mod)

  op_mod.define_constant(name: 'Boolean', type: builtins.boolean_type)
  module.define_constant(name: 'Boolean', type: builtins.boolean_type)
  module.define_constant(name: 'Int', type: builtins.integer_type)
  module.define_constant(name: 'True', type: builtins.true_singleton)
  module.define_constant(name: 'Nil', type: builtins.nil_singleton)

  type_checker.check_module(
    module: op_mod,
    ast: parse('trait Match!(T) { def =~(other: T) -> Boolean }')
  )

  type_checker.check_module(
    module: module,
    ast: parse(
      '
      import std::operators::Match

      impl Match!(Int) for Int {
        def =~(other: Int) -> Boolean { True }
      }
      '
    )
  )
}

class DummyPass {
  @type_checker: TypeChecker
  @module: ModuleType

  static def new -> Self {
    Self { @type_checker = new_type_checker, @module = new_module('foo') }
  }
}

impl TypePass for DummyPass {
  def type_checker -> TypeChecker {
    @type_checker
  }

  def module -> ModuleType {
    @module
  }
}

def tests(t: Tests) {
  t.group('std::compiler::type_checker::TypePass.visit_constant') do (g) {
    g.test('Resolving a constant that does not exist') {
      let pass = DummyPass.new
      let node = parse_type('Foo') as Constant
      let scope = TypeScope.new(pass.module)
      let type = pass.visit_constant(node: node, types: scope)

      try assert_true(type.error?)
      try assert_true(node.resolved_type.get.error?)
      try assert_true(pass.type_checker.diagnostics.errors?)
    }

    g.test('Resolving a constant that exists') {
      let pass = DummyPass.new
      let foo_type = ClassType.new('Foo')

      pass.module.define_constant(name: foo_type.name, type: foo_type)

      let node = parse_type('Foo') as Constant
      let scope = TypeScope.new(pass.module)
      let type = pass.visit_constant(node: node, types: scope)

      try assert_same_object(type, foo_type)
      try assert_same_object(node.resolved_type.get, type)
      try assert_false(pass.type_checker.diagnostics.errors?)
    }

    g.test('Resolving a non-existing constant with type arguments') {
      let pass = DummyPass.new
      let node = parse_type('Foo!(Bar)') as Constant
      let scope = TypeScope.new(pass.module)
      let type = pass.visit_constant(node: node, types: scope)

      try assert_true(type.error?)
      try assert_true(node.resolved_type.get.error?)
      try assert_true(pass.type_checker.diagnostics.errors?)
    }

    g.test('Resolving an existing regular constant with type arguments') {
      let pass = DummyPass.new
      let foo_type = ClassType.new('Foo')
      let bar_type = ClassType.new('Bar')

      pass.module.define_constant(name: foo_type.name, type: foo_type)
      pass.module.define_constant(name: bar_type.name, type: bar_type)

      let node = parse_type('Foo!(Bar)') as Constant
      let scope = TypeScope.new(pass.module)
      let type = pass.visit_constant(node: node, types: scope)

      try assert_true(type.error?)
      try assert_true(node.resolved_type.get.error?)
      try assert_true(pass.type_checker.diagnostics.errors?)
    }

    g.test('Resolving an existing generic constant with type arguments') {
      let pass = DummyPass.new
      let foo_type = ClassType.new('Foo')
      let bar_type = ClassType.new('Bar')
      let param = TypeParameterType.new('A')

      foo_type.type_parameters.define(name: 'A', type: param)
      pass.module.define_constant(name: foo_type.name, type: foo_type)
      pass.module.define_constant(name: bar_type.name, type: bar_type)

      let node = parse_type('Foo!(Bar)') as Constant
      let scope = TypeScope.new(pass.module)
      let type = pass.visit_constant(node: node, types: scope)

      try assert_instance_of(type, ClassInstance)
      try assert_same_object(node.resolved_type.get, type)
      try assert_false(pass.type_checker.diagnostics.errors?)

      let obj_type = type as ClassInstance

      try assert_same_object(obj_type.instance_of, foo_type)
      try assert_equal(obj_type.type_parameter_types.length, 1)
      try assert_object_instance(obj_type.type_parameter_types[param], bar_type)
    }

    g.test('Resolving an existing generic constant with an incorrect number of type arguments') {
      let pass = DummyPass.new
      let foo_type = ClassType.new('Foo')
      let bar_type = ClassType.new('Bar')

      foo_type.type_parameters.define(name: 'A', type: TypeParameterType.new('A'))
      foo_type.type_parameters.define(name: 'B', type: TypeParameterType.new('B'))

      pass.module.define_constant(name: foo_type.name, type: foo_type)
      pass.module.define_constant(name: bar_type.name, type: bar_type)

      let node = parse_type('Foo!(Bar)') as Constant
      let scope = TypeScope.new(pass.module)
      let type = pass.visit_constant(node: node, types: scope)

      try assert_true(type.error?)
      try assert_true(node.resolved_type.get.error?)
      try assert_true(pass.type_checker.diagnostics.errors?)
    }
  }

  t.group('std::compiler::type_checker::TypePass.visit_constant_as_type') do (g) {
    g.test('Resolving the Never type') {
      let pass = DummyPass.new
      let node = parse_type('Never') as Constant
      let scope = TypeScope.new(pass.module)
      let type = pass.visit_constant_as_type(node: node, types: scope)

      try assert_instance_of(type, NeverType)
      try assert_same_object(node.resolved_type.get, type)
      try assert_false(pass.type_checker.diagnostics.errors?)
    }

    g.test('Resolving the Self type') {
      let pass = DummyPass.new
      let node = parse_type('Self') as Constant
      let scope = TypeScope.new(pass.module)
      let type = pass.visit_constant_as_type(node: node, types: scope)

      try assert_instance_of(type, SelfType)
      try assert_same_object(node.resolved_type.get, type)
      try assert_false(pass.type_checker.diagnostics.errors?)
    }

    g.test('Resolving the Never type with type arguments') {
      let pass = DummyPass.new
      let node = parse_type('Never!(Bar)') as Constant
      let scope = TypeScope.new(pass.module)
      let type = pass.visit_constant_as_type(node: node, types: scope)

      try assert_true(type.error?)
      try assert_true(node.resolved_type.get.error?)
      try assert_true(pass.type_checker.diagnostics.errors?)
    }

    g.test('Resolving an existing generic constant without type arguments') {
      let pass = DummyPass.new
      let foo_type = ClassType.new('Foo')

      foo_type.type_parameters.define(name: 'A', type: TypeParameterType.new('A'))
      pass.module.define_constant(name: foo_type.name, type: foo_type)

      let node = parse_type('Foo') as Constant
      let scope = TypeScope.new(pass.module)
      let type = pass.visit_constant_as_type(node: node, types: scope)

      try assert_true(type.error?)
      try assert_true(node.resolved_type.get.error?)
      try assert_true(pass.type_checker.diagnostics.errors?)
    }
  }

  t.group('std::compiler::type_checker::TypePass.visit_closure_type') do (g) {
    g.test('Defining a simple closure type') {
      let pass = DummyPass.new
      let node = parse_type('do') as ClosureTypeNode
      let scope = TypeScope.new(pass.module)
      let type = pass.visit_closure_type(node: node, types: scope)

      try assert_same_object(node.resolved_type.get, type)
      try assert_true(type.arguments.empty?)
      try assert_true(type.type_parameters.empty?)
      try assert_true(type.throw_type.none?)
      try assert_instance_of(type.return_type, AnyType)
    }

    g.test('Defining a closure type with valid argument types') {
      let foo_type = ClassType.new('Foo')
      let bar_type = ClassType.new('Bar')
      let pass = DummyPass.new

      pass.module.define_constant(name: foo_type.name, type: foo_type)
      pass.module.define_constant(name: bar_type.name, type: bar_type)

      let node = parse_type('do (Foo, Bar)') as ClosureTypeNode
      let scope = TypeScope.new(pass.module)
      let type = pass.visit_closure_type(node: node, types: scope)

      try assert_same_object(node.resolved_type.get, type)
      try assert_equal(type.arguments.length, 2)

      let args = type.arguments.symbols
      let arg0 = args[0]
      let arg1 = args[1]

      try assert_equal(arg0.name, '0')
      try assert_equal(arg1.name, '1')

      try assert_instance_of(arg0.type, ClassInstance)
      try assert_instance_of(arg1.type, ClassInstance)

      try assert_equal((arg0.type as ClassInstance).instance_of.name, 'Foo')
      try assert_equal((arg1.type as ClassInstance).instance_of.name, 'Bar')
    }

    g.test('Defining a closure type with invalid argument types') {
      let pass = DummyPass.new
      let node = parse_type('do (Foo, Bar)') as ClosureTypeNode
      let scope = TypeScope.new(pass.module)
      let type = pass.visit_closure_type(node: node, types: scope)

      try assert_same_object(node.resolved_type.get, type)
      try assert_equal(type.arguments.length, 2)

      let args = type.arguments.symbols
      let arg0 = args[0]
      let arg1 = args[1]

      try assert_equal(arg0.name, '0')
      try assert_equal(arg1.name, '1')

      try assert_true(arg0.type.error?)
      try assert_true(arg1.type.error?)
    }

    g.test('Defining a closure with a valid throw type') {
      let pass = DummyPass.new
      let foo_type = ClassType.new('Foo')

      pass.module.define_constant(name: foo_type.name, type: foo_type)

      let node = parse_type('do !! Foo') as ClosureTypeNode
      let scope = TypeScope.new(pass.module)
      let type = pass.visit_closure_type(node: node, types: scope)
      let throws = type.throw_type.get

      try assert_same_object(node.resolved_type.get, type)
      try assert_instance_of(throws, ClassInstance)
      try assert_same_object((throws as ClassInstance).instance_of, foo_type)
    }

    g.test('Defining a closure with an invalid throw type') {
      let pass = DummyPass.new
      let node = parse_type('do !! Foo') as ClosureTypeNode
      let scope = TypeScope.new(pass.module)
      let type = pass.visit_closure_type(node: node, types: scope)

      try assert_same_object(node.resolved_type.get, type)
      try assert_true(type.throw_type.get.error?)
    }

    g.test('Defining a closure with a valid return type') {
      let pass = DummyPass.new
      let foo_type = ClassType.new('Foo')

      pass.module.define_constant(name: foo_type.name, type: foo_type)

      let node = parse_type('do -> Foo') as ClosureTypeNode
      let scope = TypeScope.new(pass.module)
      let type = pass.visit_closure_type(node: node, types: scope)
      let returns = type.return_type

      try assert_same_object(node.resolved_type.get, type)
      try assert_instance_of(returns, ClassInstance)
      try assert_same_object((returns as ClassInstance).instance_of, foo_type)
    }

    g.test('Defining a closure with an invalid return type') {
      let pass = DummyPass.new
      let node = parse_type('do -> Foo') as ClosureTypeNode
      let scope = TypeScope.new(pass.module)
      let type = pass.visit_closure_type(node: node, types: scope)

      try assert_same_object(node.resolved_type.get, type)
      try assert_true(type.return_type.error?)
    }

    g.test('Defining a closure with type parameters') {
      let pass = DummyPass.new
      let foo_type = TraitType.new('Foo')

      pass.module.define_constant(name: foo_type.name, type: foo_type)

      let node = parse_type('do !(A: Foo, B: Foo)') as ClosureTypeNode
      let scope = TypeScope.new(pass.module)
      let type = pass.visit_closure_type(node: node, types: scope)

      try assert_same_object(node.resolved_type.get, type)

      let params = type.type_parameters.symbols
      let param0 = params[0]
      let param1 = params[1]

      try assert_equal(param0.name, 'A')
      try assert_equal(param1.name, 'B')

      try assert_equal(param0.type.name, 'A')
      try assert_equal(param1.type.name, 'B')

      try assert_equal(param0.type.required_traits[0].instance_of, foo_type)
      try assert_equal(param1.type.required_traits[0].instance_of, foo_type)
    }

    g.test('Defining a closure type with an uninitialised generic argument') {
      let pass = DummyPass.new
      let foo_type = ClassType.new('Foo')

      foo_type.type_parameters.define(name: 'A', type: TypeParameterType.new('A'))

      pass.module.define_constant(name: foo_type.name, type: foo_type)

      let node = parse_type('do (Foo)') as ClosureTypeNode
      let scope = TypeScope.new(pass.module)
      let type = pass.visit_closure_type(node: node, types: scope)

      try assert_same_object(node.resolved_type.get, type)
      try assert_true(type.arguments.symbols[0].type.error?)
    }
  }

  t.group('std::compiler::type_checker::TypePass.visit_lambda_type') do (g) {
    g.test('Defining a simple lambda type') {
      let pass = DummyPass.new
      let node = parse_type('fn') as LambdaTypeNode
      let scope = TypeScope.new(pass.module)
      let type = pass.visit_lambda_type(node: node, types: scope)

      try assert_same_object(node.resolved_type.get, type)
      try assert_true(type.arguments.empty?)
      try assert_true(type.type_parameters.empty?)
      try assert_true(type.throw_type.none?)
      try assert_instance_of(type.return_type, AnyType)
    }

    g.test('Defining a lambda type with valid argument types') {
      let foo_type = ClassType.new('Foo')
      let bar_type = ClassType.new('Bar')
      let pass = DummyPass.new

      pass.module.define_constant(name: foo_type.name, type: foo_type)
      pass.module.define_constant(name: bar_type.name, type: bar_type)

      let node = parse_type('fn (Foo, Bar)') as LambdaTypeNode
      let scope = TypeScope.new(pass.module)
      let type = pass.visit_lambda_type(node: node, types: scope)

      try assert_same_object(node.resolved_type.get, type)
      try assert_equal(type.arguments.length, 2)

      let args = type.arguments.symbols
      let arg0 = args[0]
      let arg1 = args[1]

      try assert_equal(arg0.name, '0')
      try assert_equal(arg1.name, '1')

      try assert_instance_of(arg0.type, ClassInstance)
      try assert_instance_of(arg1.type, ClassInstance)

      try assert_equal((arg0.type as ClassInstance).instance_of.name, 'Foo')
      try assert_equal((arg1.type as ClassInstance).instance_of.name, 'Bar')
    }

    g.test('Defining a lambda type with invalid argument types') {
      let pass = DummyPass.new
      let node = parse_type('fn (Foo, Bar)') as LambdaTypeNode
      let scope = TypeScope.new(pass.module)
      let type = pass.visit_lambda_type(node: node, types: scope)

      try assert_same_object(node.resolved_type.get, type)
      try assert_equal(type.arguments.length, 2)

      let args = type.arguments.symbols
      let arg0 = args[0]
      let arg1 = args[1]

      try assert_equal(arg0.name, '0')
      try assert_equal(arg1.name, '1')

      try assert_true(arg0.type.error?)
      try assert_true(arg1.type.error?)
    }

    g.test('Defining a lambda with a valid throw type') {
      let pass = DummyPass.new
      let foo_type = ClassType.new('Foo')

      pass.module.define_constant(name: foo_type.name, type: foo_type)

      let node = parse_type('fn !! Foo') as LambdaTypeNode
      let scope = TypeScope.new(pass.module)
      let type = pass.visit_lambda_type(node: node, types: scope)

      try assert_same_object(node.resolved_type.get, type)

      let throws = type.throw_type.get

      try assert_instance_of(throws, ClassInstance)
      try assert_same_object((throws as ClassInstance).instance_of, foo_type)
    }

    g.test('Defining a lambda with an invalid throw type') {
      let pass = DummyPass.new
      let node = parse_type('fn !! Foo') as LambdaTypeNode
      let scope = TypeScope.new(pass.module)
      let type = pass.visit_lambda_type(node: node, types: scope)

      try assert_same_object(node.resolved_type.get, type)
      try assert_true(type.throw_type.get.error?)
    }

    g.test('Defining a lambda with a valid return type') {
      let pass = DummyPass.new
      let foo_type = ClassType.new('Foo')

      pass.module.define_constant(name: foo_type.name, type: foo_type)

      let node = parse_type('fn -> Foo') as LambdaTypeNode
      let scope = TypeScope.new(pass.module)
      let type = pass.visit_lambda_type(node: node, types: scope)

      try assert_same_object(node.resolved_type.get, type)

      let returns = type.return_type

      try assert_instance_of(returns, ClassInstance)
      try assert_same_object((returns as ClassInstance).instance_of, foo_type)
    }

    g.test('Defining a lambda with an invalid return type') {
      let pass = DummyPass.new
      let node = parse_type('fn -> Foo') as LambdaTypeNode
      let scope = TypeScope.new(pass.module)
      let type = pass.visit_lambda_type(node: node, types: scope)

      try assert_same_object(node.resolved_type.get, type)
      try assert_true(type.return_type.error?)
    }

    g.test('Defining a lambda with type parameters') {
      let pass = DummyPass.new
      let foo_type = TraitType.new('Foo')

      pass.module.define_constant(name: foo_type.name, type: foo_type)

      let node = parse_type('fn !(A: Foo, B: Foo)') as LambdaTypeNode
      let scope = TypeScope.new(pass.module)
      let type = pass.visit_lambda_type(node: node, types: scope)

      try assert_same_object(node.resolved_type.get, type)

      let params = type.type_parameters.symbols
      let param0 = params[0]
      let param1 = params[1]

      try assert_equal(param0.name, 'A')
      try assert_equal(param1.name, 'B')

      try assert_equal(param0.type.name, 'A')
      try assert_equal(param1.type.name, 'B')

      try assert_equal(param0.type.required_traits[0].instance_of, foo_type)
      try assert_equal(param1.type.required_traits[0].instance_of, foo_type)
    }

    g.test('Defining a lambda type with an uninitialised generic argument') {
      let pass = DummyPass.new
      let foo_type = ClassType.new('Foo')

      foo_type.type_parameters.define(name: 'A', type: TypeParameterType.new('A'))

      pass.module.define_constant(name: foo_type.name, type: foo_type)

      let node = parse_type('fn (Foo)') as LambdaTypeNode
      let scope = TypeScope.new(pass.module)
      let type = pass.visit_lambda_type(node: node, types: scope)

      try assert_same_object(node.resolved_type.get, type)
      try assert_true(type.arguments.symbols[0].type.error?)
    }
  }

  t.group('std::compiler::type_checker::TypePass.visit_define_type_parameter') do (g) {
    g.test('Defining a type parameter') {
      let pass = DummyPass.new
      let foo_type = TraitType.new('Foo')

      pass.module.define_constant(name: foo_type.name, type: foo_type)

      let foo_node = Constant.new(name: 'Foo', location: location)
      let node = DefineTypeParameter
        .new(name: 'T', required_traits: Array.new(foo_node), location: location)

      let scope = TypeScope.new(pass.module)
      let table: SymbolTable!(TypeParameterType) = SymbolTable.new

      pass.visit_define_type_parameter(
        node: node,
        table: table,
        types: scope
      )

      let type = node.resolved_type.get

      try assert_equal(type.required_traits[0].instance_of, foo_type)
      try assert_equal(table['T'].type, type)
    }

    g.test('Defining an invalid type parameter') {
      let pass = DummyPass.new
      let foo_type = ClassType.new('Foo')

      pass.module.define_constant(name: foo_type.name, type: foo_type)

      let foo_node = Constant.new(name: 'Foo', location: location)
      let node = DefineTypeParameter
        .new(name: 'T', required_traits: Array.new(foo_node), location: location)

      let scope = TypeScope.new(pass.module)
      let table = SymbolTable.new

      pass.visit_define_type_parameter(node: node, table: table, types: scope)

      let type = node.resolved_type

      try assert_true(node.resolved_type.none?)
      try assert_true(type.none?)
      try assert_true(pass.type_checker.diagnostics.errors?)
      try assert_true(table.empty?)
    }
  }

  t.group('std::compiler::type_checker::TypeChecker.add_module') do (g) {
    g.test('Adding a module') {
      let module = new_module('foo')
      let type_checker = new_type_checker

      type_checker.add_module(module)

      try assert_same_object(type_checker.module(module.name).get, module)
    }
  }

  t.group('std::compiler::type_checker::TypeChecker.diagnostics') do (g) {
    g.test('Obtaining the diagnostics that have been produced') {
      try assert_true(new_type_checker.diagnostics.empty?)
    }
  }

  t.group('std::compiler::type_checker::TypeChecker.check') do (g) {
    g.test('Type-checking a module and its dependencies') {
      let name = ModuleName.new(Array.new('main'))
      let ast = parse("import foo\nclass A {}")
      let foo_parsed = ParsedModule
        .new(name: ModuleName.new(Array.new('foo')), ast: parse('class A {}'))

      let type_checker = new_type_checker(dependencies: Array.new(foo_parsed))

      type_checker.check(name: name, ast: ast)

      let main_mod = type_checker.module(name).get
      let foo_mod = type_checker.module(foo_parsed.name).get

      try assert_false(main_mod.constants.get('A').none?)
      try assert_false(foo_mod.constants.get('A').none?)
      try assert_false(type_checker.diagnostics.errors?)
    }
  }

  t.group('Type-checking imports') do (g) {
    g.test('Importing a single symbol') {
      let foo_mod = new_module('foo')
      let bar_mod = new_module('bar')
      let type_checker = new_type_checker
      let bar_type = ClassType.new('Bar')
      let node = parse('import foo::(Bar)')

      foo_mod.define_constant(name: bar_type.name, type: bar_type)
      type_checker.add_module(foo_mod)
      type_checker.check_module(module: bar_mod, ast: node)

      let imported = bar_mod.globals['Bar'].type

      try assert_false(type_checker.diagnostics.errors?)
      try assert_same_object(imported as ClassType, bar_type)
    }

    g.test('Importing a non-existing symbol') {
      let foo_mod = new_module('foo')
      let bar_mod = new_module('bar')
      let type_checker = new_type_checker
      let node = parse('import foo::(Bar)')

      type_checker.add_module(foo_mod)
      type_checker.check_module(module: bar_mod, ast: node)

      let imported = bar_mod.globals.get('Bar')

      try assert_true(imported.none?)
      try assert_true(type_checker.diagnostics.errors?)
    }

    g.test('Importing the same symbol twice') {
      let foo_mod = new_module('foo')
      let bar_mod = new_module('bar')
      let type_checker = new_type_checker
      let bar_type = ClassType.new('Bar')
      let node = parse('import foo::(Bar, Bar)')

      foo_mod.define_constant(name: bar_type.name, type: bar_type)
      type_checker.add_module(foo_mod)
      type_checker.check_module(module: bar_mod, ast: node)

      let imported = bar_mod.globals['Bar'].type

      try assert_true(type_checker.diagnostics.errors?)
      try assert_same_object(imported as ClassType, bar_type)
    }

    g.test('Importing two different symbols') {
      let foo_mod = new_module('foo')
      let bar_mod = new_module('bar')
      let type_checker = new_type_checker
      let node = parse('import foo::(Bar, Baz)')
      let bar_type = ClassType.new('Bar')
      let baz_type = ClassType.new('Baz')

      foo_mod.define_constant(name: bar_type.name, type: bar_type)
      foo_mod.define_constant(name: baz_type.name, type: baz_type)

      type_checker.add_module(foo_mod)
      type_checker.check_module(module: bar_mod, ast: node)

      let bar = bar_mod.globals['Bar'].type
      let baz = bar_mod.globals['Baz'].type

      try assert_same_object(bar as ClassType, bar_type)
      try assert_same_object(baz as ClassType, baz_type)
    }

    g.test('Importing a symbol with an alias') {
      let foo_mod = new_module('foo')
      let bar_mod = new_module('bar')
      let type_checker = new_type_checker
      let node = parse('import foo::(Bar as Baz)')
      let bar_type = ClassType.new('Bar')

      foo_mod.define_constant(name: bar_type.name, type: bar_type)
      type_checker.add_module(foo_mod)
      type_checker.check_module(module: bar_mod, ast: node)

      try assert_true(bar_mod.globals.get('Bar').none?)
      try assert_false(bar_mod.globals.get('Baz').none?)
    }

    g.test('Importing a module itself') {
      let foo_mod = new_module('foo')
      let bar_mod = new_module('bar')
      let node = parse('import foo::(self)')
      let type_checker = new_type_checker

      type_checker.add_module(foo_mod)
      type_checker.check_module(module: bar_mod, ast: node)

      let foo = bar_mod.globals['foo'].type

      try assert_same_object(foo as ModuleType, foo_mod)
    }

    g.test('Importing a module using an alias') {
      let foo_mod = new_module('foo')
      let bar_mod = new_module('bar')
      let type_checker = new_type_checker
      let node = parse('import foo::(self as bar)')

      type_checker.add_module(foo_mod)
      type_checker.check_module(module: bar_mod, ast: node)

      try assert_true(bar_mod.globals.get('foo').none?)
      try assert_false(bar_mod.globals.get('bar').none?)
    }

    g.test('Importing all symbols of a module') {
      let foo_mod = new_module('foo')
      let bar_mod = new_module('bar')
      let type_checker = new_type_checker
      let node = parse('import foo::*')
      let bar_type = ClassType.new('Bar')
      let baz_type = ClassType.new('Baz')

      foo_mod.define_constant(name: bar_type.name, type: bar_type)
      foo_mod.define_constant(name: baz_type.name, type: baz_type)

      type_checker.add_module(foo_mod)
      type_checker.check_module(module: bar_mod, ast: node)

      let bar = bar_mod.globals['Bar'].type
      let baz = bar_mod.globals['Baz'].type

      try assert_same_object(bar as ClassType, bar_type)
      try assert_same_object(baz as ClassType, baz_type)
    }

    g.test('Importing an external function') {
      let foo_mod = new_module('foo')
      let bar_mod = new_module('bar')
      let type_checker = new_type_checker
      let bar_type = MethodType
        .new(name: 'bar', layout: BlockLayout.new(AnyType.new), external: True)

      let node = parse('import foo::(bar)')

      foo_mod.define_method(name: bar_type.name, type: bar_type)
      type_checker.add_module(foo_mod)
      type_checker.check_module(module: bar_mod, ast: node)

      try assert_true(type_checker.diagnostics.errors?)
    }
  }

  t.group('Type-checking class definitions') do (g) {
    g.test('Defining an empty class') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let node = parse('class A {}')

      type_checker.check_module(module: module, ast: node)

      let type = module.constants['A'].type

      try assert_false(type_checker.diagnostics.errors?)
      try assert_instance_of(type, ClassType)
      try assert_instance_of(node.children[0].resolved_type.get, ClassType)
    }

    g.test('Defining an empty generic class') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let foo_type = TraitType.new('Foo')
      let node = parse('class A!(T: Foo) {}')

      module.define_constant(name: foo_type.name, type: foo_type)
      type_checker.check_module(module: module, ast: node)

      let type = module.constants['A'].type

      try assert_instance_of(type, ClassType)
      try assert_instance_of(node.children[0].resolved_type.get, ClassType)

      let param = (type as ClassType).type_parameters['T'].type

      try assert_false(type_checker.diagnostics.errors?)
      try assert_equal(param.required_traits[0].instance_of, foo_type)
    }

    g.test('Defining a generic class with an invalid type parameter') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let node = parse('class A!(T: Foo) {}')

      type_checker.check_module(module: module, ast: node)

      let type = module.constants['A'].type

      try assert_true(type_checker.diagnostics.errors?)
      try assert_instance_of(type, ClassType)
      try assert_instance_of(node.children[0].resolved_type.get, ClassType)
      try assert_true((type as ClassType).type_parameters.get('T').none?)
    }

    g.test('Redefining an existing class') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let a_type = ClassType.new('A')
      let node = parse('class A {}')

      module.define_constant(name: a_type.name, type: a_type)
      type_checker.check_module(module: module, ast: node)

      try assert_true(type_checker.diagnostics.errors?)
      try assert_same_object(module.constants['A'].type, a_type)
      try assert_instance_of(node.children[0].resolved_type.get, ClassType)
    }
  }

  t.group('Type-checking trait definitions') do (g) {
    g.test('Defining a trait') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let node = parse('trait A {}')

      type_checker.check_module(module: module, ast: node)

      let type = module.constants['A'].type

      try assert_false(type_checker.diagnostics.errors?)
      try assert_instance_of(type, TraitType)
      try assert_instance_of(node.children[0].resolved_type.get, TraitType)
    }

    g.test('Defining a generic trait') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let foo_type = TraitType.new('Foo')
      let node = parse('trait A!(T: Foo) {}')

      module.define_constant(name: foo_type.name, type: foo_type)
      type_checker.check_module(module: module, ast: node)

      let type = module.constants['A'].type

      try assert_false(type_checker.diagnostics.errors?)
      try assert_instance_of(type, TraitType)
      try assert_instance_of(node.children[0].resolved_type.get, TraitType)

      let param = (type as ClassType).type_parameters['T'].type

      try assert_equal(param.required_traits[0].instance_of, foo_type)
    }

    g.test('Defining a generic trait with an invalid type parameter') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let node = parse('trait A!(T: Foo) {}')

      type_checker.check_module(module: module, ast: node)

      let type = module.constants['A'].type

      try assert_true(type_checker.diagnostics.errors?)
      try assert_instance_of(type, TraitType)
      try assert_same_object(node.children[0].resolved_type.get, type)
      try assert_true((type as TraitType).type_parameters.get('T').none?)
    }

    g.test('Redefining an existing trait') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let a_type = TraitType.new('A')
      let node = parse('trait A {}')

      module.define_constant(name: a_type.name, type: a_type)
      type_checker.check_module(module: module, ast: node)

      try assert_true(type_checker.diagnostics.errors?)
      try assert_same_object(module.constants['A'].type, a_type)
      try assert_instance_of(node.children[0].resolved_type.get, TraitType)
    }
  }

  t.group('Type-checking attribute definitions') do (g) {
    g.test('Defining an attribute') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let foo_type = ClassType.new('Foo')
      let node = parse('class A { @foo: Foo }')
      let attr_node =
        (node.children[0] as DefineClass).body.children[0] as DefineAttribute

      module.define_constant(name: foo_type.name, type: foo_type)
      type_checker.check_module(module: module, ast: node)

      let obj = module.constants['A'].type as ClassType
      let attr = obj.attributes['@foo'].type

      try assert_instance_of(attr.public_type, ClassInstance)
      try assert_instance_of(attr.internal_type, ClassInstance)
      try assert_same_object(attr_node.resolved_type.get, attr.internal_type)
      try assert_same_object(
        (attr.internal_type as ClassInstance).instance_of,
        foo_type
      )
    }

    g.test('Defining an attribute as a type parameter') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let node = parse('class A!(T) { @foo: T }')
      let attr_node =
        (node.children[0] as DefineClass).body.children[0] as DefineAttribute

      type_checker.check_module(module: module, ast: node)

      let obj = module.constants['A'].type as ClassType
      let attr = obj.attributes['@foo'].type

      try assert_false(type_checker.diagnostics.errors?)
      try assert_instance_of(attr.internal_type, RigidTypeParameterType)
      try assert_instance_of(attr.public_type, TypeParameterType)
      try assert_same_object(attr_node.resolved_type.get, attr.internal_type)
    }

    g.test('Defining an attribute as a generic type containing a type parameter') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let node = parse('class A!(T) { @foo: List!(T) }')
      let list_type = ClassType.new('List')
      let list_param = TypeParameterType.new('A')

      list_type.type_parameters.define(name: 'A', type: list_param)
      module.globals.define(name: list_type.name, type: list_type)
      type_checker.check_module(module: module, ast: node)

      let obj = module.constants['A'].type as ClassType
      let attr = obj.attributes['@foo'].type.internal_type as ClassInstance

      try assert_false(type_checker.diagnostics.errors?)
      try assert_instance_of(attr, ClassInstance)

      let list_param_type = attr.lookup_type_parameter_type(list_param).get
      let obj_param = obj.lookup_type_parameter('T').get.type

      try assert_instance_of(list_param_type, RigidTypeParameterType)
      try assert_same_object(
        (list_param_type as RigidTypeParameterType).type,
        obj_param
      )
    }

    g.test('Defining an attribute with an invalid type') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let node = parse('class A { @foo: Foo }')
      let attr_node =
        (node.children[0] as DefineClass).body.children[0] as DefineAttribute

      type_checker.check_module(module: module, ast: node)

      let obj = module.constants['A'].type as ClassType
      let attr = obj.attributes['@foo'].type

      try assert_true(type_checker.diagnostics.errors?)
      try assert_true(attr.public_type.error?)
      try assert_true(attr.internal_type.error?)
      try assert_true(attr_node.resolved_type.get.error?)
    }
  }

  t.group('Type-checking local variable definitions') do (g) {
    g.test('Defining a local variable') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let body = parse('let a = 10')

      type_checker.check_module(module: module, ast: body)

      let symbol = body.variable_scope.symbols['a']
      let let_node = body.children[0] as DefineLocalVariable

      try assert_false(type_checker.diagnostics.errors?)

      try assert_false(symbol.mutable?)
      try assert_false(symbol.type.error?)

      try assert_same_object(let_node.resolved_type.get, symbol.type)
      try assert_same_object(
        let_node.resolved_type.get,
        let_node.value.resolved_type.get
      )
    }

    g.test('Defining a local variable with an invalid value') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let body = parse('let a = Foo')

      type_checker.check_module(module: module, ast: body)

      let symbol = body.variable_scope.symbols['a']
      let let_node = body.children[0] as DefineLocalVariable

      try assert_true(type_checker.diagnostics.errors?)

      try assert_false(symbol.mutable?)
      try assert_true(symbol.type.error?)

      try assert_same_object(let_node.resolved_type.get, symbol.type)
      try assert_same_object(
        let_node.resolved_type.get,
        let_node.value.resolved_type.get
      )
    }

    g.test('Defining a local variable with an explicit type') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let body = parse('let a: Any = 10')

      type_checker.check_module(module: module, ast: body)

      let symbol = body.variable_scope.symbols['a']
      let let_node = body.children[0] as DefineLocalVariable

      try assert_false(type_checker.diagnostics.errors?)

      try assert_false(symbol.mutable?)
      try assert_false(symbol.type.error?)

      try assert_same_object(let_node.resolved_type.get, symbol.type)
      try assert_same_object(
        let_node.resolved_type.get,
        let_node.value_type.get.resolved_type.get
      )
      try assert_instance_of(let_node.resolved_type.get, AnyType)
    }

    g.test('Defining a local variable with an incompatible value') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let body = parse('let a: String = 10')

      module
        .define_constant(name: 'String', type: type_checker.builtins.string_type)

      type_checker.check_module(module: module, ast: body)

      let symbol = body.variable_scope.symbols['a']
      let let_node = body.children[0] as DefineLocalVariable

      try assert_true(type_checker.diagnostics.errors?)

      try assert_false(symbol.mutable?)
      try assert_false(symbol.type.error?)

      try assert_same_object(let_node.resolved_type.get, symbol.type)
      try assert_same_object(
        let_node.resolved_type.get,
        let_node.value_type.get.resolved_type.get
      )

      try assert_object_instance(
        let_node.resolved_type.get,
        type_checker.builtins.string_type
      )
    }

    g.test('Defining a local variable with an undefined explicit type') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let body = parse('let a: Object = 10')

      type_checker.check_module(module: module, ast: body)

      let symbol = body.variable_scope.symbols['a']
      let let_node = body.children[0] as DefineLocalVariable

      try assert_true(type_checker.diagnostics.errors?)

      try assert_false(symbol.mutable?)
      try assert_true(symbol.type.error?)

      try assert_same_object(let_node.resolved_type.get, symbol.type)
      try assert_same_object(
        let_node.resolved_type.get,
        let_node.value_type.get.resolved_type.get
      )
    }

    g.test('Defining a local variable with Self as the explicit type') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let body = parse('let a: Self = 10')

      type_checker.check_module(module: module, ast: body)

      let symbol = body.variable_scope.symbols['a']
      let let_node = body.children[0] as DefineLocalVariable

      try assert_true(type_checker.diagnostics.errors?)

      try assert_false(symbol.mutable?)
      try assert_true(symbol.type.error?)

      try assert_same_object(let_node.resolved_type.get, symbol.type)
      try assert_true(let_node.resolved_type.get.error?)
    }

    g.test('Defining an already existing local variable') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let body = parse('let a = 10')
      let a_type = type_checker.builtins.float_type.new_instance

      body.variable_scope.symbols.define(name: 'a', type: a_type)

      type_checker.check_module(module: module, ast: body)

      let symbol = body.variable_scope.symbols['a']
      let let_node = body.children[0] as DefineLocalVariable

      try assert_true(type_checker.diagnostics.errors?)
      try assert_same_object(symbol.type, a_type)

      try assert_false(let_node.resolved_type.same_object?(symbol.type))
      try assert_same_object(
        let_node.resolved_type.get,
        let_node.value.resolved_type.get
      )
    }
  }

  t.group('Type-checking literals') do (g) {
    g.test('Type-checking an integer literal') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let body = parse('10')

      type_checker.check_module(module: module, ast: body)

      try assert_object_instance(
        body.children[0].resolved_type.get,
        type_checker.builtins.integer_type
      )
    }

    g.test('Type-checking a float literal') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let body = parse('10.5')

      type_checker.check_module(module: module, ast: body)

      try assert_object_instance(
        body.children[0].resolved_type.get,
        type_checker.builtins.float_type
      )
    }

    g.test('Type-checking a string literal') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let body = parse('"foo"')

      type_checker.check_module(module: module, ast: body)

      try assert_object_instance(
        body.children[0].resolved_type.get,
        type_checker.builtins.string_type
      )
    }
  }

  t.group('Type-checking constant references') do (g) {
    g.test('Referring to an undefined constant') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let body = parse('Foo')
      let node = body.children[0] as Constant

      type_checker.check_module(module: module, ast: body)

      try assert_true(type_checker.diagnostics.errors?)
      try assert_true(node.symbol.none?)
      try assert_true(body.children[0].resolved_type.get.error?)
    }

    g.test('Referring to a defined constant') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let body = parse('Foo')
      let node = body.children[0] as Constant
      let foo_type = type_checker.builtins.string_type.new_instance

      module.define_constant(name: 'Foo', type: foo_type)
      type_checker.check_module(module: module, ast: body)

      try assert_false(type_checker.diagnostics.errors?)
      try assert_same_object(node.symbol.get.type, foo_type)
      try assert_same_object(body.children[0].resolved_type.get, foo_type)
    }
  }

  t.group('Type-checking method definitions') do (g) {
    g.test('Defining a method without arguments') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let body = parse('def foo {}')

      type_checker.check_module(module: module, ast: body)

      try assert_false(type_checker.diagnostics.errors?)

      let method = module.methods['foo'].type as MethodType

      try assert_instance_of(method, MethodType)
      try assert_same_object(body.children[0].resolved_type.get, method)
      try assert_true(method.arguments.empty?)
    }

    g.test('Defining a method with invalid statically typed arguments') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let body = parse('def foo(a: A, b: B) {}')

      type_checker.check_module(module: module, ast: body)

      try assert_true(type_checker.diagnostics.errors?)

      let method = module.methods['foo'].type as MethodType

      try assert_true(method.arguments['a'].type.error?)
      try assert_true(method.arguments['b'].type.error?)
    }

    g.test('Defining a method with valid statically typed arguments') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let body = parse('def foo(a: String, b: Int) {}')

      module
        .define_constant(name: 'String', type: type_checker.builtins.string_type)

      module
        .define_constant(name: 'Int', type: type_checker.builtins.integer_type)

      type_checker.check_module(module: module, ast: body)

      let method = module.methods['foo'].type as MethodType
      let a_type = method.arguments['a'].type
      let b_type = method.arguments['b'].type

      try assert_false(type_checker.diagnostics.errors?)
      try assert_object_instance(a_type, type_checker.builtins.string_type)
      try assert_object_instance(b_type, type_checker.builtins.integer_type)
    }

    g.test('Defining a method with a default argument value') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let body = parse('def foo(a = 10) {}')

      type_checker.check_module(module: module, ast: body)

      let method = module.methods['foo'].type as MethodType
      let a_type = method.arguments['a'].type

      try assert_false(type_checker.diagnostics.errors?)
      try assert_object_instance(a_type, type_checker.builtins.integer_type)
    }

    g.test('Defining a method with a default argument value and a compatible explicit type') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let body = parse('def foo(a: Any = 10) {}')

      type_checker.check_module(module: module, ast: body)

      let method = module.methods['foo'].type as MethodType
      let a_type = method.arguments['a'].type

      try assert_false(type_checker.diagnostics.errors?)
      try assert_instance_of(a_type, AnyType)
    }

    g.test('Defining a method with a default argument value and an incompatible explicit type') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let body = parse('def foo(a: Float = 10) {}')

      module.define_constant(name: 'Float', type_checker.builtins.float_type)

      type_checker.check_module(module: module, ast: body)

      let method = module.methods['foo'].type as MethodType
      let a_type = method.arguments['a'].type

      try assert_true(type_checker.diagnostics.errors?)
      try assert_object_instance(a_type, type_checker.builtins.float_type)
    }

    g.test('Defining a method with a statically typed rest argument') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let body = parse('def foo(*a: Int) {}')

      module
        .define_constant(name: 'Int', type: type_checker.builtins.integer_type)

      type_checker.check_module(module: module, ast: body)

      let method = module.methods['foo'].type as MethodType
      let arg = method.arguments['a'].type as ClassInstance

      try assert_false(type_checker.diagnostics.errors?)
      try assert_true(method.rest_argument?)
      try assert_object_instance(arg, type_checker.builtins.integer_type)
    }

    g.test('Defining a method with an invalid throw type') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let body = parse('def foo !! Int {}')

      type_checker.check_module(module: module, ast: body)

      let method = module.methods['foo'].type as MethodType

      try assert_true(type_checker.diagnostics.errors?)
      try assert_true(method.throw_type.get.error?)
    }

    g.test('Defining a method with a valid throw type that never throws') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let body = parse('def foo !! Int {}')

      module
        .define_constant(name: 'Int', type: type_checker.builtins.integer_type)

      type_checker.check_module(module: module, ast: body)

      let method = module.methods['foo'].type as MethodType

      try assert_true(type_checker.diagnostics.errors?)
      try assert_object_instance(
        method.throw_type.get,
        type_checker.builtins.integer_type
      )
    }

    g.test('Defining a method with a valid throw type that throws') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let body = parse('def foo !! Int { throw 10 }')

      module
        .define_constant(name: 'Int', type: type_checker.builtins.integer_type)

      type_checker.check_module(module: module, ast: body)

      let method = module.methods['foo'].type as MethodType

      try assert_false(type_checker.diagnostics.errors?)
      try assert_object_instance(
        method.throw_type.get,
        type_checker.builtins.integer_type
      )
    }

    g.test('Defining a method with an invalid return type') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let body = parse('def foo -> Int {}')

      type_checker.check_module(module: module, ast: body)

      let method = module.methods['foo'].type as MethodType

      try assert_true(type_checker.diagnostics.errors?)
      try assert_true(method.return_type.error?)
    }

    g.test('Defining a method with a return value that does not return') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let body = parse('def foo -> Int {}')

      module
        .define_constant(name: 'Int', type: type_checker.builtins.integer_type)

      type_checker.check_module(module: module, ast: body)

      let method = module.methods['foo'].type as MethodType

      try assert_true(type_checker.diagnostics.errors?)
      try assert_object_instance(
        method.return_type,
        type_checker.builtins.integer_type
      )
    }

    g.test('Defining a method without an explicit return type that returns') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let body = parse('def foo { 10 }')

      type_checker.check_module(module: module, ast: body)

      let method = module.methods['foo'].type as MethodType

      try assert_false(type_checker.diagnostics.errors?)
      try assert_object_instance(method.return_type, type_checker.builtins.nil_type)
    }

    g.test('Defining a method with a valid explicit return type') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let body = parse('def foo -> Int { return 10 }')

      module
        .define_constant(name: 'Int', type: type_checker.builtins.integer_type)

      type_checker.check_module(module: module, ast: body)

      let method = module.methods['foo'].type as MethodType

      try assert_false(type_checker.diagnostics.errors?)
      try assert_object_instance(
        method.return_type,
        type_checker.builtins.integer_type
      )
    }

    g.test('Defining a method with an invalid explicit return type') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let body = parse('def foo -> Int { return 10.5 }')

      module
        .define_constant(name: 'Int', type: type_checker.builtins.integer_type)

      type_checker.check_module(module: module, ast: body)

      try assert_true(type_checker.diagnostics.errors?)
      try assert_equal(type_checker.diagnostics.length, 1)
    }

    g.test('Defining a method with a valid implicit return type') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let body = parse('def foo -> Int { 10 }')

      module
        .define_constant(name: 'Int', type: type_checker.builtins.integer_type)

      type_checker.check_module(module: module, ast: body)

      try assert_false(type_checker.diagnostics.errors?)
    }

    g.test('Defining a method with an invalid implicit return type') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let body = parse('def foo -> Int { 10.5 }')

      module
        .define_constant(name: 'Int', type: type_checker.builtins.integer_type)

      type_checker.check_module(module: module, ast: body)

      try assert_true(type_checker.diagnostics.errors?)
    }

    g.test('Defining a method with valid type parameters') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let body = parse('def foo!(A, B: ToInt) {}')
      let trait_type = TraitType.new('ToInt')

      module
        .define_constant(name: 'ToInt', type: TraitInstance.new(trait_type))

      type_checker.check_module(module: module, ast: body)

      let method = module.methods['foo'].type as MethodType

      try assert_false(type_checker.diagnostics.errors?)
      try assert_equal(method.type_parameters.length, 2)

      try assert_true(method.type_parameters['A'].type.required_traits.empty?)

      try assert_trait_instance(
        method.type_parameters['B'].type.required_traits[0],
        trait_type
      )
    }

    g.test('Defining a method with invalid type parameters') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let body = parse('def foo!(A, B: ToInt) {}')

      type_checker.check_module(module: module, ast: body)

      let method = module.methods['foo'].type as MethodType

      try assert_true(type_checker.diagnostics.errors?)
      try assert_equal(method.type_parameters.length, 1)

      try assert_true(method.type_parameters['A'].type.required_traits.empty?)
      try assert_true(method.type_parameters.get('B').none?)
    }

    g.test('Defining a method with its type arguments used as method bounds') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let body = parse('def foo!(T) when T: ToString {}')
      let trait_type = TraitType.new('ToString')

      module.define_constant(name: 'ToString', trait_type)

      type_checker.check_module(module: module, ast: body)

      let method = module.methods['foo'].type

      try assert_true(type_checker.diagnostics.errors?)
      try assert_true(method.type_parameter_bounds.empty?)
    }

    g.test('Defining a method with duplicate type parameter bounds') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let trait1 = TraitType.new('ToString')
      let trait2 = TraitType.new('ToInt')
      let body =
        parse('class A!(T) { def foo when T: ToString, T: ToInt {} }')

      module.define_constant(name: 'ToString', trait1)
      module.define_constant(name: 'ToInt', trait2)

      type_checker.check_module(module: module, ast: body)

      let a_obj = module.constants['A'].type as ClassType
      let param = a_obj.type_parameters['T'].type
      let method = a_obj.instance_methods['foo'].type
      let bounds = method.type_parameter_bounds[param]

      try assert_true(type_checker.diagnostics.errors?)
      try assert_equal(bounds.length, 1)
      try assert_equal(bounds[0].instance_of, trait1)
    }

    g.test('Defining a method with an argument type used in a method bound') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let body = parse('class A!(T) { def foo(a: T) when T: ToString {} }')
      let trait_type = TraitType.new('ToString')

      module.define_constant(name: 'ToString', trait_type)

      type_checker.check_module(module: module, ast: body)

      let a_obj = module.constants['A'].type as ClassType
      let method = a_obj.instance_methods['foo'].type as MethodType
      let arg_type = method.arguments['a'].type as TypeParameterType

      try assert_false(type_checker.diagnostics.errors?)
      try assert_instance_of(arg_type, TypeParameterType)

      try assert_equal(arg_type.name, 'T')
      try assert_true(arg_type.required_traits.empty?)
    }

    g.test('Defining a method with a throw type used in a method bound') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let body =
        parse('class A!(T) { def foo(a: T) !! T when T: ToString { throw a } }')

      let trait_type = TraitType.new('ToString')

      module.define_constant(name: 'ToString', trait_type)

      type_checker.check_module(module: module, ast: body)

      let a_obj = module.constants['A'].type as ClassType
      let method = a_obj.instance_methods['foo'].type as MethodType
      let ttype = method.throw_type.get as TypeParameterType

      try assert_false(type_checker.diagnostics.errors?)
      try assert_instance_of(ttype, TypeParameterType)

      try assert_equal(ttype.name, 'T')
      try assert_true(ttype.required_traits.empty?)
    }

    g.test('Defining a method with a return type used in a method bound') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let body = parse('class A!(T) { def foo -> T when T: ToString {} }')
      let trait_type = TraitType.new('ToString')

      module.define_constant(name: 'ToString', trait_type)

      type_checker.check_module(module: module, ast: body)

      let a_obj = module.constants['A'].type as ClassType
      let method = a_obj.instance_methods['foo'].type as MethodType
      let rtype = method.return_type as TypeParameterType

      try assert_false(type_checker.diagnostics.errors?)
      try assert_instance_of(rtype, TypeParameterType)

      try assert_equal(rtype.name, 'T')
      try assert_true(rtype.required_traits.empty?)
    }

    g.test('Defining a module method') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let body = parse('def foo(a: Self) {} def foo {}')

      type_checker.check_module(module: module, ast: body)

      let method = module.methods['foo'].type as MethodType

      try assert_true(type_checker.diagnostics.errors?)
      try assert_equal(method.arguments.length, 1)
    }

    g.test('Defining a module method that already exists') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let body = parse('def foo(a: Self) {}')
      let method_type =
        MethodType.new(name: 'foo', layout: BlockLayout.new(NeverType.new))

      module.define_method(name: 'foo', type: method_type)
      type_checker.check_module(module: module, ast: body)

      try assert_true(type_checker.diagnostics.errors?)
      try assert_same_object(module.methods['foo'].type, method_type)
    }

    g.test('Defining a module method with the same name as an imported constant') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let body = parse('def foo(a: Self) {}')

      module.globals.define(name: 'foo', type: ClassType.new('Foo'))
      type_checker.check_module(module: module, ast: body)

      try assert_false(type_checker.diagnostics.errors?)
      try assert_false(module.methods.get('foo').none?)
    }

    g.test('Defining a default method with the same name as a required method') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let body = parse('trait Foo { def foo def foo {} }')

      type_checker.check_module(module: module, ast: body)

      let trait_type = body.children[0].resolved_type.get as TraitType

      try assert_true(type_checker.diagnostics.errors?)
      try assert_true(trait_type.default_methods.empty?)
    }

    g.test('Defining a required method with the same name as a default method') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let body = parse('trait Foo { def foo {} def foo }')

      type_checker.check_module(module: module, ast: body)

      let trait_type = body.children[0].resolved_type.get as TraitType

      try assert_true(type_checker.diagnostics.errors?)
      try assert_true(trait_type.required_methods.empty?)
    }

    g.test('Defining a required method with a default argument value') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let body = parse('trait Foo { def foo(a = 10) }')

      type_checker.check_module(module: module, ast: body)

      let trait_type = body.children[0].resolved_type.get as TraitType
      let method = trait_type.required_methods['foo'].type

      try assert_true(type_checker.diagnostics.errors?)

      try assert_object_instance(
        method.arguments['a'].type,
        type_checker.builtins.integer_type
      )
    }

    g.test('Defining a method in an object') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let int_type = type_checker.builtins.integer_type
      let body = parse('class A { def foo -> Int { 10 } }')
      let object_node = body.children[0] as DefineClass
      let method_node = object_node.body.children[0] as DefineMethod
      let int_node = method_node.body.children[0] as IntegerLiteral

      module.define_constant(name: 'Int', type: int_type)

      type_checker.check_module(module: module, ast: body)

      try assert_false(type_checker.diagnostics.errors?)
      try assert_object_instance(int_node.resolved_type.get, int_type)
    }

    g.test('Defining a method in a trait') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let int_type = type_checker.builtins.integer_type
      let body = parse('trait A { def foo -> Int { 10 } }')
      let object_node = body.children[0] as DefineTrait
      let method_node = object_node.body.children[0] as DefineMethod
      let int_node = method_node.body.children[0] as IntegerLiteral

      module.define_constant(name: 'Int', type: int_type)

      type_checker.check_module(module: module, ast: body)

      try assert_false(type_checker.diagnostics.errors?)
      try assert_object_instance(int_node.resolved_type.get, int_type)
    }

    g.test('Defining a method in a trait implementation') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let int_type = type_checker.builtins.integer_type
      let body = parse('impl A for B { def foo -> Int { 10 } }')
      let object_node = body.children[0] as ImplementTrait
      let method_node = object_node.body.children[0] as DefineMethod
      let int_node = method_node.body.children[0] as IntegerLiteral

      module.define_constant(name: 'Int', type: int_type)
      module.define_constant(name: 'A', type: TraitType.new('A'))
      module.define_constant(name: 'B', type: ClassType.new('B'))

      type_checker.check_module(module: module, ast: body)

      try assert_false(type_checker.diagnostics.errors?)
      try assert_object_instance(int_node.resolved_type.get, int_type)
    }

    g.test('Defining a method when reopening an object') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let int_type = type_checker.builtins.integer_type
      let body = parse('impl Int { def foo -> Int { 10 } }')
      let object_node = body.children[0] as ImplementTrait
      let method_node = object_node.body.children[0] as DefineMethod
      let int_node = method_node.body.children[0] as IntegerLiteral

      module.define_constant(name: 'Int', type: int_type)

      type_checker.check_module(module: module, ast: body)

      try assert_false(type_checker.diagnostics.errors?)
      try assert_object_instance(int_node.resolved_type.get, int_type)
    }

    g.test('Defining a method in an object') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let body = parse('class Foo { def foo {} }')

      type_checker.check_module(module: module, ast: body)

      let obj_type = body.children[0].resolved_type.get as ClassType

      try assert_false(type_checker.diagnostics.errors?)
      try assert_instance_of(obj_type, ClassType)

      try assert_false(obj_type.instance_methods.get('foo').none?)
    }

    g.test('Redefining a method in an object') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let body = parse('class Foo { def foo(a: Self) {} def foo {} }')

      type_checker.check_module(module: module, ast: body)

      let foo_type = module.constants['Foo'].type as ClassType
      let method = foo_type.instance_methods['foo'].type

      try assert_true(type_checker.diagnostics.errors?)
      try assert_equal(method.arguments.length, 1)
    }

    g.test('Defining an instance method with the same name as a static method') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let body = parse('class Foo { static def foo {} def foo {} }')

      type_checker.check_module(module: module, ast: body)

      let foo_type = module.constants['Foo'].type as ClassType

      try assert_true(type_checker.diagnostics.errors?)
      try assert_false(foo_type.static_methods.get('foo').none?)
      try assert_true(foo_type.instance_methods.get('foo').none?)
    }

    g.test('Defining a static method with the same name as an instance method') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let body = parse('class Foo { def foo {} static def foo {} }')

      type_checker.check_module(module: module, ast: body)

      let foo_type = module.constants['Foo'].type as ClassType

      try assert_true(type_checker.diagnostics.errors?)
      try assert_true(foo_type.static_methods.get('foo').none?)
      try assert_false(foo_type.instance_methods.get('foo').none?)
    }

    g.test('Defining an instance method with an argument depending on the "self" type') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let body = parse('class Foo { def foo(a = self) {} }')

      type_checker.check_module(module: module, ast: body)

      let obj_type = module.constants['Foo'].type as ClassType
      let method = obj_type.instance_methods['foo'].type

      try assert_false(type_checker.diagnostics.errors?)
      try assert_object_instance(method.arguments['a'].type, obj_type)
    }

    g.test('Defining a static method with an argument depending on the "self" type') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let body = parse('class Foo { static def foo(a = self) {} }')

      type_checker.check_module(module: module, ast: body)

      let obj_type = module.constants['Foo'].type as ClassType
      let method = obj_type.static_methods['foo'].type

      try assert_false(type_checker.diagnostics.errors?)
      try assert_same_object(method.arguments['a'].type, obj_type)
    }

    g.test('Defining a method inside a trait') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let body = parse('trait Foo { def foo {} }')

      type_checker.check_module(module: module, ast: body)

      let trait_type = body.children[0].resolved_type.get as TraitType

      try assert_false(type_checker.diagnostics.errors?)
      try assert_instance_of(trait_type, TraitType)

      try assert_false(trait_type.default_methods.get('foo').none?)
    }

    g.test('Defining a default method with an argument depending on the "self" type') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let body = parse('trait Foo { def foo(a = self) {} }')

      type_checker.check_module(module: module, ast: body)

      let trait_type = module.constants['Foo'].type as TraitType
      let method = trait_type.default_methods['foo'].type

      try assert_false(type_checker.diagnostics.errors?)
      try assert_trait_instance(method.arguments['a'].type, trait_type)
    }

    g.test('Referring to a method argument in its body') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let int_type = type_checker.builtins.integer_type
      let body = parse('def foo(a: Int) { a }')

      module.define_constant(name: 'Int', type: int_type)
      type_checker.check_module(module: module, ast: body)

      let method = body.children[0] as DefineMethod
      let lvar = method.body.children[0] as Identifier

      try assert_object_instance(lvar.resolved_type.get, int_type)
      try assert_false(type_checker.diagnostics.errors?)
    }

    g.test('Referring to a method rest argument in its body') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let int_type = type_checker.builtins.integer_type
      let ary_type = type_checker.builtins.array_type
      let body = parse('def foo(*a: Int) { a }')

      module.define_constant(name: 'Int', type: int_type)
      type_checker.check_module(module: module, ast: body)

      let method = body.children[0] as DefineMethod
      let lvar = method.body.children[0] as Identifier

      let param = type_checker
        .builtins
        .array_type
        .lookup_type_parameter(ARRAY_TYPE_PARAMETER)
        .get
        .type

      let type = lvar.resolved_type.get

      try assert_object_instance(type, ary_type)
      try assert_object_instance(type.lookup_type_parameter_type(param).get, int_type)
      try assert_false(type_checker.diagnostics.errors?)
    }

    g.test('Defining a static method that returns self when the return type is Self') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let int_type = type_checker.builtins.integer_type
      let body = parse('impl Int { static def foo -> Self { self } }')

      module.define_constant(name: 'Int', type: int_type)
      type_checker.check_module(module: module, ast: body)

      # Here `self` is `Int` itself, but `-> Self` means "returns an
      # _instance_ of Int".
      try assert_true(type_checker.diagnostics.errors?)
    }

    g.test('Defining a method that returns self when the return type is Self') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let int_type = type_checker.builtins.integer_type
      let body = parse('impl Int { def foo -> Self { self } }')

      module.define_constant(name: 'Int', type: int_type)
      type_checker.check_module(module: module, ast: body)

      try assert_false(type_checker.diagnostics.errors?)
    }

    g.test('Defining a method that yields') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let int_type = type_checker.builtins.integer_type
      let body = parse('def foo => Int { yield 10 }')
      let node = body.children[0] as DefineMethod

      module.define_constant(name: 'Int', type: int_type)
      type_checker.check_module(module: module, ast: body)

      let method = module.methods['foo'].type as MethodType

      try assert_false(type_checker.diagnostics.errors?)
      try assert_object_instance(method.yield_type.get, int_type)
      try assert_object_instance(node.body.children[0].resolved_type.get, int_type)
    }

    g.test('Defining a required method with a yield type') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let int_type = type_checker.builtins.integer_type
      let body = parse('trait A { def foo => Int }')

      module.define_constant(name: 'Int', type: int_type)
      type_checker.check_module(module: module, ast: body)

      let ttype = module.constants['A'].type as TraitType
      let mtype = ttype.required_methods['foo'].type

      try assert_false(type_checker.diagnostics.errors?)
      try assert_object_instance(mtype.yield_type.get, int_type)
    }

    g.test('Defining a method with a yield type that never yields') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let int_type = type_checker.builtins.integer_type
      let body = parse('def foo => Int {}')

      module.define_constant(name: 'Int', type: int_type)
      type_checker.check_module(module: module, ast: body)

      try assert_true(type_checker.diagnostics.errors?)
    }

    g.test('Defining a method that yields without a yield type') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let body = parse('def foo { yield 10 }')

      type_checker.check_module(module: module, ast: body)

      try assert_true(type_checker.diagnostics.errors?)
    }

    g.test('Defining a method that yields an invalid type') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let int_type = type_checker.builtins.integer_type
      let body = parse('def foo => Int { yield 10.5 }')

      module.define_constant(name: 'Int', type: int_type)
      type_checker.check_module(module: module, ast: body)

      try assert_true(type_checker.diagnostics.errors?)
    }

    g.test('Defining a method with a yield type that returns a value') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let int_type = type_checker.builtins.integer_type
      let body = parse(
        'def foo => Int {
          yield 10
          return 10
        }'
      )

      module.define_constant(name: 'Int', type: int_type)
      type_checker.check_module(module: module, ast: body)

      try assert_true(type_checker.diagnostics.errors?)
    }

    g.test('Defining a method with a yield type that returns without a value') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let int_type = type_checker.builtins.integer_type
      let body = parse('def foo => Int { yield 10 return }')

      module.define_constant(name: 'Int', type: int_type)
      type_checker.check_module(module: module, ast: body)

      try assert_false(type_checker.diagnostics.errors?)
    }

    g.test('Defining a method with both a return and yield type') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let int_type = type_checker.builtins.integer_type
      let body = parse('def foo -> Int => Int { yield 10 }')

      module.define_constant(name: 'Int', type: int_type)
      type_checker.check_module(module: module, ast: body)

      try assert_true(type_checker.diagnostics.errors?)
    }

    g.test('Defining a method using a required class type parameter argument') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let body = parse('class A!(T) { def foo(arg: T) {} }')
      let obj_node = body.children[0] as DefineClass
      let meth_node = obj_node.body.children[0] as DefineMethod
      let arg_node = meth_node.arguments[0] as DefineRequiredArgument

      type_checker.check_module(module: module, ast: body)

      let body_vars = meth_node.body.variable_scope
      let obj_type = module.constants['A'].type
      let param = obj_type.lookup_type_parameter('T').get.type
      let lvar = body_vars.symbols['arg'].type

      try assert_same_object(arg_node.resolved_type.get, param)
      try assert_instance_of(lvar, RigidTypeParameterType)
      try assert_same_object((lvar as RigidTypeParameterType).type, param)
    }

    g.test('Defining a method using a required method type parameter argument') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let body = parse('def foo!(T)(arg: T) {}')
      let meth_node = body.children[0] as DefineMethod
      let arg_node = meth_node.arguments[0] as DefineRequiredArgument

      type_checker.check_module(module: module, ast: body)

      let body_vars = meth_node.body.variable_scope
      let meth_type = module.methods['foo'].type
      let param = meth_type.lookup_type_parameter('T').get.type
      let lvar = body_vars.symbols['arg'].type

      try assert_same_object(arg_node.resolved_type.get, param)
      try assert_instance_of(lvar, RigidTypeParameterType)
      try assert_same_object((lvar as RigidTypeParameterType).type, param)
    }

    g.test('Defining a method using an optional method type parameter argument') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let body = parse('def foo!(T)(arg: T = 10) {}')
      let meth_node = body.children[0] as DefineMethod
      let arg_node = meth_node.arguments[0] as DefineOptionalArgument

      type_checker.check_module(module: module, ast: body)

      let body_vars = meth_node.body.variable_scope
      let meth_type = module.methods['foo'].type
      let param = meth_type.lookup_type_parameter('T').get.type
      let lvar = body_vars.symbols['arg'].type

      try assert_same_object(arg_node.resolved_type.get, param)
      try assert_instance_of(lvar, RigidTypeParameterType)
      try assert_same_object((lvar as RigidTypeParameterType).type, param)
    }

    g.test('Defining a method using a rest method type parameter argument') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let body = parse('def foo!(T)(*arg: T) {}')
      let meth_node = body.children[0] as DefineMethod
      let arg_node = meth_node.arguments[0] as DefineRestArgument

      type_checker.check_module(module: module, ast: body)

      let body_vars = meth_node.body.variable_scope
      let meth_type = module.methods['foo'].type
      let param = meth_type.lookup_type_parameter('T').get.type
      let lvar = body_vars.symbols['arg'].type

      let arg_node_type = arg_node.resolved_type.get
      let ary_param = type_checker
        .builtins
        .array_type
        .lookup_type_parameter(ARRAY_TYPE_PARAMETER)
        .get
        .type

      let lvar_param_type = lvar.lookup_type_parameter_type(ary_param).get

      try assert_same_object(arg_node_type, param)
      try assert_object_instance(lvar, type_checker.builtins.array_type)
      try assert_instance_of(lvar_param_type, RigidTypeParameterType)
      try assert_same_object((lvar_param_type as RigidTypeParameterType).type, param)
    }

    g.test('Referring to an class type parameter in a method body') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let body = parse('class A!(T) { def foo { T } }')

      type_checker.check_module(module: module, ast: body)

      try assert_true(type_checker.diagnostics.errors?)
    }

    g.test('Referring to a trait type parameter in a method body') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let body = parse('trait A!(T) { def foo { T } }')

      type_checker.check_module(module: module, ast: body)

      try assert_true(type_checker.diagnostics.errors?)
    }

    g.test('Referring to a method type parameter in a method body') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let body = parse('def foo!(T) { T }')

      type_checker.check_module(module: module, ast: body)

      try assert_true(type_checker.diagnostics.errors?)
    }

    g.test('Referring to a type in a method body') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let ary_type = ClassType.new('Array')
      let body = parse('def foo { Array }')
      let meth_node = body.children[0] as DefineMethod
      let const_node = meth_node.body.children[0] as Constant

      module.define_constant(name: ary_type.name, type: ary_type)
      type_checker.check_module(module: module, ast: body)

      try assert_false(type_checker.diagnostics.errors?)
      try assert_same_object(const_node.resolved_type.get, ary_type)
    }

    g.test('Referring to a generic type using type arguments in a method body') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let foo_type = ClassType.new('Foo')
      let ary_type = ClassType.new('Array')
      let ary_param = TypeParameterType.new('T')

      ary_type.type_parameters.define(name: ary_param.name, type: ary_param)

      let body = parse('def foo { Array!(Foo) }')
      let meth_node = body.children[0] as DefineMethod
      let const_node = meth_node.body.children[0] as Constant

      module.define_constant(name: ary_type.name, type: ary_type)
      module.define_constant(name: foo_type.name, type: foo_type)
      type_checker.check_module(module: module, ast: body)

      let const_type = const_node.resolved_type.get

      try assert_false(type_checker.diagnostics.errors?)
      try assert_object_instance(const_type, ary_type)
      try assert_object_instance(
        const_type.lookup_type_parameter_type(ary_param).get,
        foo_type
      )
    }
  }

  t.group('Type-checking constant definitions') do (g) {
    g.test('Defining a constant') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let body = parse('let A = 10')

      type_checker.check_module(module: module, ast: body)

      let type = module.constants['A'].type

      try assert_false(type_checker.diagnostics.errors?)
      try assert_object_instance(type, type_checker.builtins.integer_type)
    }

    g.test('Defining an already defined constant') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let body = parse('let A = 10')

      module.define_constant(
        name: 'A',
        type: ClassInstance.new(type_checker.builtins.float_type)
      )

      type_checker.check_module(module: module, ast: body)

      let type = module.constants['A'].type

      try assert_true(type_checker.diagnostics.errors?)
      try assert_object_instance(type, type_checker.builtins.float_type)
    }

    g.test('Defining a constant with the same name as an imported constant') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let body = parse('let A = 10')

      module.globals.define(
        name: 'A',
        type: ClassInstance.new(type_checker.builtins.float_type)
      )

      type_checker.check_module(module: module, ast: body)

      try assert_true(type_checker.diagnostics.errors?)
      try assert_true(module.constants.get('A').none?)

      try assert_object_instance(
        module.globals['A'].type,
        type_checker.builtins.float_type
      )
    }
  }

  t.group('Type-checking trait implementations') do (g) {
    g.test('Implementing a trait') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let trait_type = TraitType.new('ToString')
      let obj_type = ClassType.new('Number')

      module.define_constant(name: trait_type.name, type: trait_type)
      module.define_constant(name: obj_type.name, type: obj_type)

      let node = parse('impl ToString for Number {}')
      let impl_node = node.children[0] as ImplementTrait

      type_checker.check_module(module: module, ast: node)

      let implementation = obj_type.implemented_traits[trait_type]

      try assert_instance_of(impl_node.class_name.resolved_type.get, ClassType)
      try assert_instance_of(impl_node.trait_name.resolved_type.get, TraitInstance)

      try assert_same_object(impl_node.class_name.resolved_type.get, obj_type)
      try assert_true(
        (impl_node.trait_name.resolved_type.get as TraitInstance)
          .instance_of == trait_type
      )

      try assert_equal(implementation.type.instance_of, trait_type)
      try assert_true(implementation.bounds.empty?)
      try assert_false(type_checker.diagnostics.errors?)
    }

    g.test('Implementing a trait with type parameter bounds') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let trait_type = TraitType.new('ToString')
      let obj_type = ClassType.new('Number')
      let type_param = TypeParameterType.new('A')

      obj_type.type_parameters.define(name: 'A', type: type_param)

      module.define_constant(name: trait_type.name, type: trait_type)
      module.define_constant(name: obj_type.name, type: obj_type)

      let node = parse('impl ToString for Number when A: ToString {}')

      type_checker.check_module(module: module, ast: node)

      let implementation = obj_type.implemented_traits[trait_type]
      let bounds = implementation.bounds[type_param]

      try assert_equal(bounds.length, 1)
      try assert_equal(bounds[0].instance_of, trait_type)
    }

    g.test('Implementing a trait with duplicate type parameter bounds') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let trait_type = TraitType.new('ToString')
      let obj_type = ClassType.new('Number')
      let type_param = TypeParameterType.new('A')

      obj_type.type_parameters.define(name: 'A', type: type_param)

      module.define_constant(name: trait_type.name, type: trait_type)
      module.define_constant(name: obj_type.name, type: obj_type)

      let node =
        parse('impl ToString for Number when A: ToString, A: ToString {}')

      type_checker.check_module(module: module, ast: node)

      try assert_true(type_checker.diagnostics.errors?)
      try assert_true(obj_type.implemented_traits.empty?)
    }

    g.test('Implementing a trait with type parameter bounds and a custom method') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let trait_type = TraitType.new('ToString')
      let obj_type = ClassType.new('Number')
      let type_param = TypeParameterType.new('A')

      obj_type.type_parameters.define(name: 'A', type: type_param)

      module.define_constant(name: trait_type.name, type: trait_type)
      module.define_constant(name: obj_type.name, type: obj_type)

      let node = parse('impl ToString for Number when A: ToString { def foo {} }')

      type_checker.check_module(module: module, ast: node)

      let method = obj_type.instance_methods['foo'].type
      let bounds = method.type_parameter_bounds[type_param]

      try assert_equal(bounds.length, 1)
      try assert_equal(bounds[0].instance_of, trait_type)
    }

    g.test('Implementing a trait with type parameter bounds and a default method') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let trait_type = TraitType.new('ToString')
      let obj_type = ClassType.new('Number')
      let type_param = TypeParameterType.new('A')
      let foo = MethodType.new(name: 'foo', layout: BlockLayout.new(NeverType.new))

      obj_type.type_parameters.define(name: 'A', type: type_param)
      trait_type.default_methods.define(name: 'foo', type: foo)

      module.define_constant(name: trait_type.name, type: trait_type)
      module.define_constant(name: obj_type.name, type: obj_type)

      let node = parse('impl ToString for Number when A: ToString {}')

      type_checker.check_module(module: module, ast: node)

      let method = obj_type.instance_methods['foo'].type

      try assert_true(method.type_parameter_bounds.empty?)
    }

    g.test('Implementing a non-existing trait') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let obj_type = ClassType.new('Number')

      module.define_constant(name: obj_type.name, type: obj_type)

      let node = parse('impl ToString for Number {}')
      let impl_node = node.children[0] as ImplementTrait

      type_checker.check_module(module: module, ast: node)

      try assert_true(type_checker.diagnostics.errors?)
      try assert_true(impl_node.trait_name.resolved_type.get.error?)
      try assert_true(obj_type.implemented_traits.empty?)
    }

    g.test('Implementing a trait for a non-existing object') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let trait_type = TraitType.new('ToString')

      module.define_constant(name: trait_type.name, type: trait_type)

      let node = parse('impl ToString for Number {}')
      let impl_node = node.children[0] as ImplementTrait

      type_checker.check_module(module: module, ast: node)

      try assert_true(type_checker.diagnostics.errors?)
      try assert_true(impl_node.class_name.resolved_type.get.error?)
      try assert_true(impl_node.trait_name.resolved_type.none?)
    }

    g.test('Implementing a trait with type parameter bounds for a non-generic object') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let trait_type = TraitType.new('ToString')
      let obj_type = ClassType.new('Number')

      module.define_constant(name: trait_type.name, type: trait_type)
      module.define_constant(name: obj_type.name, type: obj_type)

      let node = parse('impl ToString for Number when A: ToString {}')

      type_checker.check_module(module: module, ast: node)

      try assert_true(type_checker.diagnostics.errors?)
      try assert_true(obj_type.implemented_traits.empty?)
    }

    g.test('Implementing a trait with invalid bounds requirements') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let trait_type = TraitType.new('ToString')
      let obj_type = ClassType.new('Number')
      let type_param = TypeParameterType.new('A')

      obj_type.type_parameters.define(name: 'A', type: type_param)

      module.define_constant(name: trait_type.name, type: trait_type)
      module.define_constant(name: obj_type.name, type: obj_type)

      let node = parse('impl ToString for Number when A: Kittens {}')

      type_checker.check_module(module: module, ast: node)

      try assert_true(type_checker.diagnostics.errors?)
      try assert_true(obj_type.implemented_traits.empty?)
    }

    g.test('Defining a method with bounds that overwrite the bounds of a trait implementation') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let trait1 = TraitType.new('ToString')
      let trait2 = TraitType.new('ToInt')
      let obj_type = ClassType.new('A')
      let type_param = TypeParameterType.new('T')

      obj_type.type_parameters.define(name: type_param.name, type: type_param)

      module.define_constant(name: trait1.name, type: trait1)
      module.define_constant(name: trait2.name, type: trait2)
      module.define_constant(name: obj_type.name, type: obj_type)

      let node = parse(
        'impl ToString for A when T: ToString { def foo when T: ToInt {} }'
      )

      type_checker.check_module(module: module, ast: node)

      let method = obj_type.instance_methods['foo'].type
      let bounds = method.type_parameter_bounds[type_param]

      try assert_true(type_checker.diagnostics.errors?)
      try assert_equal(bounds.length, 1)
      try assert_equal(bounds[0].instance_of, trait1)
    }

    g.test('Implementing a generic trait without the required type arguments') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let trait_type = TraitType.new('Add')
      let obj_type = ClassType.new('Int')
      let type_param = TypeParameterType.new('A')

      trait_type.type_parameters.define(name: type_param.name, type: type_param)

      module.define_constant(name: trait_type.name, type: trait_type)
      module.define_constant(name: obj_type.name, type: obj_type)

      let node = parse('impl Add for Int {}')

      type_checker.check_module(module: module, ast: node)

      try assert_true(type_checker.diagnostics.errors?)
      try assert_true(obj_type.implemented_traits.empty?)
    }

    g.test('Implementing a trait with unmet requirements') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let trait_type = TraitType.new('Add')
      let obj_type = ClassType.new('Int')
      let method_type =
        MethodType.new(name: '+', layout: BlockLayout.new(NeverType.new))

      trait_type.required_methods.define(name: '+', type: method_type)

      module.define_constant(name: trait_type.name, type: trait_type)
      module.define_constant(name: obj_type.name, type: obj_type)

      let node = parse('impl Add for Int {}')

      type_checker.check_module(module: module, ast: node)

      try assert_true(type_checker.diagnostics.errors?)
      try assert_true(obj_type.implemented_traits.empty?)
    }

    g.test('Implementing a trait with an unimplemented dependency') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let obj_type = ClassType.new('Int')
      let trait1 = TraitType.new('Sub')
      let trait2 = TraitType
        .new(name: 'Add', required_traits: Array.new(TraitInstance.new(trait1)))

      module.define_constant(name: trait1.name, type: trait1)
      module.define_constant(name: trait2.name, type: trait2)
      module.define_constant(name: obj_type.name, type: obj_type)

      let node = parse('impl Add for Int {}')

      type_checker.check_module(module: module, ast: node)

      try assert_true(type_checker.diagnostics.errors?)
      try assert_true(obj_type.implemented_traits.empty?)
    }

    g.test('Implementing a trait with all requirements met') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let trait_type = TraitType.new('Add')
      let obj_type = ClassType.new('Int')
      let method_type = MethodType.new(
        name: '+',
        layout: BlockLayout.new(type_checker.builtins.nil_type.new_instance)
      )

      trait_type.required_methods.define(name: '+', type: method_type)

      module.define_constant(name: trait_type.name, type: trait_type)
      module.define_constant(name: obj_type.name, type: obj_type)

      let node = parse('impl Add for Int { def + {} }')

      type_checker.check_module(module: module, ast: node)

      let implementation = obj_type.implemented_traits[trait_type]

      try assert_false(type_checker.diagnostics.errors?)
      try assert_false(obj_type.implemented_traits.empty?)
      try assert_equal(implementation.type.instance_of, trait_type)
    }

    g.test('Implementing a trait with all dependencies implemented') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let obj_type = ClassType.new('Int')
      let trait1 = TraitType.new('Sub')
      let trait2 = TraitType
        .new(name: 'Add', required_traits: Array.new(TraitInstance.new(trait1)))

      module.define_constant(name: trait1.name, type: trait1)
      module.define_constant(name: trait2.name, type: trait2)
      module.define_constant(name: obj_type.name, type: obj_type)

      let node = parse('impl Sub for Int {} impl Add for Int {}')

      type_checker.check_module(module: module, ast: node)

      let implementation = obj_type.implemented_traits[trait2]

      try assert_false(type_checker.diagnostics.errors?)
      try assert_false(obj_type.implemented_traits.empty?)
      try assert_equal(implementation.type.instance_of, trait2)
    }

    g.test('Implementing a trait that implements a required method incorrectly') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let trait_type = TraitType.new('Add')
      let obj_type = ClassType.new('Int')
      let plus = MethodType.new(
        name: '+',
        layout: BlockLayout.new(type_checker.builtins.nil_type.new_instance)
      )

      plus.define_required_argument(
        name: 'a',
        type: type_checker.builtins.integer_type.new_instance
      )

      trait_type.required_methods.define(name: '+', type: plus)

      module.define_constant(name: trait_type.name, type: trait_type)
      module.define_constant(name: obj_type.name, type: obj_type)

      let node = parse('impl Add for Int { def + {} }')

      type_checker.check_module(module: module, ast: node)

      try assert_true(type_checker.diagnostics.errors?)
      try assert_true(obj_type.implemented_traits.empty?)
    }

    g.test('Implementing a trait that provides default methods') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let trait_type = TraitType.new('Add')
      let obj_type = ClassType.new('Int')
      let plus = MethodType.new(name: '+', layout: BlockLayout.new(NeverType.new))

      trait_type.default_methods.define(name: '+', type: plus)

      module.define_constant(name: trait_type.name, type: trait_type)
      module.define_constant(name: obj_type.name, type: obj_type)

      let node = parse('impl Add for Int {}')

      type_checker.check_module(module: module, ast: node)

      try assert_same_object(obj_type.instance_methods['+'].type, plus)
    }

    g.test('Redefining a default method') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let trait_type = TraitType.new('Add')
      let obj_type = ClassType.new('Int')
      let plus = MethodType.new(
        name: '+',
        layout: BlockLayout.new(type_checker.builtins.nil_type.new_instance)
      )

      trait_type.default_methods.define(name: '+', type: plus)

      module.define_constant(name: trait_type.name, type: trait_type)
      module.define_constant(name: obj_type.name, type: obj_type)

      let node = parse('impl Add for Int { def + {} }')

      type_checker.check_module(module: module, ast: node)

      let custom_plus = obj_type.instance_methods['+'].type

      try assert_false(type_checker.diagnostics.errors?)
      try assert_false(custom_plus.same_object?(plus))
    }

    g.test('Incorrectly redefining a default method') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let trait_type = TraitType.new('Add')
      let obj_type = ClassType.new('Int')
      let plus = MethodType.new(
        name: '+',
        layout: BlockLayout.new(type_checker.builtins.integer_type.new_instance)
      )

      trait_type.default_methods.define(name: '+', type: plus)

      module.define_constant(name: trait_type.name, type: trait_type)
      module.define_constant(name: obj_type.name, type: obj_type)
      module
        .define_constant(name: 'NilType', type: type_checker.builtins.nil_type)

      let node = parse('impl Add for Int { def +(a: Int) {} }')

      type_checker.check_module(module: module, ast: node)

      try assert_true(type_checker.diagnostics.errors?)
      try assert_true(obj_type.implemented_traits.empty?)
    }

    g.test('Implementing a trait that requires a method that is already implemented') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let trait_type = TraitType.new('Add')
      let obj_type = ClassType.new('Int')
      let trait_plus = MethodType.new(
        name: '+',
        layout: BlockLayout.new(type_checker.builtins.nil_type.new_instance)
      )

      let obj_plus = MethodType.new(
        name: '+',
        layout: BlockLayout.new(type_checker.builtins.nil_type.new_instance)
      )

      trait_type.required_methods.define(name: '+', type: trait_plus)
      obj_type.instance_methods.define(name: '+', type: obj_plus)

      module.define_constant(name: trait_type.name, type: trait_type)
      module.define_constant(name: obj_type.name, type: obj_type)

      let node = parse('impl Add for Int { def + {} }')

      type_checker.check_module(module: module, ast: node)

      try assert_true(type_checker.diagnostics.errors?)
      try assert_true(obj_type.implemented_traits.empty?)
      try assert_same_object(obj_type.instance_methods['+'].type, obj_plus)
    }

    g.test('Implementing a trait with a default method compatible with an existing method') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let trait_type = TraitType.new('Add')
      let obj_type = ClassType.new('Int')
      let trait_plus =
        MethodType.new(name: '+', layout: BlockLayout.new(AnyType.new))

      let obj_plus =
        MethodType.new(name: '+', layout: BlockLayout.new(AnyType.new))

      trait_type.default_methods.define(name: '+', type: trait_plus)
      obj_type.instance_methods.define(name: '+', type: obj_plus)

      module.define_constant(name: trait_type.name, type: trait_type)
      module.define_constant(name: obj_type.name, type: obj_type)

      let node = parse('impl Add for Int {}')

      type_checker.check_module(module: module, ast: node)

      try assert_false(type_checker.diagnostics.errors?)
      try assert_false(obj_type.implemented_traits.empty?)
      try assert_same_object(obj_type.instance_methods['+'].type, obj_plus)
    }

    g.test('Implementing a trait with a default method incompatible with an existing method') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let trait_type = TraitType.new('Add')
      let obj_type = ClassType.new('Int')
      let trait_plus =
        MethodType.new(name: '+', layout: BlockLayout.new(NeverType.new))

      let obj_plus =
        MethodType.new(name: '+', layout: BlockLayout.new(obj_type.new_instance))

      trait_type.default_methods.define(name: '+', type: trait_plus)
      obj_type.instance_methods.define(name: '+', type: obj_plus)

      module.define_constant(name: trait_type.name, type: trait_type)
      module.define_constant(name: obj_type.name, type: obj_type)

      let node = parse('impl Add for Int {}')

      type_checker.check_module(module: module, ast: node)

      try assert_true(type_checker.diagnostics.errors?)
      try assert_true(obj_type.implemented_traits.empty?)
      try assert_same_object(obj_type.instance_methods['+'].type, obj_plus)
    }

    g.test('Defining a method with an argument depending on a required method') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let trait_type = TraitType.new('Add')
      let obj_type = ClassType.new('Bla')
      let foo = MethodType.new(
        name: 'foo',
        layout: BlockLayout.new(type_checker.builtins.integer_type.new_instance)
      )

      trait_type.required_methods.define(name: foo.name, type: foo)

      module.define_constant(name: trait_type.name, type: trait_type)
      module.define_constant(name: obj_type.name, type: obj_type)
      module
        .define_constant(name: 'Int', type: type_checker.builtins.integer_type)

      let node = parse(
        'impl Add for Bla { def foo -> Int { 10 } def bar(a = foo) {} }'
      )

      type_checker.check_module(module: module, ast: node)

      let bar = obj_type.instance_methods['bar'].type

      try assert_false(type_checker.diagnostics.errors?)
      try assert_object_instance(
        bar.arguments['a'].type,
        type_checker.builtins.integer_type
      )
    }

    g.test('Defining a method with an argument depending on a default method') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let trait_type = TraitType.new('Add')
      let obj_type = ClassType.new('Int')
      let foo = MethodType.new(
        name: 'foo',
        layout: BlockLayout.new(type_checker.builtins.nil_singleton)
      )

      foo.return_type = type_checker.builtins.integer_type.new_instance

      trait_type.default_methods.define(name: 'foo', type: foo)

      module.define_constant(name: trait_type.name, type: trait_type)
      module.define_constant(name: obj_type.name, type: obj_type)

      let node = parse('impl Add for Int { def bar(a = foo) {} }')

      type_checker.check_module(module: module, ast: node)

      let bar = obj_type.instance_methods['bar'].type

      try assert_false(type_checker.diagnostics.errors?)
      try assert_same_object(obj_type.instance_methods['foo'].type, foo)
      try assert_object_instance(
        bar.arguments['a'].type,
        type_checker.builtins.integer_type
      )
    }

    g.test('Defining a method with an argument depending on the "self" type') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let trait_type = TraitType.new('Add')
      let obj_type = ClassType.new('Int')
      let foo = MethodType.new(
        name: 'foo',
        layout: BlockLayout.new(type_checker.builtins.nil_singleton)
      )

      foo.return_type = type_checker.builtins.integer_type.new_instance

      trait_type.default_methods.define(name: 'foo', type: foo)

      module.define_constant(name: trait_type.name, type: trait_type)
      module.define_constant(name: obj_type.name, type: obj_type)

      let node = parse('impl Add for Int { def bar(a = self) {} }')

      type_checker.check_module(module: module, ast: node)

      let bar = obj_type.instance_methods['bar'].type

      try assert_false(type_checker.diagnostics.errors?)
      try assert_same_object(obj_type.instance_methods['foo'].type, foo)
      try assert_object_instance(bar.arguments['a'].type, obj_type)
    }

    g.test('Redefining a static method') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let trait_type = TraitType.new('Add')
      let obj_type = ClassType.new('Int')
      let foo = MethodType.new(name: 'foo', static_method: True)

      obj_type.static_methods.define(name: 'foo', type: foo)

      module.define_constant(name: trait_type.name, type: trait_type)
      module.define_constant(name: obj_type.name, type: obj_type)

      let node = parse('impl Add for Int { def foo {} }')

      type_checker.check_module(module: module, ast: node)

      try assert_true(type_checker.diagnostics.errors?)
      try assert_same_object(obj_type.static_methods['foo'].type, foo)
      try assert_true(obj_type.instance_methods.empty?)
      try assert_true(obj_type.implemented_traits.empty?)
    }
  }

  t.group('Type-checking reopened types') do (g) {
    g.test('Reopening a non-existing type') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let node = parse('impl A {}')

      type_checker.check_module(module: module, ast: node)

      try assert_true(type_checker.diagnostics.errors?)
    }

    g.test('Reopening a trait') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let trait_type = TraitType.new('Add')
      let node = parse('impl A {}')

      module.define_constant(name: trait_type.name, type: trait_type)

      type_checker.check_module(module: module, ast: node)

      try assert_true(type_checker.diagnostics.errors?)
    }

    g.test('Reopening the instance of an object') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let obj_type = ClassType.new('String')
      let node = parse('impl A {}')

      module.define_constant(name: 'A', type: obj_type.new_instance)

      type_checker.check_module(module: module, ast: node)

      try assert_true(type_checker.diagnostics.errors?)
    }

    g.test('Reopening a module') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let node = parse('impl A {}')

      module.define_constant(name: 'A', type: module)

      type_checker.check_module(module: module, ast: node)

      try assert_true(type_checker.diagnostics.errors?)
    }

    g.test('Defining an instance method when reopening an object') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let a_type = ClassType.new('A')
      let node = parse('impl A { def foo {} }')

      module.define_constant(name: a_type.name, type: a_type)

      type_checker.check_module(module: module, ast: node)

      try assert_false(type_checker.diagnostics.errors?)
      try assert_false(a_type.instance_methods.get('foo').none?)
    }

    g.test('Defining a static method when reopening an object') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let a_type = ClassType.new('A')
      let node = parse('impl A { static def foo {} }')

      module.define_constant(name: a_type.name, type: a_type)

      type_checker.check_module(module: module, ast: node)

      try assert_false(type_checker.diagnostics.errors?)
      try assert_false(a_type.static_methods.get('foo').none?)
    }

    g.test('Defining an existing instance method when reopening an object') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let a_type = ClassType.new('A')
      let foo_method = MethodType.new(
        name: 'foo',
        layout: BlockLayout.new(type_checker.builtins.nil_singleton)
      )

      let node = parse('impl A { def foo {} }')

      module.define_constant(name: a_type.name, type: a_type)
      a_type.instance_methods.define(name: foo_method.name, type: foo_method)

      type_checker.check_module(module: module, ast: node)

      try assert_false(type_checker.diagnostics.errors?)
      try assert_false(a_type.instance_methods['foo'].type.same_object?(foo_method))
    }

    g.test('Defining an existing static method when reopening an object') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let a_type = ClassType.new('A')
      let foo_method =
        MethodType.new(name: 'foo', layout: BlockLayout.new(NeverType.new))

      let node = parse('impl A { static def foo {} }')

      module.define_constant(name: a_type.name, type: a_type)
      a_type.static_methods.define(name: foo_method.name, type: foo_method)

      type_checker.check_module(module: module, ast: node)

      try assert_true(type_checker.diagnostics.errors?)
      try assert_same_object(a_type.static_methods['foo'].type, foo_method)
    }
  }

  t.group('Type-checking identifier references') do (g) {
    g.test('Referring to an undefined identifier') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let body = parse('foo')
      let node = body.children[0] as Identifier

      type_checker.check_module(module: module, ast: body)

      try assert_true(type_checker.diagnostics.errors?)
      try assert_true(node.resolved_type.get.error?)
      try assert_true(node.symbol.none?)
    }

    g.test('Referring to a defined local variable') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let body = parse('foo')
      let node = body.children[0] as Identifier

      body
        .variable_scope
        .symbols
        .define(name: 'foo', type: type_checker.builtins.integer_type.new_instance)

      type_checker.check_module(module: module, ast: body)

      try assert_false(type_checker.diagnostics.errors?)

      try assert_object_instance(
        node.resolved_type.get,
        type_checker.builtins.integer_type
      )

      try assert_same_object(node.symbol.get.type, node.resolved_type.get)
    }

    g.test('Referring to an imported module') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let body = parse('foo')
      let node = body.children[0] as Identifier

      module
        .globals
        .define(name: 'foo', type: type_checker.builtins.integer_type.new_instance)

      type_checker.check_module(module: module, ast: body)

      try assert_false(type_checker.diagnostics.errors?)

      try assert_object_instance(
        node.resolved_type.get,
        type_checker.builtins.integer_type
      )

      try assert_same_object(node.symbol.get.type, node.resolved_type.get)
    }
  }

  t.group('Type-checking method calls without explicit receivers') do (g) {
    g.test('Sending a message to "self"') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let body = parse('foo')
      let node = body.children[0] as Identifier
      let type = MethodType.new(
        name: 'foo',
        layout: BlockLayout.new(type_checker.builtins.integer_type.new_instance)
      )

      module.define_method(name: type.name, type: type)
      type_checker.check_module(module: module, ast: body)

      try assert_false(type_checker.diagnostics.errors?)
      try assert_object_instance(
        node.resolved_type.get,
        type_checker.builtins.integer_type
      )

      try assert_instance_of(node.symbol.get.type, MethodType)
    }

    g.test('Sending a message to "self" that throws an unhandled error') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let body = parse('foo')
      let node = body.children[0] as Identifier
      let int_type = type_checker.builtins.integer_type
      let type = MethodType.new(
        name: 'foo',
        layout: BlockLayout.new(
          return_type: int_type.new_instance,
          throw_type: Option.some(int_type.new_instance)
        )
      )

      module.define_method(name: type.name, type: type)

      type_checker.check_module(module: module, ast: body)

      try assert_true(type_checker.diagnostics.errors?)
      try assert_object_instance(node.resolved_type.get, int_type)
    }

    g.test('Sending a message to "self" with parentheses that throws an unhandled error') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let body = parse('foo()')
      let node = body.children[0] as Identifier
      let int_type = type_checker.builtins.integer_type
      let type = MethodType.new(
        name: 'foo',
        layout: BlockLayout.new(
          return_type: int_type.new_instance,
          throw_type: Option.some(int_type.new_instance)
        )
      )

      module.define_method(name: type.name, type: type)

      type_checker.check_module(module: module, ast: body)

      try assert_true(type_checker.diagnostics.errors?)
      try assert_object_instance(node.resolved_type.get, int_type)
    }

    g.test('Calling a defined module method') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let body = parse('foo')
      let node = body.children[0] as Identifier
      let type = MethodType.new(
        name: 'foo',
        layout: BlockLayout.new(type_checker.builtins.integer_type.new_instance)
      )

      module.define_method(name: type.name, type: type)
      type_checker.check_module(module: module, ast: body)

      try assert_false(type_checker.diagnostics.errors?)
      try assert_object_instance(
        node.resolved_type.get,
        type_checker.builtins.integer_type
      )
    }

    g.test('Calling an imported module method') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let body = parse('foo')
      let node = body.children[0] as Identifier
      let type = MethodType.new(
        name: 'foo',
        layout: BlockLayout.new(type_checker.builtins.integer_type.new_instance)
      )

      module.globals.define(name: type.name, type: type)
      type_checker.check_module(module: module, ast: body)

      try assert_false(type_checker.diagnostics.errors?)
      try assert_object_instance(
        node.resolved_type.get,
        type_checker.builtins.integer_type
      )
    }

    g.test('Calling a module method that returns Self in a generic type') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let body = parse('foo')
      let node = body.children[0] as Identifier
      let rtype =
        type_checker.builtins.array_type.new_instance(Array.new(SelfType.new))

      let method = MethodType.new(name: 'foo', layout: BlockLayout.new(rtype))

      module.define_method(name: method.name, type: method)
      type_checker.check_module(module: module, ast: body)

      try assert_false(type_checker.diagnostics.errors?)

      let type = node.resolved_type.get as ClassInstance
      let param = type_checker
        .builtins
        .array_type
        .lookup_type_parameter(ARRAY_TYPE_PARAMETER)
        .get
        .type

      try assert_object_instance(type, type_checker.builtins.array_type)
      try assert_same_object(type.type_parameter_types[param], module)
    }
  }

  t.group('Type-checking global references using ::') do (g) {
    g.test('Referring to a global variable') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let body = parse('::Foo')
      let node = body.children[0] as Global

      module.define_constant(
        name: 'Foo',
        type: type_checker.builtins.integer_type.new_instance
      )

      type_checker.check_module(module: module, ast: body)

      try assert_false(type_checker.diagnostics.errors?)

      try assert_object_instance(
        node.resolved_type.get,
        type_checker.builtins.integer_type
      )

      try assert_same_object(node.symbol.get.type, node.resolved_type.get)
    }

    g.test('Referring to an imported global variable') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let body = parse('::foo')
      let node = body.children[0] as Global

      module
        .globals
        .define(name: 'foo', type: type_checker.builtins.integer_type.new_instance)

      type_checker.check_module(module: module, ast: body)

      try assert_false(type_checker.diagnostics.errors?)

      try assert_object_instance(
        node.resolved_type.get,
        type_checker.builtins.integer_type
      )

      try assert_same_object(node.symbol.get.type, node.resolved_type.get)
    }

    g.test('Calling a module method with no arguments using ::') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let body = parse('::foo')
      let node = body.children[0] as Global
      let type = MethodType.new(
        name: 'foo',
        layout: BlockLayout.new(type_checker.builtins.integer_type.new_instance)
      )

      module.define_method(name: type.name, type: type)
      type_checker.check_module(module: module, ast: body)

      try assert_false(type_checker.diagnostics.errors?)
      try assert_object_instance(
        node.resolved_type.get,
        type_checker.builtins.integer_type
      )
    }

    g.test('Calling an imported module method with no arguments using ::') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let body = parse('::foo')
      let node = body.children[0] as Global
      let type = MethodType.new(
        name: 'foo',
        layout: BlockLayout.new(type_checker.builtins.integer_type.new_instance)
      )

      module.globals.define(name: type.name, type: type)
      type_checker.check_module(module: module, ast: body)

      try assert_false(type_checker.diagnostics.errors?)
      try assert_object_instance(
        node.resolved_type.get,
        type_checker.builtins.integer_type
      )
    }

    g.test('Calling an imported module method that throws an unhandled error') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let int_type = type_checker.builtins.integer_type
      let body = parse('::foo')
      let layout = BlockLayout.new(
        return_type: int_type.new_instance,
        throw_type: Option.some(int_type.new_instance)
      )

      let type = MethodType.new(name: 'foo', layout: layout)

      module.globals.define(name: type.name, type: type)
      type_checker.check_module(module: module, ast: body)

      try assert_true(type_checker.diagnostics.errors?)
    }
  }

  t.group('Type-checking constants defined by the compiler') do (g) {
    g.test('Referencing the ThisModule global') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let body = parse('ThisModule')
      let node = body.children[0]

      type_checker.check_module(module: module, ast: body)

      try assert_false(type_checker.diagnostics.errors?)
      try assert_same_object(node.resolved_type.get, module)
    }
  }

  t.group('Type-checking variable reassignments') do (g) {
    g.test('Reassigning an existing local variable with the same type') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let body = parse('foo = 10')
      let node = body.children[0] as AssignLocal
      let int_type = type_checker.builtins.integer_type

      body
        .variable_scope
        .symbols
        .define(name: 'foo', type: int_type.new_instance, mutable: True)

      type_checker.check_module(module: module, ast: body)

      try assert_false(type_checker.diagnostics.errors?)
      try assert_object_instance(node.resolved_type.get, int_type)
    }

    g.test('Reassigning an existing attribute with the same type') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let body = parse('impl A { def foo(arg = @a = 10) {} }')

      let impl_node = body.children[0] as ReopenObject
      let meth_node = impl_node.body.children[0] as DefineMethod
      let arg_node = meth_node.arguments[0] as DefineOptionalArgument
      let assign_node = arg_node.default_value as AssignAttribute

      let obj_type = ClassType.new(name: 'A')
      let int_type = type_checker.builtins.integer_type

      let attr =
        obj_type.define_attribute(name: '@a', type: int_type.new_instance)

      module.define_constant(name: obj_type.name, type: obj_type)
      type_checker.check_module(module: module, ast: body)

      let method = obj_type.instance_methods['foo'].type

      try assert_false(type_checker.diagnostics.errors?)
      try assert_same_object(assign_node.symbol.get, attr)
      try assert_object_instance(method.arguments['arg'].type, int_type)
    }

    g.test('Reassigning an existing local variable with a different compatible type') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let body = parse('foo = 10')
      let node = body.children[0] as AssignLocal
      let int_type = type_checker.builtins.integer_type
      let initial_type = AnyType.new

      let lvar = body
        .variable_scope
        .symbols
        .define(name: 'foo', type: initial_type, mutable: True)

      type_checker.check_module(module: module, ast: body)

      try assert_false(type_checker.diagnostics.errors?)
      try assert_same_object(body.variable_scope.symbols['foo'].type, initial_type)
      try assert_true(node.symbol.get.same_object?(lvar))
      try assert_object_instance(node.resolved_type.get, int_type)
    }

    g.test('Reassigning an existing local variable with an incompatible type') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let body = parse('foo = 10.5')
      let node = body.children[0] as AssignLocal
      let int_type = type_checker.builtins.integer_type
      let float_type = type_checker.builtins.float_type

      body
        .variable_scope
        .symbols
        .define(name: 'foo', type: int_type.new_instance, mutable: True)

      type_checker.check_module(module: module, ast: body)

      try assert_true(type_checker.diagnostics.errors?)

      # The expression itself returns a Float, but the existing variable
      # definition is not altered.
      try assert_object_instance(node.resolved_type.get, float_type)
      try assert_object_instance(body.variable_scope.symbols['foo'].type, int_type)
    }

    g.test('Reassigning an immutable local variable') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let body = parse('foo = 10')
      let node = body.children[0] as AssignLocal

      body
        .variable_scope
        .symbols
        .define(name: 'foo', type: type_checker.builtins.integer_type.new_instance)

      type_checker.check_module(module: module, ast: body)

      try assert_true(type_checker.diagnostics.errors?)
      try assert_object_instance(
        node.resolved_type.get,
        type_checker.builtins.integer_type
      )
    }

    g.test('Reassigning an undefined local variable') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let body = parse('foo = 10')
      let node = body.children[0] as AssignLocal

      type_checker.check_module(module: module, ast: body)

      try assert_true(type_checker.diagnostics.errors?)
      try assert_true(body.variable_scope.symbols.get('foo').none?)
      try assert_true(node.symbol.none?)
      try assert_object_instance(
        node.resolved_type.get,
        type_checker.builtins.integer_type
      )
    }

    g.test('Reassigning an undefined attribute') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let body = parse('impl A { def foo(arg = @a = 10) {} }')

      let impl_node = body.children[0] as ReopenObject
      let meth_node = impl_node.body.children[0] as DefineMethod
      let arg_node = meth_node.arguments[0] as DefineOptionalArgument
      let assign_node = arg_node.default_value as AssignAttribute

      let obj_type = ClassType.new(name: 'A')
      let int_type = type_checker.builtins.integer_type

      module.define_constant(name: obj_type.name, obj_type)

      type_checker.check_module(module: module, ast: body)

      let method = obj_type.instance_methods['foo'].type

      try assert_true(type_checker.diagnostics.errors?)
      try assert_true(assign_node.symbol.none?)
      try assert_object_instance(method.arguments['arg'].type, int_type)
    }
  }

  t.group('Type-checking attribute references') do (g) {
    g.test('Referring to a defined attribute') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let body = parse('impl A { def foo(arg = @a) {} }')

      let impl_node = body.children[0] as ReopenObject
      let meth_node = impl_node.body.children[0] as DefineMethod
      let arg_node = meth_node.arguments[0] as DefineOptionalArgument
      let attr_node = arg_node.default_value as Attribute

      let obj_type = ClassType.new(name: 'A')
      let int_type = type_checker.builtins.integer_type

      let attr =
        obj_type.define_attribute(name: '@a', type: int_type.new_instance)

      module.define_constant(name: obj_type.name, obj_type)

      type_checker.check_module(module: module, ast: body)

      try assert_false(type_checker.diagnostics.errors?)
      try assert_same_object(attr_node.symbol.get, attr)
      try assert_object_instance(attr_node.resolved_type.get, int_type)
    }

    g.test('Referring to an undefined attribute') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let body = parse('impl A { def foo(arg = @a) {} }')

      let impl_node = body.children[0] as ReopenObject
      let meth_node = impl_node.body.children[0] as DefineMethod
      let arg_node = meth_node.arguments[0] as DefineOptionalArgument
      let attr_node = arg_node.default_value as Attribute
      let obj_type = ClassType.new(name: 'A')

      module.define_constant(name: obj_type.name, obj_type)

      type_checker.check_module(module: module, ast: body)

      try assert_true(type_checker.diagnostics.errors?)
      try assert_true(attr_node.symbol.none?)
      try assert_true(attr_node.resolved_type.get.error?)
    }

    g.test('Referring to a type parameter attribute') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let body = parse('impl A { def foo { @a } }')
      let impl_node = body.children[0] as ReopenObject
      let meth_node = impl_node.body.children[0] as DefineMethod
      let attr_node = meth_node.body.children[0] as Attribute
      let obj_type = ClassType.new(name: 'A')
      let param = TypeParameterType.new('T')

      obj_type.type_parameters.define(name: param.name, type: param)
      obj_type.define_attribute(name: '@a', type: param)

      module.define_constant(name: obj_type.name, obj_type)
      type_checker.check_module(module: module, ast: body)

      let attr_type = attr_node.resolved_type.get

      try assert_false(type_checker.diagnostics.errors?)
      try assert_instance_of(attr_type, RigidTypeParameterType)
      try assert_same_object((attr_type as RigidTypeParameterType).type, param)
    }
  }

  t.group('Type-checking method returns') do (g) {
    g.test('Returning at the module-level, without a value') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let body = parse('return')

      type_checker.check_module(module: module, ast: body)

      try assert_true(type_checker.diagnostics.errors?)
    }

    g.test('Returning at the module-level, with a value') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let body = parse('return 10')

      type_checker.check_module(module: module, ast: body)

      try assert_true(type_checker.diagnostics.errors?)
    }

    g.test('Defining an argument with a return as the default value') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let body = parse('def foo(arg = return) {}')

      type_checker.check_module(module: module, ast: body)

      let method = body.children[0] as DefineMethod
      let arg = method.arguments[0]

      try assert_false(type_checker.diagnostics.errors?)
      try assert_instance_of(arg.resolved_type.get, NeverType)
    }

    g.test('Returning from a method without a value') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let body = parse('def foo { return }')
      let method_node = body.children[0] as DefineMethod
      let return_node = method_node.body.children[0] as Return

      type_checker.check_module(module: module, ast: body)

      try assert_false(type_checker.diagnostics.errors?)
      try assert_instance_of(return_node.resolved_type.get, NeverType)
    }

    g.test('Returning from a method with a valid value') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let int_type = type_checker.builtins.integer_type
      let body = parse('def foo -> Int { return 10 }')
      let method_node = body.children[0] as DefineMethod
      let return_node = method_node.body.children[0] as Return

      module.define_constant(name: 'Int', type: int_type)
      type_checker.check_module(module: module, ast: body)

      try assert_false(type_checker.diagnostics.errors?)
      try assert_instance_of(return_node.resolved_type.get, NeverType)
      try assert_object_instance(
        return_node.expression.get.resolved_type.get,
        int_type
      )
    }

    g.test('Returning from a method with an invalid value') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let int_type = type_checker.builtins.integer_type
      let body = parse('def foo { return 10 }')
      let method_node = body.children[0] as DefineMethod
      let return_node = method_node.body.children[0] as Return

      type_checker.check_module(module: module, ast: body)

      let method_type = method_node.resolved_type.get

      try assert_true(type_checker.diagnostics.errors?)
      try assert_instance_of(return_node.resolved_type.get, NeverType)
      try assert_object_instance(
        return_node.expression.get.resolved_type.get,
        int_type
      )
      try assert_object_instance(
        method_type.return_type,
        type_checker.builtins.nil_type
      )
    }

    g.test('Returning from a closure') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let body = parse('do { return }')

      type_checker.check_module(module: module, ast: body)

      let block = body.children[0].resolved_type.get as ClosureType

      try assert_true(type_checker.diagnostics.errors?)
      try assert_true(block.return_type.error?)
    }

    g.test('Returning from a lambda') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let int_type = type_checker.builtins.integer_type
      let body = parse('fn { return 10 }')

      type_checker.check_module(module: module, ast: body)

      let block = body.children[0].resolved_type.get as LambdaType

      try assert_false(type_checker.diagnostics.errors?)
      try assert_object_instance(block.return_type, int_type)
    }
  }

  t.group('Type-checking pattern-matching expressions') do (g) {
    g.test('Defining an empty match expression') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let body = parse('match {}')
      let node = body.children[0] as Match

      setup_match_types(type_checker: type_checker, module: module)
      type_checker.check_module(module: module, ast: body)

      try assert_true(type_checker.diagnostics.errors?)
      try assert_true(node.resolved_type.get.error?)
    }

    g.test('Defining a match without any patterns') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let body = parse('match 10 {}')
      let node = body.children[0] as Match

      setup_match_types(type_checker: type_checker, module: module)
      type_checker.check_module(module: module, ast: body)

      try assert_true(type_checker.diagnostics.errors?)
      try assert_true(node.resolved_type.get.error?)
    }

    g.test('Defining a match with only an "else" branch') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let body = parse('match 10 { else -> { 10 } }')
      let node = body.children[0] as Match

      setup_match_types(type_checker: type_checker, module: module)
      type_checker.check_module(module: module, ast: body)

      try assert_true(type_checker.diagnostics.errors?)
      try assert_true(node.resolved_type.get.error?)
    }

    g.test('Defining a non-exhaustive match') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let body = parse('match 10 { 10 -> { 10 } }')
      let node = body.children[0] as Match

      setup_match_types(type_checker: type_checker, module: module)
      type_checker.check_module(module: module, ast: body)

      try assert_true(type_checker.diagnostics.errors?)
      try assert_true(node.resolved_type.get.error?)
    }

    g.test('Defining a match when the Match trait does not exist') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let body = parse('match 10 { 10 -> { 10 } else -> { 20 } }')
      let node = body.children[0] as Match

      type_checker.check_module(module: module, ast: body)

      try assert_true(type_checker.diagnostics.errors?)
      try assert_true(node.resolved_type.get.error?)
    }

    g.test('Defining a match with an invalid expression case') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let body = parse('match 10.5 { 10.5 -> { 10 } else -> { 20 } }')
      let node = body.children[0] as Match

      setup_match_types(type_checker: type_checker, module: module)
      type_checker.check_module(module: module, ast: body)

      # In this test, Int does not implement std::operators::Match, and thus
      # can't be used in an expression case.
      try assert_true(type_checker.diagnostics.errors?)
      try assert_object_instance(
        node.resolved_type.get,
        type_checker.builtins.integer_type
      )
    }

    g.test('Defining a match with a valid expression case') {
      let type_checker = new_type_checker
      let int_type = type_checker.builtins.integer_type
      let module = new_module('foo')
      let body = parse('match 10 { 10 -> { 10 } else -> { 20 } }')
      let node = body.children[0] as Match
      let case = node.cases[0] as MatchExpressions

      setup_match_types(type_checker: type_checker, module: module)
      type_checker.check_module(module: module, ast: body)

      try assert_false(type_checker.diagnostics.errors?)
      try assert_object_instance(node.resolved_type.get, int_type)
      try assert_object_instance(case.resolved_type.get, int_type)
      try assert_object_instance(case.patterns[0].resolved_type.get, int_type)
      try assert_object_instance(node.else_branch.get.resolved_type.get, int_type)

      try assert_false(case.body.type_scope.none?)
      try assert_false(node.else_branch.get.body.type_scope.none?)
    }

    g.test('Defining a match with an expression case with two patterns') {
      let type_checker = new_type_checker
      let int_type = type_checker.builtins.integer_type
      let module = new_module('foo')
      let body = parse('match 10 { 10, 20 -> { 10 } else -> { 20 } }')
      let node = body.children[0] as Match
      let case = node.cases[0] as MatchExpressions

      setup_match_types(type_checker: type_checker, module: module)
      type_checker.check_module(module: module, ast: body)

      try assert_false(type_checker.diagnostics.errors?)
      try assert_object_instance(node.resolved_type.get, int_type)
      try assert_object_instance(case.resolved_type.get, int_type)
      try assert_object_instance(case.patterns[0].resolved_type.get, int_type)
      try assert_object_instance(case.patterns[1].resolved_type.get, int_type)
    }

    g.test('Defining a match with an expression guard') {
      let type_checker = new_type_checker
      let builtins = type_checker.builtins
      let module = new_module('foo')
      let body = parse('match 10 { 10 when True -> { 10 } else -> { 20 } }')

      setup_match_types(type_checker: type_checker, module: module)
      type_checker.check_module(module: module, ast: body)

      let node = body.children[0] as Match
      let case = node.cases[0] as MatchExpressions
      let pattern = case.patterns[0]

      try assert_false(type_checker.diagnostics.errors?)

      try assert_object_instance(pattern.resolved_type.get, builtins.integer_type)
      try assert_object_instance(
        case.guard.get.resolved_type.get,
        builtins.boolean_type
      )
    }

    g.test('Defining a match with an invalid expression guard') {
      let type_checker = new_type_checker
      let builtins = type_checker.builtins
      let module = new_module('foo')
      let body = parse('match 10 { 10 when 20 -> { 10 } else -> { 20 } }')

      setup_match_types(type_checker: type_checker, module: module)
      type_checker.check_module(module: module, ast: body)

      let node = body.children[0] as Match
      let case = node.cases[0] as MatchExpressions

      # This test errors because guards must return a Boolean.
      try assert_true(type_checker.diagnostics.errors?)
      try assert_object_instance(
        case.guard.get.resolved_type.get,
        builtins.integer_type
      )
    }

    g.test('Defining a match with a type case') {
      let type_checker = new_type_checker
      let module = new_module('foo')
      let int_type = type_checker.builtins.integer_type
      let body = parse('match x { as Int -> { 10 } else -> { 20 } }')

      body
        .variable_scope
        .symbols
        .define(name: 'x', type: TraitInstance.new(TraitType.new('X')))

      setup_match_types(type_checker: type_checker, module: module)
      type_checker.check_module(module: module, ast: body)

      let node = body.children[0] as Match
      let case = node.cases[0] as MatchType

      try assert_false(type_checker.diagnostics.errors?)
      try assert_object_instance(node.resolved_type.get, int_type)
      try assert_object_instance(case.resolved_type.get, int_type)
      try assert_object_instance(case.pattern.resolved_type.get, int_type)

      try assert_false(case.body.type_scope.none?)
      try assert_false(node.else_branch.get.body.type_scope.none?)
    }

    g.test('Defining a match with a type case and a valid guard') {
      let type_checker = new_type_checker
      let module = new_module('foo')
      let builtins = type_checker.builtins
      let int_type = builtins.integer_type
      let body =
        parse('match x { as Int when True -> { 10 } else -> { 20 } }')

      body
        .variable_scope
        .symbols
        .define(name: 'x', type: TraitInstance.new(TraitType.new('X')))

      setup_match_types(type_checker: type_checker, module: module)
      type_checker.check_module(module: module, ast: body)

      let node = body.children[0] as Match
      let case = node.cases[0] as MatchType

      try assert_false(type_checker.diagnostics.errors?)
      try assert_object_instance(node.resolved_type.get, int_type)
      try assert_object_instance(case.resolved_type.get, int_type)
      try assert_object_instance(
        case.guard.get.resolved_type.get,
        builtins.boolean_type
      )
      try assert_object_instance(case.pattern.resolved_type.get, int_type)
    }

    g.test('Defining a match with a type case and an invalid guard') {
      let type_checker = new_type_checker
      let module = new_module('foo')
      let builtins = type_checker.builtins
      let int_type = builtins.integer_type
      let body = parse('match x { as Int when 10 -> { 10 } else -> { 20 } }')

      body
        .variable_scope
        .symbols
        .define(name: 'x', type: TraitInstance.new(TraitType.new('X')))

      setup_match_types(type_checker: type_checker, module: module)
      type_checker.check_module(module: module, ast: body)

      let node = body.children[0] as Match
      let case = node.cases[0] as MatchType

      try assert_true(type_checker.diagnostics.errors?)

      try assert_object_instance(node.resolved_type.get, int_type)
      try assert_object_instance(case.resolved_type.get, int_type)
      try assert_object_instance(case.guard.get.resolved_type.get, int_type)
      try assert_object_instance(case.pattern.resolved_type.get, int_type)
    }

    g.test('Defining a match where cases return different types') {
      let type_checker = new_type_checker
      let builtins = type_checker.builtins
      let module = new_module('foo')
      let body = parse('match 10 { 10 -> { 10.5 } else -> { 20 } }')

      setup_match_types(type_checker: type_checker, module: module)
      type_checker.check_module(module: module, ast: body)

      let node = body.children[0] as Match
      let case = node.cases[0] as MatchExpressions

      try assert_instance_of(node.resolved_type.get, AnyType)
      try assert_object_instance(case.resolved_type.get, builtins.float_type)
      try assert_object_instance(
        node.else_branch.get.resolved_type.get,
        builtins.integer_type
      )
    }

    g.test('Defining a match without an argument with a Boolean expression case') {
      let type_checker = new_type_checker
      let builtins = type_checker.builtins
      let module = new_module('foo')
      let body = parse('match { True -> { 10 } else -> { 20 } }')

      setup_match_types(type_checker: type_checker, module: module)
      type_checker.check_module(module: module, ast: body)

      let node = body.children[0] as Match
      let case = node.cases[0] as MatchExpressions
      let patt = case.patterns[0]

      try assert_false(type_checker.diagnostics.errors?)
      try assert_object_instance(node.resolved_type.get, builtins.integer_type)
      try assert_object_instance(case.resolved_type.get, builtins.integer_type)
      try assert_object_instance(patt.resolved_type.get, builtins.boolean_type)

      try assert_false(case.body.type_scope.none?)
      try assert_false(node.else_branch.get.body.type_scope.none?)
    }

    g.test('Defining a match without an argument with a non-Boolean expression case') {
      let type_checker = new_type_checker
      let builtins = type_checker.builtins
      let module = new_module('foo')
      let body = parse('match { 10 -> { 10 } else -> { 20 } }')

      setup_match_types(type_checker: type_checker, module: module)
      type_checker.check_module(module: module, ast: body)

      let node = body.children[0] as Match
      let case = node.cases[0] as MatchExpressions
      let patt = case.patterns[0]

      try assert_true(type_checker.diagnostics.errors?)

      try assert_object_instance(node.resolved_type.get, builtins.integer_type)
      try assert_object_instance(case.resolved_type.get, builtins.integer_type)
      try assert_object_instance(patt.resolved_type.get, builtins.integer_type)
    }

    g.test('Defining a match without an argument with a type case') {
      let type_checker = new_type_checker
      let builtins = type_checker.builtins
      let module = new_module('foo')
      let body = parse('match { as Int -> { 10 } else -> { 20 } }')

      setup_match_types(type_checker: type_checker, module: module)
      type_checker.check_module(module: module, ast: body)

      let node = body.children[0] as Match

      try assert_true(type_checker.diagnostics.errors?)
      try assert_object_instance(node.resolved_type.get, builtins.integer_type)
    }

    g.test('Defining a match with a binding') {
      let type_checker = new_type_checker
      let module = new_module('foo')
      let int_type = type_checker.builtins.integer_type
      let body = parse(
        '
        match let x = 10 {
          10 -> { x }
          as Int -> { x }
          else -> { x }
        }
        '
      )

      setup_match_types(type_checker: type_checker, module: module)
      type_checker.check_module(module: module, ast: body)

      let node = body.children[0] as Match

      try assert_false(type_checker.diagnostics.errors?)
      try assert_object_instance(node.cases[0].resolved_type.get, int_type)
      try assert_object_instance(node.cases[1].resolved_type.get, int_type)
      try assert_object_instance(node.else_branch.get.resolved_type.get, int_type)
    }

    g.test('Defining a match with a type case matching a generic type') {
      let type_checker = new_type_checker
      let module = new_module('foo')
      let ary_type = type_checker.builtins.array_type
      let trait_type = TraitType.new('Foo')
      let body = parse('match x { as Array -> {} else -> {} }')

      setup_match_types(type_checker: type_checker, module: module)
      module.define_constant(name: 'Array', type: ary_type)
      body.variable_scope.symbols.define(name: 'x', type: trait_type.new_instance)
      type_checker.check_module(module: module, ast: body)

      let node = body.children[0] as Match
      let case = node.cases[0] as MatchType

      try assert_false(type_checker.diagnostics.errors?)
      try assert_object_instance(case.pattern.resolved_type.get, ary_type)
    }
  }

  t.group('Type-checking type casts') do (g) {
    g.test('Casting a type to an implemented trait') {
      let type_checker = new_type_checker
      let int_type = type_checker.builtins.integer_type
      let to_foo = TraitType.new('ToFoo')
      let module = new_module('foo')
      let body = parse('x as ToFoo')
      let node = body.children[0] as TypeCast

      int_type
        .add_trait_implementation(TraitImplementation.new(to_foo.new_instance))

      module.define_constant(name: 'ToFoo', type: to_foo)
      body.variable_scope.symbols.define(name: 'x', type: int_type.new_instance)
      type_checker.check_module(module: module, ast: body)

      try assert_false(type_checker.diagnostics.errors?)
      try assert_trait_instance(node.resolved_type.get, to_foo)
    }

    g.test('Casting a type to an unimplemented trait') {
      let type_checker = new_type_checker
      let int_type = type_checker.builtins.integer_type
      let to_foo = TraitType.new('ToFoo')
      let module = new_module('foo')
      let body = parse('x as ToFoo')
      let node = body.children[0] as TypeCast

      module.define_constant(name: 'ToFoo', type: to_foo)
      body.variable_scope.symbols.define(name: 'x', type: int_type.new_instance)
      type_checker.check_module(module: module, ast: body)

      try assert_true(type_checker.diagnostics.errors?)
      try assert_trait_instance(node.resolved_type.get, to_foo)
    }

    g.test('Casting a type to a non-existing type') {
      let type_checker = new_type_checker
      let int_type = type_checker.builtins.integer_type
      let module = new_module('foo')
      let body = parse('x as ToFoo')
      let node = body.children[0]

      body.variable_scope.symbols.define(name: 'x', type: int_type.new_instance)
      type_checker.check_module(module: module, ast: body)

      try assert_true(type_checker.diagnostics.errors?)
      try assert_true(node.resolved_type.get.error?)
    }

    g.test('Casting a trait to an object that implements the trait') {
      let type_checker = new_type_checker
      let int_type = type_checker.builtins.integer_type
      let to_foo = TraitType.new('ToFoo')
      let module = new_module('foo')
      let body = parse('x as Int')
      let node = body.children[0] as TypeCast

      int_type
        .add_trait_implementation(TraitImplementation.new(to_foo.new_instance))

      module.define_constant(name: 'Int', type: int_type)
      body.variable_scope.symbols.define(name: 'x', type: to_foo.new_instance)
      type_checker.check_module(module: module, ast: body)

      try assert_false(type_checker.diagnostics.errors?)
      try assert_object_instance(node.resolved_type.get, int_type)
    }

    g.test("Casting a trait to an object that doesn't implement the trait") {
      let type_checker = new_type_checker
      let int_type = type_checker.builtins.integer_type
      let to_foo = TraitType.new('ToFoo')
      let module = new_module('foo')
      let body = parse('x as Int')
      let node = body.children[0] as TypeCast

      module.define_constant(name: 'Int', type: int_type)
      body.variable_scope.symbols.define(name: 'x', type: to_foo.new_instance)
      type_checker.check_module(module: module, ast: body)

      try assert_true(type_checker.diagnostics.errors?)
      try assert_object_instance(node.resolved_type.get, int_type)
    }

    g.test('Casting an error type to an object') {
      let type_checker = new_type_checker
      let int_type = type_checker.builtins.integer_type
      let module = new_module('foo')
      let body = parse('x as Int')
      let node = body.children[0]

      module.define_constant(name: 'Int', type: int_type)
      body.variable_scope.symbols.define(name: 'x', type: ErrorType.new)
      type_checker.check_module(module: module, ast: body)

      try assert_false(type_checker.diagnostics.errors?)
      try assert_object_instance(node.resolved_type.get, int_type)
    }

    g.test('Casting one object to another object') {
      let type_checker = new_type_checker
      let int_type = type_checker.builtins.integer_type
      let float_type = type_checker.builtins.float_type
      let module = new_module('foo')
      let body = parse('x as Int')
      let node = body.children[0]

      module.define_constant(name: 'Int', type: int_type)
      body.variable_scope.symbols.define(name: 'x', type: float_type.new_instance)
      type_checker.check_module(module: module, ast: body)

      try assert_true(type_checker.diagnostics.errors?)
      try assert_object_instance(node.resolved_type.get, int_type)
    }

    g.test('Casting a type to a method type parameter') {
      let type_checker = new_type_checker
      let module = new_module('foo')
      let body = parse('def foo!(A) { 10 as A }')
      let meth_node = body.children[0] as DefineMethod
      let node = meth_node.body.children[0]

      type_checker.check_module(module: module, ast: body)

      try assert_false(type_checker.diagnostics.errors?)

      let type = node.resolved_type.get
      let param = module.methods['foo'].type.lookup_type_parameter('A').get.type

      try assert_instance_of(type, RigidTypeParameterType)
      try assert_same_object((type as RigidTypeParameterType).type, param)
    }

    g.test('Casting a type to an class type parameter') {
      let type_checker = new_type_checker
      let module = new_module('foo')
      let body = parse('class Foo!(A) { def foo { 10 as A } }')
      let obj_node = body.children[0] as DefineClass
      let meth_node = obj_node.body.children[0] as DefineMethod
      let node = meth_node.body.children[0]

      type_checker.check_module(module: module, ast: body)

      let type = node.resolved_type.get
      let obj = module.constants['Foo'].type as ClassType
      let param = obj.lookup_type_parameter('A').get.type

      try assert_false(type_checker.diagnostics.errors?)
      try assert_instance_of(type, RigidTypeParameterType)
      try assert_same_object((type as RigidTypeParameterType).type, param)
    }
  }

  t.group('Type-checking closures') do (g) {
    g.test('Defining an empty basic closure') {
      let type_checker = new_type_checker
      let module = new_module('foo')
      let body = parse('{}')
      let node = body.children[0] as BasicClosure

      type_checker.check_module(module: module, ast: body)

      let type = node.resolved_type.get

      try assert_false(type_checker.diagnostics.errors?)
      try assert_true(type.arguments.empty?)
      try assert_true(type.throw_type.none?)

      try assert_false(node.body.type_scope.none?)
      try assert_same_object(node.body.type_scope.get.block.get, type)

      try assert_object_instance(type.return_type, type_checker.builtins.nil_type)
    }

    g.test('Defining a basic closure that captures a local variable') {
      let type_checker = new_type_checker
      let int_type = type_checker.builtins.integer_type
      let module = new_module('foo')
      let body = parse('{ x }')
      let node = body.children[0] as BasicClosure

      body.variable_scope.symbols.define(name: 'x', type: int_type.new_instance)
      type_checker.check_module(module: module, ast: body)

      let type = node.resolved_type.get

      try assert_false(type_checker.diagnostics.errors?)
      try assert_true(type.arguments.empty?)
      try assert_true(type.throw_type.none?)
      try assert_true(type.captures?)

      try assert_object_instance(type.return_type, int_type)
      try assert_object_instance(node.body.children[0].resolved_type.get, int_type)
    }

    g.test('Defining an empty closure without explicit types') {
      let type_checker = new_type_checker
      let module = new_module('foo')
      let body = parse('do {}')
      let node = body.children[0] as Closure

      type_checker.check_module(module: module, ast: body)

      let type = node.resolved_type.get

      try assert_false(type_checker.diagnostics.errors?)
      try assert_true(type.arguments.empty?)
      try assert_true(type.throw_type.none?)

      try assert_false(node.body.type_scope.none?)
      try assert_same_object(node.body.type_scope.get.block.get, type)
      try assert_object_instance(type.return_type, type_checker.builtins.nil_type)
    }

    g.test('Defining a closure without explicit types that captures a local variable') {
      let type_checker = new_type_checker
      let int_type = type_checker.builtins.integer_type
      let module = new_module('foo')
      let body = parse('do { x }')
      let node = body.children[0] as Closure

      body.variable_scope.symbols.define(name: 'x', type: int_type.new_instance)
      type_checker.check_module(module: module, ast: body)

      let type = node.resolved_type.get

      try assert_false(type_checker.diagnostics.errors?)
      try assert_true(type.arguments.empty?)
      try assert_true(type.throw_type.none?)
      try assert_true(type.captures?)

      try assert_object_instance(type.return_type, int_type)
      try assert_object_instance(node.body.children[0].resolved_type.get, int_type)
    }

    g.test('Defining a closure with typed arguments') {
      let type_checker = new_type_checker
      let module = new_module('foo')
      let int_type = type_checker.builtins.integer_type
      let float_type = type_checker.builtins.float_type
      let body = parse("do (a: Float, b: Int) { a \n b }")
      let node = body.children[0] as Closure

      module.define_constant(name: 'Int', type: int_type)
      module.define_constant(name: 'Float', type: float_type)
      type_checker.check_module(module: module, ast: body)

      let type = node.resolved_type.get

      try assert_false(type_checker.diagnostics.errors?)
      try assert_equal(type.arguments.length, 2)
      try assert_true(type.throw_type.none?)

      try assert_object_instance(type.return_type, int_type)

      try assert_object_instance(type.arguments['a'].type, float_type)
      try assert_object_instance(type.arguments['b'].type, int_type)

      try assert_object_instance(node.body.children[0].resolved_type.get, float_type)
      try assert_object_instance(node.body.children[1].resolved_type.get, int_type)
    }

    g.test('Defining a closure with an explicit return type and a valid return value') {
      let type_checker = new_type_checker
      let module = new_module('foo')
      let int_type = type_checker.builtins.integer_type
      let body = parse('do -> Int { 10 }')
      let node = body.children[0] as Closure

      module.define_constant(name: 'Int', type: int_type)
      type_checker.check_module(module: module, ast: body)

      let type = node.resolved_type.get

      try assert_false(type_checker.diagnostics.errors?)
      try assert_object_instance(type.return_type, int_type)
    }

    g.test('Defining a closure with an explicit return type and an invalid return value') {
      let type_checker = new_type_checker
      let module = new_module('foo')
      let int_type = type_checker.builtins.integer_type
      let body = parse('do -> Int { 10.5 }')
      let node = body.children[0] as Closure

      module.define_constant(name: 'Int', type: int_type)
      type_checker.check_module(module: module, ast: body)

      let type = node.resolved_type.get

      try assert_true(type_checker.diagnostics.errors?)
      try assert_object_instance(type.return_type, int_type)
    }

    g.test('Defining a closure with an explicit throw type and a valid thrown type') {
      let type_checker = new_type_checker
      let module = new_module('foo')
      let int_type = type_checker.builtins.integer_type
      let body = parse('do !! Int { throw 10 }')
      let node = body.children[0] as Closure

      module.define_constant(name: 'Int', type: int_type)
      type_checker.check_module(module: module, ast: body)

      let type = node.resolved_type.get

      try assert_false(type_checker.diagnostics.errors?)
      try assert_object_instance(type.throw_type.get, int_type)
    }

    g.test('Defining a closure with an explicit throw type and an invalid thrown type') {
      let type_checker = new_type_checker
      let module = new_module('foo')
      let int_type = type_checker.builtins.integer_type
      let body = parse('do !! Int { throw 10.5 }')
      let node = body.children[0] as Closure

      module.define_constant(name: 'Int', type: int_type)
      type_checker.check_module(module: module, ast: body)

      let type = node.resolved_type.get

      try assert_true(type_checker.diagnostics.errors?)
      try assert_object_instance(type.throw_type.get, int_type)
    }

    g.test('Defining a closure with an explicit throw type that never throws') {
      let type_checker = new_type_checker
      let module = new_module('foo')
      let int_type = type_checker.builtins.integer_type
      let body = parse('do !! Int {}')

      module.define_constant(name: 'Int', type: int_type)
      type_checker.check_module(module: module, ast: body)

      try assert_true(type_checker.diagnostics.errors?)
    }

    g.test('Defining a closure that throws without an explicit throw type') {
      let type_checker = new_type_checker
      let module = new_module('foo')
      let int_type = type_checker.builtins.integer_type
      let body = parse('do { throw 10 }')
      let node = body.children[0] as Closure

      type_checker.check_module(module: module, ast: body)

      let type = node.resolved_type.get

      try assert_false(type_checker.diagnostics.errors?)
      try assert_object_instance(type.throw_type.get, int_type)
    }

    g.test('Defining a closure with a type parameter') {
      let type_checker = new_type_checker
      let module = new_module('foo')
      let body = parse('do !(T)(a: T) { a }')
      let node = body.children[0] as Closure

      type_checker.check_module(module: module, ast: body)

      let type = node.resolved_type.get
      let param = type.lookup_type_parameter('T').get.type

      try assert_false(type_checker.diagnostics.errors?)
      try assert_instance_of(type.return_type, RigidTypeParameterType)
      try assert_same_object((type.return_type as RigidTypeParameterType).type, param)
    }

    g.test('Defining a closure with a type parameter and explicit return type') {
      let type_checker = new_type_checker
      let module = new_module('foo')
      let body = parse('do !(T)(a: T) -> T { a }')
      let node = body.children[0] as Closure

      type_checker.check_module(module: module, ast: body)

      let type = node.resolved_type.get
      let param = type.lookup_type_parameter('T').get.type

      try assert_false(type_checker.diagnostics.errors?)
      try assert_same_object(type.return_type, param)
    }

    g.test('Defining a closure with a type parameter and explicit throw type') {
      let type_checker = new_type_checker
      let module = new_module('foo')
      let body = parse('do !(T)(a: T) !! T { throw a }')
      let node = body.children[0] as Closure

      type_checker.check_module(module: module, ast: body)

      let type = node.resolved_type.get
      let param = type.lookup_type_parameter('T').get.type

      try assert_false(type_checker.diagnostics.errors?)
      try assert_same_object(type.throw_type.get, param)
    }

    g.test('Defining a closure with immutable untyped arguments') {
      let type_checker = new_type_checker
      let module = new_module('foo')
      let body = parse('do (a, b) {}')
      let node = body.children[0] as Closure

      type_checker.check_module(module: module, ast: body)

      let type = node.resolved_type.get

      try assert_true(type_checker.diagnostics.errors?)
      try assert_true(type.arguments['a'].type.error?)
      try assert_true(type.arguments['b'].type.error?)
    }

    g.test('Defining a closure with an optional argument') {
      let type_checker = new_type_checker
      let int_type = type_checker.builtins.integer_type
      let module = new_module('foo')
      let body = parse('do (a = 10) {}')
      let node = body.children[0] as Closure

      type_checker.check_module(module: module, ast: body)

      let type = node.resolved_type.get

      try assert_false(type_checker.diagnostics.errors?)
      try assert_object_instance(type.arguments['a'].type, int_type)
    }

    g.test('Defining a closure with a statically typed rest argument') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let body = parse('do(*a: Int) {}')

      module
        .define_constant(name: 'Int', type: type_checker.builtins.integer_type)

      type_checker.check_module(module: module, ast: body)

      let block = body.children[0].resolved_type.get as ClosureType
      let arg = block.arguments['a'].type as ClassInstance

      try assert_false(type_checker.diagnostics.errors?)
      try assert_true(block.rest_argument?)
      try assert_object_instance(arg, type_checker.builtins.integer_type)
    }

    g.test('Referring to closure method argument in its body') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let int_type = type_checker.builtins.integer_type
      let body = parse('do(a: Int) { a }')

      module.define_constant(name: 'Int', type: int_type)
      type_checker.check_module(module: module, ast: body)

      let method = body.children[0] as Closure
      let lvar = method.body.children[0] as Identifier

      try assert_object_instance(lvar.resolved_type.get, int_type)
      try assert_false(type_checker.diagnostics.errors?)
    }

    g.test('Referring to a closure rest argument in its body') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let int_type = type_checker.builtins.integer_type
      let ary_type = type_checker.builtins.array_type
      let body = parse('do(*a: Int) { a }')

      module.define_constant(name: 'Int', type: int_type)
      type_checker.check_module(module: module, ast: body)

      let method = body.children[0] as Closure
      let lvar = method.body.children[0] as Identifier

      let param = type_checker
        .builtins
        .array_type
        .lookup_type_parameter(ARRAY_TYPE_PARAMETER)
        .get
        .type

      let type = lvar.resolved_type.get

      try assert_object_instance(type, ary_type)
      try assert_object_instance(type.lookup_type_parameter_type(param).get, int_type)
      try assert_false(type_checker.diagnostics.errors?)
    }
  }

  t.group('Type-checking lambdas') do (g) {
    g.test('Defining an empty lambda without explicit types') {
      let type_checker = new_type_checker
      let module = new_module('foo')
      let body = parse('fn {}')
      let node = body.children[0] as Lambda

      type_checker.check_module(module: module, ast: body)

      let type = node.resolved_type.get

      try assert_false(type_checker.diagnostics.errors?)
      try assert_true(type.arguments.empty?)
      try assert_true(type.throw_type.none?)

      try assert_false(node.body.type_scope.none?)
      try assert_same_object(node.body.type_scope.get.block.get, type)

      try assert_object_instance(type.return_type, type_checker.builtins.nil_type)
    }

    g.test('Defining a lambda that refers to a local variarble') {
      let type_checker = new_type_checker
      let int_type = type_checker.builtins.integer_type
      let module = new_module('foo')
      let body = parse('fn { x }')
      let node = body.children[0] as Lambda

      body.variable_scope.symbols.define(name: 'x', type: int_type.new_instance)
      type_checker.check_module(module: module, ast: body)

      let type = node.resolved_type.get

      try assert_true(type_checker.diagnostics.errors?)
      try assert_true(type.arguments.empty?)
      try assert_true(type.throw_type.none?)
      try assert_true(type.return_type.error?)
    }

    g.test('Defining a lambda with typed arguments') {
      let type_checker = new_type_checker
      let module = new_module('foo')
      let int_type = type_checker.builtins.integer_type
      let float_type = type_checker.builtins.float_type
      let body = parse("fn (a: Float, b: Int) { a \n b }")
      let node = body.children[0] as Lambda

      module.define_constant(name: 'Int', type: int_type)
      module.define_constant(name: 'Float', type: float_type)
      type_checker.check_module(module: module, ast: body)

      let type = node.resolved_type.get

      try assert_false(type_checker.diagnostics.errors?)
      try assert_equal(type.arguments.length, 2)
      try assert_true(type.throw_type.none?)

      try assert_object_instance(type.return_type, int_type)

      try assert_object_instance(type.arguments['a'].type, float_type)
      try assert_object_instance(type.arguments['b'].type, int_type)

      try assert_object_instance(node.body.children[0].resolved_type.get, float_type)
      try assert_object_instance(node.body.children[1].resolved_type.get, int_type)
    }

    g.test('Defining a lambda with an explicit return type and a valid return value') {
      let type_checker = new_type_checker
      let module = new_module('foo')
      let int_type = type_checker.builtins.integer_type
      let body = parse('fn -> Int { 10 }')
      let node = body.children[0] as Lambda

      module.define_constant(name: 'Int', type: int_type)
      type_checker.check_module(module: module, ast: body)

      let type = node.resolved_type.get

      try assert_false(type_checker.diagnostics.errors?)
      try assert_object_instance(type.return_type, int_type)
    }

    g.test('Defining a lambda with an explicit return type and an invalid return value') {
      let type_checker = new_type_checker
      let module = new_module('foo')
      let int_type = type_checker.builtins.integer_type
      let body = parse('fn -> Int { 10.5 }')
      let node = body.children[0] as Lambda

      module.define_constant(name: 'Int', type: int_type)
      type_checker.check_module(module: module, ast: body)

      let type = node.resolved_type.get

      try assert_true(type_checker.diagnostics.errors?)
      try assert_object_instance(type.return_type, int_type)
    }

    g.test('Defining a lambda with an explicit throw type and a valid thrown type') {
      let type_checker = new_type_checker
      let module = new_module('foo')
      let int_type = type_checker.builtins.integer_type
      let body = parse('fn !! Int { throw 10 }')
      let node = body.children[0] as Lambda

      module.define_constant(name: 'Int', type: int_type)
      type_checker.check_module(module: module, ast: body)

      let type = node.resolved_type.get

      try assert_false(type_checker.diagnostics.errors?)
      try assert_object_instance(type.throw_type.get, int_type)
    }

    g.test('Defining a lambda with an explicit throw type and an invalid thrown type') {
      let type_checker = new_type_checker
      let module = new_module('foo')
      let int_type = type_checker.builtins.integer_type
      let body = parse('fn !! Int { throw 10.5 }')
      let node = body.children[0] as Lambda

      module.define_constant(name: 'Int', type: int_type)
      type_checker.check_module(module: module, ast: body)

      let type = node.resolved_type.get

      try assert_true(type_checker.diagnostics.errors?)
      try assert_object_instance(type.throw_type.get, int_type)
    }

    g.test('Defining a lambda with an explicit throw type that never throws') {
      let type_checker = new_type_checker
      let module = new_module('foo')
      let int_type = type_checker.builtins.integer_type
      let body = parse('fn !! Int {}')

      module.define_constant(name: 'Int', type: int_type)
      type_checker.check_module(module: module, ast: body)

      try assert_true(type_checker.diagnostics.errors?)
    }

    g.test('Defining a lambda that throws without an explicit throw type') {
      let type_checker = new_type_checker
      let module = new_module('foo')
      let int_type = type_checker.builtins.integer_type
      let body = parse('fn { throw 10 }')
      let node = body.children[0] as Lambda

      type_checker.check_module(module: module, ast: body)

      let type = node.resolved_type.get

      try assert_false(type_checker.diagnostics.errors?)
      try assert_object_instance(type.throw_type.get, int_type)
    }

    g.test('Defining a lambda with a type parameter') {
      let type_checker = new_type_checker
      let module = new_module('foo')
      let body = parse('fn !(T)(a: T) { a }')
      let node = body.children[0] as Lambda

      type_checker.check_module(module: module, ast: body)

      let type = node.resolved_type.get
      let param = type.lookup_type_parameter('T').get.type

      try assert_false(type_checker.diagnostics.errors?)
      try assert_instance_of(type.return_type, RigidTypeParameterType)
      try assert_same_object((type.return_type as RigidTypeParameterType).type, param)
    }

    g.test('Defining a lambda with a type parameter and explicit return type') {
      let type_checker = new_type_checker
      let module = new_module('foo')
      let body = parse('fn !(T)(a: T) -> T { a }')
      let node = body.children[0] as Lambda

      type_checker.check_module(module: module, ast: body)

      let type = node.resolved_type.get
      let param = type.lookup_type_parameter('T').get.type

      try assert_false(type_checker.diagnostics.errors?)
      try assert_same_object(type.return_type, param)
    }

    g.test('Defining a lambda with a type parameter and explicit throw type') {
      let type_checker = new_type_checker
      let module = new_module('foo')
      let body = parse('fn !(T)(a: T) !! T { throw a }')
      let node = body.children[0] as Lambda

      type_checker.check_module(module: module, ast: body)

      let type = node.resolved_type.get
      let param = type.lookup_type_parameter('T').get.type

      try assert_false(type_checker.diagnostics.errors?)
      try assert_same_object(type.throw_type.get, param)
    }

    g.test('Defining a lambda with immutable untyped arguments') {
      let type_checker = new_type_checker
      let module = new_module('foo')
      let body = parse('fn (a, b) {}')
      let node = body.children[0] as Lambda

      type_checker.check_module(module: module, ast: body)

      let type = node.resolved_type.get

      try assert_true(type_checker.diagnostics.errors?)
      try assert_true(type.arguments['a'].type.error?)
      try assert_true(type.arguments['b'].type.error?)
    }

    g.test('Defining a lambda with an optional argument') {
      let type_checker = new_type_checker
      let int_type = type_checker.builtins.integer_type
      let module = new_module('foo')
      let body = parse('fn (a = 10) {}')
      let node = body.children[0] as Lambda

      type_checker.check_module(module: module, ast: body)

      let type = node.resolved_type.get

      try assert_false(type_checker.diagnostics.errors?)
      try assert_object_instance(type.arguments['a'].type, int_type)
    }

    g.test('Defining a lambda with a statically typed rest argument') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let body = parse('fn(*a: Int) {}')

      module
        .define_constant(name: 'Int', type: type_checker.builtins.integer_type)

      type_checker.check_module(module: module, ast: body)

      let block = body.children[0].resolved_type.get as LambdaType
      let arg = block.arguments['a'].type as ClassInstance

      try assert_false(type_checker.diagnostics.errors?)
      try assert_true(block.rest_argument?)
      try assert_object_instance(arg, type_checker.builtins.integer_type)
    }

    g.test('Referring to lambda method argument in its body') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let int_type = type_checker.builtins.integer_type
      let body = parse('fn(a: Int) { a }')

      module.define_constant(name: 'Int', type: int_type)
      type_checker.check_module(module: module, ast: body)

      let method = body.children[0] as Lambda
      let lvar = method.body.children[0] as Identifier

      try assert_object_instance(lvar.resolved_type.get, int_type)
      try assert_false(type_checker.diagnostics.errors?)
    }

    g.test('Referring to a lambda rest argument in its body') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let int_type = type_checker.builtins.integer_type
      let ary_type = type_checker.builtins.array_type
      let body = parse('fn(*a: Int) { a }')

      module.define_constant(name: 'Int', type: int_type)
      type_checker.check_module(module: module, ast: body)

      let method = body.children[0] as Lambda
      let lvar = method.body.children[0] as Identifier

      let param = type_checker
        .builtins
        .array_type
        .lookup_type_parameter(ARRAY_TYPE_PARAMETER)
        .get
        .type

      let type = lvar.resolved_type.get

      try assert_object_instance(type, ary_type)
      try assert_object_instance(type.lookup_type_parameter_type(param).get, int_type)
      try assert_false(type_checker.diagnostics.errors?)
    }
  }

  t.group('Type-checking method throws') do (g) {
    g.test('Throwing at the module-level') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let body = parse('throw 10')

      type_checker.check_module(module: module, ast: body)

      try assert_true(type_checker.diagnostics.errors?)
    }
  }

  t.group('Type-checking yields') do (g) {
    g.test('Yielding at the module-level') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let body = parse('yield 10')

      type_checker.check_module(module: module, ast: body)

      try assert_true(type_checker.diagnostics.errors?)
    }
  }

  t.group('Type-checking sending messages') do (g) {
    g.test('Not passing any arguments when none are required') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let body = parse('foo()')
      let node = body.children[0] as Send
      let int_type = type_checker.builtins.integer_type
      let foo =
        MethodType.new(name: 'foo', layout: BlockLayout.new(int_type.new_instance))

      module.define_method(name: foo.name, type: foo)
      type_checker.check_module(module: module, ast: body)

      try assert_false(type_checker.diagnostics.errors?)
      try assert_object_instance(node.resolved_type.get, int_type)
    }

    g.test('Not passing enough arguments') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let body = parse('foo(10)')
      let node = body.children[0] as Send
      let int_type = type_checker.builtins.integer_type
      let foo =
        MethodType.new(name: 'foo', layout: BlockLayout.new(int_type.new_instance))

      foo.define_required_argument(name: 'a', type: int_type.new_instance)
      foo.define_required_argument(name: 'b', type: int_type.new_instance)

      module.define_method(name: foo.name, type: foo)
      type_checker.check_module(module: module, ast: body)

      try assert_true(type_checker.diagnostics.errors?)
      try assert_true(node.resolved_type.get.error?)
    }

    g.test('Passing too many arguments') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let body = parse('foo(10)')
      let node = body.children[0] as Send
      let int_type = type_checker.builtins.integer_type
      let foo =
        MethodType.new(name: 'foo', layout: BlockLayout.new(int_type.new_instance))

      module.define_method(name: foo.name, type: foo)
      type_checker.check_module(module: module, ast: body)

      try assert_true(type_checker.diagnostics.errors?)
      try assert_true(node.resolved_type.get.error?)
    }

    g.test('Passing the correct number of arguments') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let body = parse('foo(10)')
      let node = body.children[0] as Send
      let int_type = type_checker.builtins.integer_type
      let foo =
        MethodType.new(name: 'foo', layout: BlockLayout.new(int_type.new_instance))

      foo.define_required_argument(name: 'a', type: int_type.new_instance)

      module.define_method(name: foo.name, type: foo)
      type_checker.check_module(module: module, ast: body)

      try assert_false(type_checker.diagnostics.errors?)
      try assert_object_instance(node.resolved_type.get, int_type)
    }

    g.test('Passing a keyword argument when no arguments are expected') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let body = parse('foo(foo: 10)')
      let node = body.children[0] as Send
      let int_type = type_checker.builtins.integer_type
      let foo =
        MethodType.new(name: 'foo', layout: BlockLayout.new(int_type.new_instance))

      module.define_method(name: foo.name, type: foo)
      type_checker.check_module(module: module, ast: body)

      try assert_true(type_checker.diagnostics.errors?)
      try assert_true(node.resolved_type.get.error?)
    }

    g.test('Passing an undefined keyword argument') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let body = parse('foo(foo: 10)')
      let node = body.children[0] as Send
      let int_type = type_checker.builtins.integer_type
      let foo =
        MethodType.new(name: 'foo', layout: BlockLayout.new(int_type.new_instance))

      foo.arguments.define(name: 'bar', type: int_type.new_instance)

      module.define_method(name: foo.name, type: foo)
      type_checker.check_module(module: module, ast: body)

      try assert_true(type_checker.diagnostics.errors?)
      try assert_object_instance(node.resolved_type.get, int_type)
    }

    g.test('Passing duplicate keyword arguments') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let body = parse('foo(a: 10, a: 20)')
      let node = body.children[0] as Send
      let int_type = type_checker.builtins.integer_type
      let foo =
        MethodType.new(name: 'foo', layout: BlockLayout.new(int_type.new_instance))

      foo.define_required_argument(name: 'a', type: int_type.new_instance)
      foo.arguments.define(name: 'b', type: int_type.new_instance)

      module.define_method(name: foo.name, type: foo)
      type_checker.check_module(module: module, ast: body)

      try assert_true(type_checker.diagnostics.errors?)
      try assert_object_instance(node.resolved_type.get, int_type)
    }

    g.test('Passing duplicate undefined keyword arguments') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let body = parse('foo(b: 10, b: 20)')
      let node = body.children[0] as Send
      let int_type = type_checker.builtins.integer_type
      let foo =
        MethodType.new(name: 'foo', layout: BlockLayout.new(int_type.new_instance))

      foo.arguments.define(name: 'a', type: int_type.new_instance)

      module.define_method(name: foo.name, type: foo)
      type_checker.check_module(module: module, ast: body)

      try assert_true(type_checker.diagnostics.errors?)

      # Two errors: one because "b" does not exist, and one because "b" is
      # specified twice.
      try assert_equal(type_checker.diagnostics.length, 2)
      try assert_object_instance(node.resolved_type.get, int_type)
    }

    g.test('Passing a keyword argument and leaving out a required argument') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let body = parse('foo(10, c: 20)')
      let node = body.children[0] as Send
      let int_type = type_checker.builtins.integer_type
      let foo =
        MethodType.new(name: 'foo', layout: BlockLayout.new(int_type.new_instance))

      foo.define_required_argument(name: 'a', type: int_type.new_instance)
      foo.define_required_argument(name: 'b', type: int_type.new_instance)
      foo.define_required_argument(name: 'c', type: int_type.new_instance)

      module.define_method(name: foo.name, type: foo)
      type_checker.check_module(module: module, ast: body)

      try assert_true(type_checker.diagnostics.errors?)
      try assert_true(node.resolved_type.get.error?)
    }

    g.test('Passing a valid keyword argument') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let body = parse('foo(a: 10)')
      let node = body.children[0] as Send
      let int_type = type_checker.builtins.integer_type
      let foo =
        MethodType.new(name: 'foo', layout: BlockLayout.new(int_type.new_instance))

      foo.define_required_argument(name: 'a', type: int_type.new_instance)

      module.define_method(name: foo.name, type: foo)
      type_checker.check_module(module: module, ast: body)

      try assert_false(type_checker.diagnostics.errors?)
      try assert_object_instance(node.resolved_type.get, int_type)
    }

    g.test('Not passing an optional argument') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let body = parse('foo')
      let node = body.children[0] as Send
      let int_type = type_checker.builtins.integer_type
      let foo =
        MethodType.new(name: 'foo', layout: BlockLayout.new(int_type.new_instance))

      foo.arguments.define(name: 'a', type: int_type.new_instance)

      module.define_method(name: foo.name, type: foo)
      type_checker.check_module(module: module, ast: body)

      try assert_false(type_checker.diagnostics.errors?)
      try assert_object_instance(node.resolved_type.get, int_type)
    }

    g.test('Passing an optional argument') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let body = parse('foo(10)')
      let node = body.children[0] as Send
      let int_type = type_checker.builtins.integer_type
      let foo =
        MethodType.new(name: 'foo', layout: BlockLayout.new(int_type.new_instance))

      foo.arguments.define(name: 'a', type: int_type.new_instance)

      module.define_method(name: foo.name, type: foo)
      type_checker.check_module(module: module, ast: body)

      try assert_false(type_checker.diagnostics.errors?)
      try assert_object_instance(node.resolved_type.get, int_type)
    }

    g.test('Passing one optional argument when two are defined') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let body = parse('foo(10)')
      let node = body.children[0] as Send
      let int_type = type_checker.builtins.integer_type
      let foo =
        MethodType.new(name: 'foo', layout: BlockLayout.new(int_type.new_instance))

      foo.arguments.define(name: 'a', type: int_type.new_instance)
      foo.arguments.define(name: 'b', type: int_type.new_instance)

      module.define_method(name: foo.name, type: foo)
      type_checker.check_module(module: module, ast: body)

      try assert_false(type_checker.diagnostics.errors?)
      try assert_object_instance(node.resolved_type.get, int_type)
    }

    g.test('Passing an optional argument as a keyword argument') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let body = parse('foo(a: 10)')
      let node = body.children[0] as Send
      let int_type = type_checker.builtins.integer_type
      let foo =
        MethodType.new(name: 'foo', layout: BlockLayout.new(int_type.new_instance))

      foo.arguments.define(name: 'a', type: int_type.new_instance)

      module.define_method(name: foo.name, type: foo)
      type_checker.check_module(module: module, ast: body)

      try assert_false(type_checker.diagnostics.errors?)
      try assert_object_instance(node.resolved_type.get, int_type)
    }

    g.test('Passing an optional keyword argument with a missing required argument') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let body = parse('foo(b: 10)')
      let node = body.children[0] as Send
      let int_type = type_checker.builtins.integer_type
      let foo =
        MethodType.new(name: 'foo', layout: BlockLayout.new(int_type.new_instance))

      foo.define_required_argument(name: 'a', type: int_type.new_instance)
      foo.arguments.define(name: 'b', type: int_type.new_instance)

      module.define_method(name: foo.name, type: foo)
      type_checker.check_module(module: module, ast: body)

      try assert_true(type_checker.diagnostics.errors?)
      try assert_true(node.resolved_type.get.error?)
    }

    g.test('Passing two required out of order keyword arguments') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let body = parse('foo(a: 10, c: 10)')
      let node = body.children[0] as Send
      let int_type = type_checker.builtins.integer_type
      let foo =
        MethodType.new(name: 'foo', layout: BlockLayout.new(int_type.new_instance))

      foo.define_required_argument(name: 'a', type: int_type.new_instance)
      foo.define_required_argument(name: 'b', type: int_type.new_instance)
      foo.define_required_argument(name: 'c', type: int_type.new_instance)

      module.define_method(name: foo.name, type: foo)
      type_checker.check_module(module: module, ast: body)

      try assert_true(type_checker.diagnostics.errors?)
      try assert_true(node.resolved_type.get.error?)
    }

    g.test('Passing too many undefined keyword arguments') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let body = parse('foo(a: 10, b: 10)')
      let node = body.children[0] as Send
      let int_type = type_checker.builtins.integer_type
      let foo =
        MethodType.new(name: 'foo', layout: BlockLayout.new(int_type.new_instance))

      module.define_method(name: foo.name, type: foo)
      type_checker.check_module(module: module, ast: body)

      try assert_true(type_checker.diagnostics.errors?)
      try assert_true(node.resolved_type.get.error?)
    }

    g.test('Passing an argument of the wrong type') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let body = parse('foo(10.5)')
      let node = body.children[0] as Send
      let int_type = type_checker.builtins.integer_type
      let foo =
        MethodType.new(name: 'foo', layout: BlockLayout.new(int_type.new_instance))

      foo.define_required_argument(name: 'a', type: int_type.new_instance)

      module.define_method(name: foo.name, type: foo)
      type_checker.check_module(module: module, ast: body)

      try assert_true(type_checker.diagnostics.errors?)
      try assert_object_instance(node.resolved_type.get, int_type)
    }

    g.test('Passing a keyword argument of the wrong type') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let body = parse('foo(a: 10.5)')
      let node = body.children[0] as Send
      let int_type = type_checker.builtins.integer_type
      let foo =
        MethodType.new(name: 'foo', layout: BlockLayout.new(int_type.new_instance))

      foo.define_required_argument(name: 'a', type: int_type.new_instance)

      module.define_method(name: foo.name, type: foo)
      type_checker.check_module(module: module, ast: body)

      try assert_true(type_checker.diagnostics.errors?)
      try assert_object_instance(node.resolved_type.get, int_type)
    }

    g.test('Passing too many arguments to a rest argument') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let body = parse('foo(10, 20, 30)')
      let node = body.children[0] as Send
      let int_type = type_checker.builtins.integer_type
      let foo =
        MethodType.new(name: 'foo', layout: BlockLayout.new(int_type.new_instance))

      foo.define_rest_argument(name: 'a', type: int_type.new_instance)
      module.define_method(name: foo.name, type: foo)
      type_checker.check_module(module: module, ast: body)

      try assert_false(type_checker.diagnostics.errors?)
      try assert_object_instance(node.resolved_type.get, int_type)
    }

    g.test('Passing too many incorrectly typed arguments to a rest argument') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let body = parse('foo(10.5, 20.5, 30.5)')
      let node = body.children[0] as Send
      let int_type = type_checker.builtins.integer_type
      let foo =
        MethodType.new(name: 'foo', layout: BlockLayout.new(int_type.new_instance))

      foo.define_rest_argument(name: 'a', type: int_type.new_instance)
      module.define_method(name: foo.name, type: foo)
      type_checker.check_module(module: module, ast: body)

      try assert_equal(type_checker.diagnostics.length, 3)
      try assert_object_instance(node.resolved_type.get, int_type)
    }

    g.test('Passing a keyword argument to a rest argument') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let body = parse('foo(a: 10)')
      let node = body.children[0] as Send
      let int_type = type_checker.builtins.integer_type
      let foo =
        MethodType.new(name: 'foo', layout: BlockLayout.new(int_type.new_instance))

      foo.define_rest_argument(name: 'a', type: int_type.new_instance)

      module.define_method(name: foo.name, type: foo)
      type_checker.check_module(module: module, ast: body)

      try assert_false(type_checker.diagnostics.errors?)
      try assert_object_instance(node.resolved_type.get, int_type)
    }

    g.test('Passing a keyword argument with an incorrect type to a rest argument') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let body = parse('foo(a: 10.5)')
      let node = body.children[0] as Send
      let int_type = type_checker.builtins.integer_type
      let foo =
        MethodType.new(name: 'foo', layout: BlockLayout.new(int_type.new_instance))

      foo.define_rest_argument(name: 'a', type: int_type.new_instance)

      module.define_method(name: foo.name, type: foo)
      type_checker.check_module(module: module, ast: body)

      try assert_true(type_checker.diagnostics.errors?)
      try assert_object_instance(node.resolved_type.get, int_type)
    }

    g.test('Assigning a method type parameter using a positional argument') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let body = parse('foo(10)')
      let node = body.children[0] as Send
      let int_type = type_checker.builtins.integer_type
      let param = TypeParameterType.new('T')
      let foo = MethodType.new(name: 'foo', layout: BlockLayout.new(param))

      foo.type_parameters.define(name: 'T', type: param)
      foo.define_required_argument(name: 'a', type: param)

      module.define_method(name: foo.name, type: foo)
      type_checker.check_module(module: module, ast: body)

      try assert_false(type_checker.diagnostics.errors?)
      try assert_object_instance(node.resolved_type.get, int_type)
    }

    g.test('Assigning a method type parameter using a keyword argument') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let body = parse('foo(a: 10)')
      let node = body.children[0] as Send
      let int_type = type_checker.builtins.integer_type
      let param = TypeParameterType.new('T')
      let foo = MethodType.new(name: 'foo', layout: BlockLayout.new(param))

      foo.type_parameters.define(name: 'T', type: param)
      foo.define_required_argument(name: 'a', type: param)

      module.define_method(name: foo.name, type: foo)
      type_checker.check_module(module: module, ast: body)

      try assert_false(type_checker.diagnostics.errors?)
      try assert_object_instance(node.resolved_type.get, int_type)
    }

    g.test('Assigning a receiver type parameter using a positional argument') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let body = parse('rec.push(10)')
      let node = body.children[0] as Send
      let int_type = type_checker.builtins.integer_type
      let ary_type = type_checker.builtins.array_type
      let ary_param = type_checker
        .builtins
        .array_type
        .lookup_type_parameter(ARRAY_TYPE_PARAMETER)
        .get
        .type

      let push = MethodType.new(name: 'push', layout: BlockLayout.new(ary_param))

      push.define_required_argument(name: 'val', type: ary_param)
      ary_type.instance_methods.define(name: push.name, type: push)

      let rec = ary_type.new_instance

      body.variable_scope.symbols.define(name: 'rec', type: rec)

      type_checker.check_module(module: module, ast: body)

      try assert_false(type_checker.diagnostics.errors?)
      try assert_object_instance(node.resolved_type.get, int_type)
      try assert_object_instance(
        rec.lookup_type_parameter_type(ary_param).get,
        int_type
      )
    }

    g.test('Assigning a receiver type parameter using a keyword argument') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let body = parse('rec.push(val: 10)')
      let node = body.children[0] as Send
      let int_type = type_checker.builtins.integer_type
      let ary_type = type_checker.builtins.array_type
      let ary_param = type_checker
        .builtins
        .array_type
        .lookup_type_parameter(ARRAY_TYPE_PARAMETER)
        .get
        .type

      let push = MethodType.new(name: 'push', layout: BlockLayout.new(ary_param))

      push.define_required_argument(name: 'val', type: ary_param)
      ary_type.instance_methods.define(name: push.name, type: push)

      let rec = ary_type.new_instance

      body.variable_scope.symbols.define(name: 'rec', type: rec)

      type_checker.check_module(module: module, ast: body)

      try assert_false(type_checker.diagnostics.errors?)
      try assert_object_instance(node.resolved_type.get, int_type)
      try assert_object_instance(
        rec.lookup_type_parameter_type(ary_param).get,
        int_type
      )
    }

    g.test('Returning a generic type containing a method type parameter') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let body = parse('foo(10)')
      let node = body.children[0] as Send
      let int_type = type_checker.builtins.integer_type
      let ary_type = type_checker.builtins.array_type
      let param = TypeParameterType.new('T')
      let foo = MethodType.new(
        name: 'foo',
        layout: BlockLayout.new(ary_type.new_instance(Array.new(param)))
      )

      foo.type_parameters.define(name: 'T', type: param)
      foo.define_required_argument(name: 'a', type: param)

      module.define_method(name: foo.name, type: foo)
      type_checker.check_module(module: module, ast: body)

      let type = node.resolved_type.get
      let ary_param = type_checker
        .builtins
        .array_type
        .lookup_type_parameter(ARRAY_TYPE_PARAMETER)
        .get
        .type

      try assert_false(type_checker.diagnostics.errors?)
      try assert_object_instance(type, ary_type)
      try assert_object_instance(
        type.lookup_type_parameter_type(ary_param).get,
        int_type
      )
    }

    g.test('Returning a Self type') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let body = parse('self.foo')
      let node = body.children[0] as Send
      let foo = MethodType.new(name: 'foo', layout: BlockLayout.new(SelfType.new))

      module.define_method(name: foo.name, type: foo)
      type_checker.check_module(module: module, ast: body)

      try assert_false(type_checker.diagnostics.errors?)
      try assert_same_object(node.resolved_type.get, module)
    }

    g.test('Returning a generic type containing a Self type') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let body = parse('self.foo')
      let node = body.children[0] as Send
      let ary_type = type_checker.builtins.array_type
      let param = TypeParameterType.new('T')

      ary_type.type_parameters.define(name: 'T', type: param)

      let foo = MethodType.new(
        name: 'foo',
        layout: BlockLayout.new(ary_type.new_instance(Array.new(SelfType.new))),
      )

      module.define_method(name: foo.name, type: foo)
      type_checker.check_module(module: module, ast: body)

      let type = node.resolved_type.get

      try assert_false(type_checker.diagnostics.errors?)
      try assert_object_instance(type, ary_type)
      try assert_same_object(type.lookup_type_parameter_type(param).get, module)
    }

    g.test('Method type parameters are not assigned in the receiver type') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let body = parse('rec.push(10, 20)')
      let node = body.children[0] as Send
      let int_type = type_checker.builtins.integer_type
      let ary_type = type_checker.builtins.array_type
      let ary_param = type_checker
        .builtins
        .array_type
        .lookup_type_parameter(ARRAY_TYPE_PARAMETER)
        .get
        .type

      let push = MethodType.new(name: 'push', layout: BlockLayout.new(ary_param))
      let b_param = TypeParameterType.new('B')

      push.type_parameters.define(name: b_param.name, type: b_param)
      push.define_required_argument(name: 'val', type: ary_param)
      push.define_required_argument(name: 'foo', type: b_param)

      ary_type.instance_methods.define(name: push.name, type: push)

      let rec = ary_type.new_instance

      body.variable_scope.symbols.define(name: 'rec', type: rec)
      type_checker.check_module(module: module, ast: body)

      try assert_false(type_checker.diagnostics.errors?)
      try assert_object_instance(node.resolved_type.get, int_type)
      try assert_object_instance(
        rec.lookup_type_parameter_type(ary_param).get,
        int_type
      )
      try assert_true(rec.lookup_type_parameter_type(b_param).none?)
    }

    g.test('Assigning a method type parameter using a closure') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let builtins = type_checker.builtins
      let body = parse('foo { 10 }')
      let node = body.children[0] as Send
      let param = TypeParameterType.new('R')
      let foo = MethodType.new(name: 'foo', layout: BlockLayout.new(param))

      foo.type_parameters.define(name: param.name, type: param)
      foo
        .define_required_argument('block', ClosureType.new(BlockLayout.new(param)))

      module.define_method(name: foo.name, type: foo)
      type_checker.check_module(module: module, ast: body)

      try assert_false(type_checker.diagnostics.errors?)
      try assert_object_instance(node.resolved_type.get, builtins.integer_type)
    }

    g.test('Assigning a method type parameter using a lambda') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let builtins = type_checker.builtins
      let body = parse('foo fn { 10 }')
      let node = body.children[0] as Send
      let param = TypeParameterType.new('R')
      let foo = MethodType.new(name: 'foo', layout: BlockLayout.new(param))

      foo.type_parameters.define(name: param.name, type: param)
      foo
        .define_required_argument('block', LambdaType.new(BlockLayout.new(param)))

      module.define_method(name: foo.name, type: foo)
      type_checker.check_module(module: module, ast: body)

      try assert_false(type_checker.diagnostics.errors?)
      try assert_object_instance(node.resolved_type.get, builtins.integer_type)
    }

    g.test('Assigning a method type parameter using an object') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let int_type = type_checker.builtins.integer_type
      let body = parse('foo(a)')
      let node = body.children[0] as Send
      let list_type = ClassType.new('List')
      let list_param = TypeParameterType.new('T')

      list_type.type_parameters.define(name: list_param.name, type: list_param)

      let param = TypeParameterType.new('R')
      let foo = MethodType.new(name: 'foo', layout: BlockLayout.new(param))

      foo.type_parameters.define(name: param.name, type: param)
      foo.define_required_argument(
        'list',
        list_type.new_instance(Array.new(param))
      )

      body.variable_scope.symbols.define(
        name: 'a',
        type: list_type.new_instance(Array.new(int_type.new_instance))
      )

      module.define_method(name: foo.name, type: foo)
      type_checker.check_module(module: module, ast: body)

      try assert_false(type_checker.diagnostics.errors?)
      try assert_object_instance(node.resolved_type.get, int_type)
    }

    g.test('Assigning a method type parameter using a trait') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let int_type = type_checker.builtins.integer_type
      let body = parse('foo(a)')
      let node = body.children[0] as Send
      let to_list_type = TraitType.new('ToList')
      let to_list_param = TypeParameterType.new('T')

      to_list_type
        .type_parameters
        .define(name: to_list_param.name, type: to_list_param)

      # def foo!(R)(list: ToList!(R)) -> R
      let param = TypeParameterType.new('R')
      let foo = MethodType.new(name: 'foo', layout: BlockLayout.new(param))

      foo.type_parameters.define(name: param.name, type: param)
      foo.define_required_argument(
        'list',
        to_list_type.new_instance(Array.new(param))
      )

      body.variable_scope.symbols.define(
        name: 'a',
        type: to_list_type.new_instance(Array.new(int_type.new_instance))
      )

      module.define_method(name: foo.name, type: foo)
      type_checker.check_module(module: module, ast: body)

      try assert_false(type_checker.diagnostics.errors?)
      try assert_object_instance(node.resolved_type.get, int_type)
    }

    g.test('Sending an identifier message of which the error type is Never') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let int_type = type_checker.builtins.integer_type
      let body = parse('foo')
      let node = body.children[0]
      let layout = BlockLayout.new(
        return_type: int_type.new_instance,
        throw_type: Option.some(NeverType.new)
      )

      let foo = MethodType.new(name: 'foo', layout: layout)

      module.define_method(name: foo.name, type: foo)
      type_checker.check_module(module: module, ast: body)

      try assert_false(type_checker.diagnostics.errors?)
      try assert_object_instance(node.resolved_type.get, int_type)
    }

    g.test('Sending a message of which the error type is Never') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let int_type = type_checker.builtins.integer_type
      let body = parse('foo()')
      let node = body.children[0]
      let layout = BlockLayout.new(
        return_type: int_type.new_instance,
        throw_type: Option.some(NeverType.new)
      )

      let foo = MethodType.new(name: 'foo', layout: layout)

      module.define_method(name: foo.name, type: foo)
      type_checker.check_module(module: module, ast: body)

      try assert_false(type_checker.diagnostics.errors?)
      try assert_object_instance(node.resolved_type.get, int_type)
    }

    g.test('Sending a message defined in the Object trait while in a trait instance') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let body = parse('trait A { def foo { bar } }')

      let bootstrap = ModuleType.new(BOOTSTRAP_MODULE)
      let object_trait = TraitType.new(OBJECT_TRAIT)
      let bar = MethodType.new(name: 'bar', layout: BlockLayout.new(AnyType.new))

      bootstrap.constants.define(name: object_trait.name, type: object_trait)
      object_trait.default_methods.define(name: bar.name, type: bar)
      type_checker.add_module(bootstrap)
      type_checker.check_module(module: module, ast: body)

      try assert_false(type_checker.diagnostics.errors?)
    }

    g.test('Sending a message to a type parameter that responds to the message') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let str_type = type_checker.builtins.string_type
      let to_string_trait = TraitType.new('ToString')
      let to_string = MethodType
        .new(name: 'to_string', layout: BlockLayout.new(str_type.new_instance))

      to_string_trait
        .default_methods
        .define(name: to_string.name, type: to_string)

      let param = TypeParameterType
        .new(name: 'T', required_traits: Array.new(to_string_trait.new_instance))

      let body = parse('a.to_string')
      let node = body.children[0]

      body.variable_scope.symbols.define(name: 'a', type: param)
      type_checker.check_module(module: module, ast: body)

      try assert_false(type_checker.diagnostics.errors?)
      try assert_object_instance(node.resolved_type.get, str_type)
    }

    g.test('Sending an undefined message to a type parameter') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let param = TypeParameterType.new('T')
      let body = parse('a.test')
      let node = body.children[0]

      body.variable_scope.symbols.define(name: 'a', type: param)
      type_checker.check_module(module: module, ast: body)

      try assert_true(type_checker.diagnostics.errors?)
      try assert_true(node.resolved_type.get.error?)
    }
  }

  t.group('Type-checking sending messages with method bounds') do (g) {
    g.test('Sending a message that is not available') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let body = parse('rec.push(10)')
      let node = body.children[0] as Send
      let bla_type = TraitType.new('Bla')
      let ary_type = type_checker.builtins.array_type
      let ary_param = type_checker
        .builtins
        .array_type
        .lookup_type_parameter(ARRAY_TYPE_PARAMETER)
        .get
        .type

      # This defines the method as `def push(val: T) when T: Bla`
      let push = MethodType.new(name: 'push', layout: BlockLayout.new(ary_param))

      push.define_required_argument(name: 'val', type: ary_param)

      push.type_parameter_bounds.define(
        parameter: ary_param,
        requirements: Array.new(bla_type.new_instance)
      )

      ary_type.instance_methods.define(name: push.name, type: push)

      let rec = ary_type.new_instance

      body.variable_scope.symbols.define(name: 'rec', type: rec)

      type_checker.check_module(module: module, ast: body)

      try assert_true(type_checker.diagnostics.errors?)
      try assert_true(node.resolved_type.get.error?)
    }

    g.test('Sending a message that is available') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let body = parse('rec.push(10)')
      let node = body.children[0] as Send
      let bla_type = TraitType.new('Bla')
      let int_type = type_checker.builtins.integer_type
      let ary_type = type_checker.builtins.array_type
      let ary_param = type_checker
        .builtins
        .array_type
        .lookup_type_parameter(ARRAY_TYPE_PARAMETER)
        .get
        .type

      int_type
        .add_trait_implementation(TraitImplementation.new(bla_type.new_instance))

      # This defines the method as `def push(val: T) when T: Bla`
      let push = MethodType.new(name: 'push', layout: BlockLayout.new(ary_param))

      push.define_required_argument(name: 'val', type: ary_param)

      push.type_parameter_bounds.define(
        parameter: ary_param,
        requirements: Array.new(bla_type.new_instance)
      )

      ary_type.instance_methods.define(name: push.name, type: push)

      let rec = ary_type.new_instance

      body.variable_scope.symbols.define(name: 'rec', type: rec)

      type_checker.check_module(module: module, ast: body)

      try assert_false(type_checker.diagnostics.errors?)
      try assert_object_instance(node.resolved_type.get, int_type)
    }
  }

  t.group('Type-checking sending "call" to blocks') do (g) {
    g.test('Sending the "call" message to a closure') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let body = parse('foo.call(10)')
      let node = body.children[0] as Send
      let int_type = type_checker.builtins.integer_type
      let foo = ClosureType.new(BlockLayout.new(int_type.new_instance))

      foo.define_required_argument(name: 'a', type: int_type.new_instance)

      body.variable_scope.symbols.define(name: 'foo', type: foo)
      type_checker.check_module(module: module, ast: body)

      try assert_false(type_checker.diagnostics.errors?)
      try assert_object_instance(node.resolved_type.get, int_type)
    }

    g.test('Sending the "call" message to a lambda') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let body = parse('foo.call(10)')
      let node = body.children[0] as Send
      let int_type = type_checker.builtins.integer_type
      let foo = LambdaType.new(BlockLayout.new(int_type.new_instance))

      foo.define_required_argument(name: 'a', type: int_type.new_instance)

      body.variable_scope.symbols.define(name: 'foo', type: foo)
      type_checker.check_module(module: module, ast: body)

      try assert_false(type_checker.diagnostics.errors?)
      try assert_object_instance(node.resolved_type.get, int_type)
    }

    g.test('Sending the "call" message to a method') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let body = parse('foo.call(10)')
      let node = body.children[0] as Send
      let int_type = type_checker.builtins.integer_type
      let foo =
        MethodType.new(name: 'foo', layout: BlockLayout.new(int_type.new_instance))

      foo.define_required_argument(name: 'a', type: int_type.new_instance)

      body.variable_scope.symbols.define(name: foo.name, type: foo)
      type_checker.check_module(module: module, ast: body)

      try assert_true(type_checker.diagnostics.errors?)
      try assert_true(node.resolved_type.get.error?)
    }

    g.test('Sending the "call" message when it may throw an unhandled error') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let body = parse('foo.call')
      let int_type = type_checker.builtins.integer_type
      let foo = ClosureType.new(
        BlockLayout.new(
          return_type: int_type.new_instance,
          throw_type: Option.some(int_type.new_instance)
        )
      )

      body.variable_scope.symbols.define(name: 'foo', type: foo)
      type_checker.check_module(module: module, ast: body)

      try assert_true(type_checker.diagnostics.errors?)
    }
  }

  t.group('Type-checking imported methods') do (g) {
    g.test('Calling an imported method without arguments') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let int_type = type_checker.builtins.integer_type
      let body = parse('foo')
      let node = body.children[0]
      let foo = MethodType
        .new(name: 'foo', layout: BlockLayout.new(int_type.new_instance))

      module.globals.define(name: foo.name, type: foo)
      type_checker.check_module(module: module, ast: body)

      try assert_false(type_checker.diagnostics.errors?)
      try assert_object_instance(node.resolved_type.get, int_type)
    }

    g.test('Calling an imported method with arguments') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let int_type = type_checker.builtins.integer_type
      let body = parse('foo(10)')
      let node = body.children[0]
      let foo = MethodType
        .new(name: 'foo', layout: BlockLayout.new(int_type.new_instance))

      foo.define_required_argument(name: 'a', type: int_type.new_instance)
      module.globals.define(name: foo.name, type: foo)
      type_checker.check_module(module: module, ast: body)

      try assert_false(type_checker.diagnostics.errors?)
      try assert_object_instance(node.resolved_type.get, int_type)
    }
  }

  t.group('Type-checking the `try` keyword') do (g) {
    g.test('Re-throwing outside of a block using an identifier') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let body = parse('try foo')
      let node = body.children[0] as Try
      let ident = node.expression as Identifier
      let int_type = type_checker.builtins.integer_type
      let float_type = type_checker.builtins.float_type
      let foo = MethodType.new(
        name: 'foo',
        layout: BlockLayout.new(
          return_type: int_type.new_instance,
          throw_type: Option.some(float_type.new_instance)
        )
      )

      module.define_method(name: foo.name, type: foo)

      type_checker.check_module(module: module, ast: body)

      try assert_true(type_checker.diagnostics.errors?)
      try assert_object_instance(node.resolved_throw_type.get, float_type)
      try assert_object_instance(node.resolved_type.get, int_type)
      try assert_object_instance(ident.resolved_throw_type.get, float_type)
    }

    g.test('Re-throwing outside of a block using a message send') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let body = parse('try foo()')
      let node = body.children[0] as Try
      let send = node.expression as Send
      let int_type = type_checker.builtins.integer_type
      let float_type = type_checker.builtins.float_type
      let foo = MethodType.new(
        name: 'foo',
        layout: BlockLayout.new(
          return_type: int_type.new_instance,
          throw_type: Option.some(float_type.new_instance)
        )
      )

      module.define_method(name: foo.name, type: foo)

      type_checker.check_module(module: module, ast: body)

      try assert_true(type_checker.diagnostics.errors?)
      try assert_object_instance(node.resolved_type.get, int_type)
      try assert_object_instance(send.resolved_throw_type.get, float_type)
    }

    g.test("Re-throwing an error with an expression that doesn't throw") {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let body = parse('def bar { try 10 }')
      let block = body.children[0] as DefineMethod
      let node = block.body.children[0] as Try

      type_checker.check_module(module: module, ast: body)

      try assert_true(type_checker.diagnostics.errors?)
      try assert_true(node.resolved_throw_type.get.error?)
      try assert_object_instance(
        node.resolved_type.get,
        type_checker.builtins.integer_type
      )
    }

    g.test("Handling an error with an expression that doesn't throw") {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let body = parse('def bar { try 10 else 20 }')
      let block = body.children[0] as DefineMethod
      let node = block.body.children[0] as Try

      type_checker.check_module(module: module, ast: body)

      try assert_true(type_checker.diagnostics.errors?)
      try assert_object_instance(
        node.resolved_type.get,
        type_checker.builtins.integer_type
      )
    }

    g.test('Re-throwing an error in a method that has no explicit error type') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let body = parse('def bar { try foo }')
      let block = body.children[0] as DefineMethod
      let node = block.body.children[0] as Try
      let int_type = type_checker.builtins.integer_type
      let foo = MethodType.new(
        name: 'foo',
        layout: BlockLayout.new(
          return_type: int_type.new_instance,
          throw_type: Option.some(int_type.new_instance)
        )
      )

      module.define_method(name: foo.name, type: foo)

      type_checker.check_module(module: module, ast: body)

      try assert_true(type_checker.diagnostics.errors?)
      try assert_object_instance(node.resolved_type.get, int_type)
    }

    g.test('Re-throwing an incompatible error type') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let body = parse('def bar !! Int { try foo }')
      let block = body.children[0] as DefineMethod
      let node = block.body.children[0] as Try
      let int_type = type_checker.builtins.integer_type
      let float_type = type_checker.builtins.float_type
      let foo = MethodType.new(
        name: 'foo',
        layout: BlockLayout.new(
          return_type: int_type.new_instance,
          throw_type: Option.some(float_type.new_instance)
        )
      )

      module.define_method(name: foo.name, type: foo)
      module.define_constant(name: int_type.name, type: int_type)

      type_checker.check_module(module: module, ast: body)

      try assert_true(type_checker.diagnostics.errors?)
      try assert_object_instance(node.resolved_type.get, int_type)
    }

    g.test('Handling an error thrown by a method') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let body = parse('def bar { try foo else 10 }')
      let block = body.children[0] as DefineMethod
      let node = block.body.children[0] as Try

      let int_type = type_checker.builtins.integer_type
      let float_type = type_checker.builtins.float_type
      let foo = MethodType.new(
        name: 'foo',
        layout: BlockLayout.new(
          return_type: int_type.new_instance,
          throw_type: Option.some(float_type.new_instance)
        )
      )

      module.define_method(name: foo.name, type: foo)
      module.define_constant(name: int_type.name, type: int_type)

      type_checker.check_module(module: module, ast: body)

      try assert_false(type_checker.diagnostics.errors?)
      try assert_object_instance(node.resolved_type.get, int_type)
    }

    g.test('Handling an error with an incompatible else type') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let body = parse('def bar { try foo else 10.5 }')
      let block = body.children[0] as DefineMethod
      let node = block.body.children[0] as Try

      let int_type = type_checker.builtins.integer_type
      let float_type = type_checker.builtins.float_type
      let foo = MethodType.new(
        name: 'foo',
        layout: BlockLayout.new(
          return_type: int_type.new_instance,
          throw_type: Option.some(float_type.new_instance)
        )
      )

      module.define_method(name: foo.name, type: foo)
      module.define_constant(name: int_type.name, type: int_type)

      type_checker.check_module(module: module, ast: body)

      try assert_true(type_checker.diagnostics.errors?)
      try assert_true(node.resolved_type.get.error?)
    }

    g.test('Defining a local variable in the else body') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let body = parse('def bar { try foo else { let a = 10 } }')
      let block = body.children[0] as DefineMethod
      let node = block.body.children[0] as Try

      let int_type = type_checker.builtins.integer_type
      let float_type = type_checker.builtins.float_type
      let foo = MethodType.new(
        name: 'foo',
        layout: BlockLayout.new(
          return_type: int_type.new_instance,
          throw_type: Option.some(float_type.new_instance)
        )
      )

      module.define_method(name: foo.name, type: foo)

      type_checker.check_module(module: module, ast: body)

      let else_vars = node.else_body.variable_scope

      try assert_true(body.variable_scope.lookup('a').none?)
      try assert_true(block.body.variable_scope.lookup('a').none?)

      try assert_object_instance(else_vars.lookup('a').get.type, int_type)
      try assert_true(else_vars.parent.get.same_object?(block.body.variable_scope))
    }

    g.test('Defining a variable to store the thrown error in') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let body = parse('def bar { try foo else (error) error }')
      let block = body.children[0] as DefineMethod
      let node = block.body.children[0] as Try

      let int_type = type_checker.builtins.integer_type
      let foo = MethodType.new(
        name: 'foo',
        layout: BlockLayout.new(
          return_type: int_type.new_instance,
          throw_type: Option.some(int_type.new_instance)
        )
      )

      module.define_method(name: foo.name, type: foo)

      type_checker.check_module(module: module, ast: body)

      try assert_object_instance(
        node.else_body.variable_scope.lookup('error').get.type,
        int_type
      )
    }

    g.test('Using a method that throws in a closure inside a `try`') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let body = parse('def bla !! Int { try foo({ bar }) }')
      let int_type = type_checker.builtins.integer_type
      let foo = MethodType.new(
        name: 'foo',
        layout: BlockLayout.new(
          return_type: int_type.new_instance,
          throw_type: Option.some(int_type.new_instance)
        )
      )

      let val_type = ClosureType.new(
        BlockLayout.new(
          return_type: int_type.new_instance,
          throw_type: Option.some(int_type.new_instance)
        )
      )

      foo.define_required_argument(name: 'val', type: val_type)

      let bar = MethodType.new(
        name: 'bar',
        layout: BlockLayout.new(
          return_type: int_type.new_instance,
          throw_type: Option.some(int_type.new_instance)
        )
      )

      module.define_method(name: foo.name, type: foo)
      module.define_method(name: bar.name, type: bar)
      module.define_constant(name: int_type.name, type: int_type)

      type_checker.check_module(module: module, ast: body)

      try assert_true(type_checker.diagnostics.errors?)
      try assert_equal(type_checker.diagnostics.length, 1)
    }

    g.test('Passing a called closure that throws as an argument in a `try`') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let body = parse('def bla !! Int { try foo({ try bar }.call) }')
      let int_type = type_checker.builtins.integer_type
      let float_type = type_checker.builtins.float_type
      let foo = MethodType.new(
        name: 'foo',
        layout: BlockLayout.new(
          return_type: int_type.new_instance,
          throw_type: Option.some(int_type.new_instance)
        )
      )

      foo.define_required_argument(name: 'val', type: int_type.new_instance)

      let bar = MethodType.new(
        name: 'bar',
        layout: BlockLayout.new(
          return_type: int_type.new_instance,
          throw_type: Option.some(float_type.new_instance)
        )
      )

      module.define_method(name: foo.name, type: foo)
      module.define_method(name: bar.name, type: bar)
      module.define_constant(name: int_type.name, type: int_type)

      type_checker.check_module(module: module, ast: body)

      try assert_true(type_checker.diagnostics.errors?)
      try assert_equal(type_checker.diagnostics.length, 1)
    }
  }

  t.group('Type-checking the `try!` keyword') do (g) {
    g.test("Handling an error with an expression that doesn't throw") {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let body = parse('try! 10')
      let node = body.children[0] as TryPanic

      type_checker.check_module(module: module, ast: body)

      try assert_true(type_checker.diagnostics.errors?)
      try assert_true(node.resolved_throw_type.get.error?)
      try assert_object_instance(
        node.resolved_type.get,
        type_checker.builtins.integer_type
      )
    }

    g.test('Handling an error with an expression that throws') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let body = parse('try! foo')
      let node = body.children[0] as TryPanic
      let int_type = type_checker.builtins.integer_type
      let float_type = type_checker.builtins.float_type
      let foo = MethodType.new(
        name: 'foo',
        layout: BlockLayout.new(
          return_type: int_type.new_instance,
          throw_type: Option.some(float_type.new_instance)
        )
      )

      module.define_method(name: foo.name, type: foo)
      type_checker.check_module(module: module, ast: body)

      try assert_false(type_checker.diagnostics.errors?)
      try assert_object_instance(node.resolved_throw_type.get, float_type)
      try assert_object_instance(node.resolved_type.get, int_type)
    }
  }

  t.group('Type-checking an unknown instruction') do (g) {
    g.test('Unknown instructions produce a compiler error') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let int_type = type_checker.builtins.integer_type
      let body = parse('_INKOC.foo')
      let node = body.children[0]

      module.define_constant(name: int_type.name, type: int_type)
      type_checker.check_module(module: module, ast: body)

      try assert_true(node.resolved_type.get.error?)
      try assert_true(type_checker.diagnostics.errors?)
    }
  }

  t.group('Type-checking VM instructions') do (g) {
    g.test('VM instructions can only be used in the standard library') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let body = parse('_INKOC.get_attribute')
      let node = body.children[0]

      type_checker.check_module(module: module, ast: body)

      try assert_true(type_checker.diagnostics.errors?)
      try assert_true(node.resolved_type.get.error?)
    }

    g.test('Using get_true()') {
      let module = new_std_module('foo')
      let type_checker = new_type_checker
      let body = parse('_INKOC.get_true')
      let node = body.children[0]

      type_checker.check_module(module: module, ast: body)

      try assert_false(type_checker.diagnostics.errors?)
      try assert_same_object(
        node.resolved_type.get,
        type_checker.builtins.true_singleton
      )
    }

    g.test('Using get_false()') {
      let module = new_std_module('foo')
      let type_checker = new_type_checker
      let body = parse('_INKOC.get_false')
      let node = body.children[0]

      type_checker.check_module(module: module, ast: body)

      try assert_false(type_checker.diagnostics.errors?)
      try assert_same_object(
        node.resolved_type.get,
        type_checker.builtins.false_singleton
      )
    }

    g.test('Using set_attribute()') {
      let module = new_std_module('foo')
      let type_checker = new_type_checker
      let body = parse('_INKOC.set_attribute')
      let node = body.children[0]

      type_checker.check_module(module: module, ast: body)

      try assert_false(type_checker.diagnostics.errors?)
      try assert_instance_of(node.resolved_type.get, AnyType)
    }

    g.test('Using get_attribute()') {
      let module = new_std_module('foo')
      let type_checker = new_type_checker
      let int_type = type_checker.builtins.integer_type
      let body = parse('_INKOC.get_attribute(a, "foo")')
      let node = body.children[0]
      let foo_type = ClassType.new('Foo')

      body.variable_scope.symbols.define(name: 'a', type: foo_type.new_instance)
      module.define_constant(name: int_type.name, type: int_type)
      type_checker.check_module(module: module, ast: body)

      try assert_false(type_checker.diagnostics.errors?)
      try assert_instance_of(node.resolved_type.get, AnyType)
    }

    g.test('Using object_equals()') {
      let module = new_std_module('foo')
      let type_checker = new_type_checker
      let body = parse('_INKOC.object_equals(10, 10)')
      let node = body.children[0]

      type_checker.check_module(module: module, ast: body)

      try assert_false(type_checker.diagnostics.errors?)
      try assert_object_instance(
        node.resolved_type.get,
        type_checker.builtins.boolean_type
      )
    }

    g.test('Using copy_blocks()') {
      let module = new_std_module('foo')
      let type_checker = new_type_checker
      let body = parse('_INKOC.copy_blocks(foo, bar)')
      let node = body.children[0]
      let foo_type = ClassType.new('Foo')
      let bar_type = ClassType.new('Bar')

      body.variable_scope.symbols.define(name: 'foo', type: foo_type)
      body.variable_scope.symbols.define(name: 'bar', type: bar_type)
      type_checker.check_module(module: module, ast: body)

      try assert_false(type_checker.diagnostics.errors?)
      try assert_instance_of(node.resolved_type.get, NeverType)
    }

    g.test('Using integer_add()') {
      let module = new_std_module('foo')
      let type_checker = new_type_checker
      let body = parse('_INKOC.integer_add(10, 10)')
      let node = body.children[0]

      type_checker.check_module(module: module, ast: body)

      try assert_false(type_checker.diagnostics.errors?)
      try assert_object_instance(
        node.resolved_type.get,
        type_checker.builtins.integer_type
      )
    }

    g.test('Using integer_div()') {
      let module = new_std_module('foo')
      let type_checker = new_type_checker
      let body = parse('_INKOC.integer_div(10, 10)')
      let node = body.children[0]

      type_checker.check_module(module: module, ast: body)

      try assert_false(type_checker.diagnostics.errors?)
      try assert_object_instance(
        node.resolved_type.get,
        type_checker.builtins.integer_type
      )
    }

    g.test('Using integer_mul()') {
      let module = new_std_module('foo')
      let type_checker = new_type_checker
      let body = parse('_INKOC.integer_mul(10, 10)')
      let node = body.children[0]

      type_checker.check_module(module: module, ast: body)

      try assert_false(type_checker.diagnostics.errors?)
      try assert_object_instance(
        node.resolved_type.get,
        type_checker.builtins.integer_type
      )
    }

    g.test('Using integer_sub()') {
      let module = new_std_module('foo')
      let type_checker = new_type_checker
      let body = parse('_INKOC.integer_sub(10, 10)')
      let node = body.children[0]

      type_checker.check_module(module: module, ast: body)

      try assert_false(type_checker.diagnostics.errors?)
      try assert_object_instance(
        node.resolved_type.get,
        type_checker.builtins.integer_type
      )
    }

    g.test('Using integer_mod()') {
      let module = new_std_module('foo')
      let type_checker = new_type_checker
      let body = parse('_INKOC.integer_mod(10, 10)')
      let node = body.children[0]

      type_checker.check_module(module: module, ast: body)

      try assert_false(type_checker.diagnostics.errors?)
      try assert_object_instance(
        node.resolved_type.get,
        type_checker.builtins.integer_type
      )
    }

    g.test('Using integer_bitwise_and()') {
      let module = new_std_module('foo')
      let type_checker = new_type_checker
      let body = parse('_INKOC.integer_bitwise_and(10, 10)')
      let node = body.children[0]

      type_checker.check_module(module: module, ast: body)

      try assert_false(type_checker.diagnostics.errors?)
      try assert_object_instance(
        node.resolved_type.get,
        type_checker.builtins.integer_type
      )
    }

    g.test('Using integer_bitwise_or()') {
      let module = new_std_module('foo')
      let type_checker = new_type_checker
      let body = parse('_INKOC.integer_bitwise_or(10, 10)')
      let node = body.children[0]

      type_checker.check_module(module: module, ast: body)

      try assert_false(type_checker.diagnostics.errors?)
      try assert_object_instance(
        node.resolved_type.get,
        type_checker.builtins.integer_type
      )
    }

    g.test('Using integer_bitwise_xor()') {
      let module = new_std_module('foo')
      let type_checker = new_type_checker
      let body = parse('_INKOC.integer_bitwise_xor(10, 10)')
      let node = body.children[0]

      type_checker.check_module(module: module, ast: body)

      try assert_false(type_checker.diagnostics.errors?)
      try assert_object_instance(
        node.resolved_type.get,
        type_checker.builtins.integer_type
      )
    }

    g.test('Using integer_shift_left()') {
      let module = new_std_module('foo')
      let type_checker = new_type_checker
      let body = parse('_INKOC.integer_shift_left(10, 10)')
      let node = body.children[0]

      type_checker.check_module(module: module, ast: body)

      try assert_false(type_checker.diagnostics.errors?)
      try assert_object_instance(
        node.resolved_type.get,
        type_checker.builtins.integer_type
      )
    }

    g.test('Using integer_shift_right()') {
      let module = new_std_module('foo')
      let type_checker = new_type_checker
      let body = parse('_INKOC.integer_shift_right(10, 10)')
      let node = body.children[0]

      type_checker.check_module(module: module, ast: body)

      try assert_false(type_checker.diagnostics.errors?)
      try assert_object_instance(
        node.resolved_type.get,
        type_checker.builtins.integer_type
      )
    }

    g.test('Using integer_smaller()') {
      let module = new_std_module('foo')
      let type_checker = new_type_checker
      let body = parse('_INKOC.integer_smaller(10, 10)')
      let node = body.children[0]

      type_checker.check_module(module: module, ast: body)

      try assert_false(type_checker.diagnostics.errors?)
      try assert_object_instance(
        node.resolved_type.get,
        type_checker.builtins.boolean_type
      )
    }

    g.test('Using integer_greater()') {
      let module = new_std_module('foo')
      let type_checker = new_type_checker
      let body = parse('_INKOC.integer_greater(10, 10)')
      let node = body.children[0]

      type_checker.check_module(module: module, ast: body)

      try assert_false(type_checker.diagnostics.errors?)
      try assert_object_instance(
        node.resolved_type.get,
        type_checker.builtins.boolean_type
      )
    }

    g.test('Using integer_equals()') {
      let module = new_std_module('foo')
      let type_checker = new_type_checker
      let body = parse('_INKOC.integer_equals(10, 10)')
      let node = body.children[0]

      type_checker.check_module(module: module, ast: body)

      try assert_false(type_checker.diagnostics.errors?)
      try assert_object_instance(
        node.resolved_type.get,
        type_checker.builtins.boolean_type
      )
    }

    g.test('Using integer_greater_or_equal()') {
      let module = new_std_module('foo')
      let type_checker = new_type_checker
      let body = parse('_INKOC.integer_greater_or_equal(10, 10)')
      let node = body.children[0]

      type_checker.check_module(module: module, ast: body)

      try assert_false(type_checker.diagnostics.errors?)
      try assert_object_instance(
        node.resolved_type.get,
        type_checker.builtins.boolean_type
      )
    }

    g.test('Using integer_smaller_or_equal()') {
      let module = new_std_module('foo')
      let type_checker = new_type_checker
      let body = parse('_INKOC.integer_smaller_or_equal(10, 10)')
      let node = body.children[0]

      type_checker.check_module(module: module, ast: body)

      try assert_false(type_checker.diagnostics.errors?)
      try assert_object_instance(
        node.resolved_type.get,
        type_checker.builtins.boolean_type
      )
    }

    g.test('Using float_add()') {
      let module = new_std_module('foo')
      let type_checker = new_type_checker
      let body = parse('_INKOC.float_add(10.5, 10.5)')
      let node = body.children[0]

      type_checker.check_module(module: module, ast: body)

      try assert_false(type_checker.diagnostics.errors?)
      try assert_object_instance(
        node.resolved_type.get,
        type_checker.builtins.float_type
      )
    }

    g.test('Using float_div()') {
      let module = new_std_module('foo')
      let type_checker = new_type_checker
      let body = parse('_INKOC.float_div(10.5, 10.5)')
      let node = body.children[0]

      type_checker.check_module(module: module, ast: body)

      try assert_false(type_checker.diagnostics.errors?)
      try assert_object_instance(
        node.resolved_type.get,
        type_checker.builtins.float_type
      )
    }

    g.test('Using float_mul()') {
      let module = new_std_module('foo')
      let type_checker = new_type_checker
      let body = parse('_INKOC.float_mul(10.5, 10.5)')
      let node = body.children[0]

      type_checker.check_module(module: module, ast: body)

      try assert_false(type_checker.diagnostics.errors?)
      try assert_object_instance(
        node.resolved_type.get,
        type_checker.builtins.float_type
      )
    }

    g.test('Using float_sub()') {
      let module = new_std_module('foo')
      let type_checker = new_type_checker
      let body = parse('_INKOC.float_sub(10.5, 10.5)')
      let node = body.children[0]

      type_checker.check_module(module: module, ast: body)

      try assert_false(type_checker.diagnostics.errors?)
      try assert_object_instance(
        node.resolved_type.get,
        type_checker.builtins.float_type
      )
    }

    g.test('Using float_mod()') {
      let module = new_std_module('foo')
      let type_checker = new_type_checker
      let body = parse('_INKOC.float_mod(10.5, 10.5)')
      let node = body.children[0]

      type_checker.check_module(module: module, ast: body)

      try assert_false(type_checker.diagnostics.errors?)
      try assert_object_instance(
        node.resolved_type.get,
        type_checker.builtins.float_type
      )
    }

    g.test('Using float_smaller()') {
      let module = new_std_module('foo')
      let type_checker = new_type_checker
      let body = parse('_INKOC.float_smaller(10.5, 10.5)')
      let node = body.children[0]

      type_checker.check_module(module: module, ast: body)

      try assert_false(type_checker.diagnostics.errors?)
      try assert_object_instance(
        node.resolved_type.get,
        type_checker.builtins.boolean_type
      )
    }

    g.test('Using float_greater()') {
      let module = new_std_module('foo')
      let type_checker = new_type_checker
      let body = parse('_INKOC.float_greater(10.5, 10.5)')
      let node = body.children[0]

      type_checker.check_module(module: module, ast: body)

      try assert_false(type_checker.diagnostics.errors?)
      try assert_object_instance(
        node.resolved_type.get,
        type_checker.builtins.boolean_type
      )
    }

    g.test('Using float_equals()') {
      let module = new_std_module('foo')
      let type_checker = new_type_checker
      let body = parse('_INKOC.float_equals(10.5, 10.5)')
      let node = body.children[0]

      type_checker.check_module(module: module, ast: body)

      try assert_false(type_checker.diagnostics.errors?)
      try assert_object_instance(
        node.resolved_type.get,
        type_checker.builtins.boolean_type
      )
    }

    g.test('Using float_greater_or_equal()') {
      let module = new_std_module('foo')
      let type_checker = new_type_checker
      let body = parse('_INKOC.float_greater_or_equal(10.5, 10.5)')
      let node = body.children[0]

      type_checker.check_module(module: module, ast: body)

      try assert_false(type_checker.diagnostics.errors?)
      try assert_object_instance(
        node.resolved_type.get,
        type_checker.builtins.boolean_type
      )
    }

    g.test('Using float_smaller_or_equal()') {
      let module = new_std_module('foo')
      let type_checker = new_type_checker
      let body = parse('_INKOC.float_smaller_or_equal(10.5, 10.5)')
      let node = body.children[0]

      type_checker.check_module(module: module, ast: body)

      try assert_false(type_checker.diagnostics.errors?)
      try assert_object_instance(
        node.resolved_type.get,
        type_checker.builtins.boolean_type
      )
    }

    g.test('Using get_nil()') {
      let module = new_std_module('foo')
      let type_checker = new_type_checker
      let body = parse('_INKOC.get_nil')
      let node = body.children[0]

      type_checker.check_module(module: module, ast: body)

      try assert_false(type_checker.diagnostics.errors?)
      try assert_same_object(
        node.resolved_type.get,
        type_checker.builtins.nil_singleton
      )
    }

    g.test('Using get_nil_prototype()') {
      let module = new_std_module('foo')
      let type_checker = new_type_checker
      let body = parse('_INKOC.get_nil_prototype')
      let node = body.children[0]

      type_checker.check_module(module: module, ast: body)

      try assert_false(type_checker.diagnostics.errors?)
      try assert_same_object(node.resolved_type.get, type_checker.builtins.nil_type)
    }

    g.test('Using get_module_prototype()') {
      let module = new_std_module('foo')
      let type_checker = new_type_checker
      let body = parse('_INKOC.get_module_prototype')
      let node = body.children[0]

      type_checker.check_module(module: module, ast: body)

      try assert_false(type_checker.diagnostics.errors?)
      try assert_same_object(node.resolved_type.get, type_checker.builtins.module_type)
    }

    g.test('Using get_string_prototype()') {
      let module = new_std_module('foo')
      let type_checker = new_type_checker
      let body = parse('_INKOC.get_string_prototype')
      let node = body.children[0]

      type_checker.check_module(module: module, ast: body)

      try assert_false(type_checker.diagnostics.errors?)
      try assert_same_object(node.resolved_type.get, type_checker.builtins.string_type)
    }

    g.test('Using get_integer_prototype()') {
      let module = new_std_module('foo')
      let type_checker = new_type_checker
      let body = parse('_INKOC.get_integer_prototype')
      let node = body.children[0]

      type_checker.check_module(module: module, ast: body)

      try assert_false(type_checker.diagnostics.errors?)
      try assert_same_object(node.resolved_type.get, type_checker.builtins.integer_type)
    }

    g.test('Using get_float_prototype()') {
      let module = new_std_module('foo')
      let type_checker = new_type_checker
      let body = parse('_INKOC.get_float_prototype')
      let node = body.children[0]

      type_checker.check_module(module: module, ast: body)

      try assert_false(type_checker.diagnostics.errors?)
      try assert_same_object(node.resolved_type.get, type_checker.builtins.float_type)
    }

    g.test('Using get_trait_prototype()') {
      let module = new_std_module('foo')
      let type_checker = new_type_checker
      let body = parse('_INKOC.get_trait_prototype')
      let node = body.children[0]

      type_checker.check_module(module: module, ast: body)

      try assert_false(type_checker.diagnostics.errors?)
      try assert_same_object(node.resolved_type.get, type_checker.builtins.trait_type)
    }

    g.test('Using get_hasher_prototype()') {
      let module = new_std_module('foo')
      let type_checker = new_type_checker
      let body = parse('_INKOC.get_hasher_prototype')
      let node = body.children[0]

      type_checker.check_module(module: module, ast: body)

      try assert_false(type_checker.diagnostics.errors?)
      try assert_same_object(node.resolved_type.get, type_checker.builtins.hasher_type)
    }

    g.test('Using get_array_prototype()') {
      let module = new_std_module('foo')
      let type_checker = new_type_checker
      let body = parse('_INKOC.get_array_prototype')
      let node = body.children[0]

      type_checker.check_module(module: module, ast: body)

      try assert_false(type_checker.diagnostics.errors?)
      try assert_same_object(node.resolved_type.get, type_checker.builtins.array_type)
    }

    g.test('Using get_block_prototype()') {
      let module = new_std_module('foo')
      let type_checker = new_type_checker
      let body = parse('_INKOC.get_block_prototype')
      let node = body.children[0]

      type_checker.check_module(module: module, ast: body)

      try assert_false(type_checker.diagnostics.errors?)
      try assert_same_object(node.resolved_type.get, type_checker.builtins.block_type)
    }

    g.test('Using run_block()') {
      let module = new_std_module('foo')
      let type_checker = new_type_checker
      let body = parse('_INKOC.run_block(block)')
      let node = body.children[0]
      let block = ClosureType
        .new(BlockLayout.new(type_checker.builtins.integer_type.new_instance))

      body.variable_scope.symbols.define(name: 'block', type: block)
      type_checker.check_module(module: module, ast: body)

      try assert_false(type_checker.diagnostics.errors?)
      try assert_instance_of(node.resolved_type.get, AnyType)
    }

    g.test('Using array_length()') {
      let module = new_std_module('foo')
      let type_checker = new_type_checker
      let body = parse('_INKOC.array_length(array)')
      let node = body.children[0]
      let array = type_checker.builtins.array_type.new_instance

      body.variable_scope.symbols.define(name: 'array', type: array)
      type_checker.check_module(module: module, ast: body)

      try assert_false(type_checker.diagnostics.errors?)
      try assert_object_instance(
        node.resolved_type.get,
        type_checker.builtins.integer_type
      )
    }

    g.test('Using array_at()') {
      let module = new_std_module('foo')
      let type_checker = new_type_checker
      let body = parse('_INKOC.array_at')
      let node = body.children[0]

      type_checker.check_module(module: module, ast: body)

      try assert_false(type_checker.diagnostics.errors?)
      try assert_instance_of(node.resolved_type.get, AnyType)
    }

    g.test('Using array_set()') {
      let module = new_std_module('foo')
      let type_checker = new_type_checker
      let body = parse('_INKOC.array_set')
      let node = body.children[0]

      type_checker.check_module(module: module, ast: body)

      try assert_false(type_checker.diagnostics.errors?)
      try assert_instance_of(node.resolved_type.get, AnyType)
    }

    g.test('Using array_remove()') {
      let module = new_std_module('foo')
      let type_checker = new_type_checker
      let body = parse('_INKOC.array_remove')
      let node = body.children[0]

      type_checker.check_module(module: module, ast: body)

      try assert_false(type_checker.diagnostics.errors?)
      try assert_instance_of(node.resolved_type.get, AnyType)
    }

    g.test('Using string_size()') {
      let module = new_std_module('foo')
      let type_checker = new_type_checker
      let body = parse('_INKOC.string_size("foo")')
      let node = body.children[0]

      type_checker.check_module(module: module, ast: body)

      try assert_false(type_checker.diagnostics.errors?)
      try assert_object_instance(
        node.resolved_type.get,
        type_checker.builtins.integer_type
      )
    }

    g.test('Using string_length()') {
      let module = new_std_module('foo')
      let type_checker = new_type_checker
      let body = parse('_INKOC.string_length("foo")')
      let node = body.children[0]

      type_checker.check_module(module: module, ast: body)

      try assert_false(type_checker.diagnostics.errors?)
      try assert_object_instance(
        node.resolved_type.get,
        type_checker.builtins.integer_type
      )
    }

    g.test('Using string_equals()') {
      let module = new_std_module('foo')
      let type_checker = new_type_checker
      let body = parse('_INKOC.string_equals("foo", "foo")')
      let node = body.children[0]

      type_checker.check_module(module: module, ast: body)

      try assert_false(type_checker.diagnostics.errors?)
      try assert_object_instance(
        node.resolved_type.get,
        type_checker.builtins.boolean_type
      )
    }

    g.test('Using string_concat()') {
      let module = new_std_module('foo')
      let type_checker = new_type_checker
      let body = parse('_INKOC.string_concat("foo", "foo")')
      let node = body.children[0]

      type_checker.check_module(module: module, ast: body)

      try assert_false(type_checker.diagnostics.errors?)
      try assert_object_instance(
        node.resolved_type.get,
        type_checker.builtins.string_type
      )
    }

    g.test('Using string_byte()') {
      let module = new_std_module('foo')
      let type_checker = new_type_checker
      let body = parse('_INKOC.string_byte("foo", 0)')
      let node = body.children[0]

      type_checker.check_module(module: module, ast: body)

      try assert_false(type_checker.diagnostics.errors?)
      try assert_object_instance(
        node.resolved_type.get,
        type_checker.builtins.integer_type
      )
    }

    g.test('Using process_spawn()') {
      let module = new_std_module('foo')
      let type_checker = new_type_checker
      let body = parse('_INKOC.process_spawn({})')
      let node = body.children[0]
      let proc_type = type_checker.builtins.process_type

      type_checker.check_module(module: module, ast: body)

      try assert_false(type_checker.diagnostics.errors?)
      try assert_object_instance(node.resolved_type.get, proc_type)
    }

    g.test('Using process_send_message()') {
      let module = new_std_module('foo')
      let type_checker = new_type_checker
      let body = parse('_INKOC.process_send_message')
      let node = body.children[0]

      type_checker.check_module(module: module, ast: body)

      try assert_false(type_checker.diagnostics.errors?)
      try assert_instance_of(node.resolved_type.get, AnyType)
    }

    g.test('Using process_receive_message()') {
      let module = new_std_module('foo')
      let type_checker = new_type_checker
      let body = parse('_INKOC.process_receive_message')
      let node = body.children[0]

      type_checker.check_module(module: module, ast: body)

      try assert_false(type_checker.diagnostics.errors?)
      try assert_instance_of(node.resolved_type.get, AnyType)
    }

    g.test('Using process_current()') {
      let module = new_std_module('foo')
      let type_checker = new_type_checker
      let body = parse('_INKOC.process_current')
      let node = body.children[0]
      let proc_type = type_checker.builtins.process_type

      type_checker.check_module(module: module, ast: body)

      try assert_false(type_checker.diagnostics.errors?)
      try assert_object_instance(node.resolved_type.get, proc_type)
    }

    g.test('Using process_suspend_current()') {
      let module = new_std_module('foo')
      let type_checker = new_type_checker
      let body = parse('_INKOC.process_suspend_current')
      let node = body.children[0]

      type_checker.check_module(module: module, ast: body)

      try assert_false(type_checker.diagnostics.errors?)
      try assert_instance_of(node.resolved_type.get, NeverType)
    }

    g.test('Using process_terminate_current()') {
      let module = new_std_module('foo')
      let type_checker = new_type_checker
      let body = parse('_INKOC.process_terminate_current')
      let node = body.children[0]

      type_checker.check_module(module: module, ast: body)

      try assert_false(type_checker.diagnostics.errors?)
      try assert_instance_of(node.resolved_type.get, NeverType)
    }

    g.test('Using get_prototype()') {
      let module = new_std_module('foo')
      let type_checker = new_type_checker
      let body = parse('_INKOC.get_prototype')
      let node = body.children[0]

      type_checker.check_module(module: module, ast: body)

      try assert_false(type_checker.diagnostics.errors?)
      try assert_instance_of(node.resolved_type.get, AnyType)
    }

    g.test('Using close()') {
      let module = new_std_module('foo')
      let type_checker = new_type_checker
      let body = parse('_INKOC.close(10)')
      let node = body.children[0]

      type_checker.check_module(module: module, ast: body)

      try assert_false(type_checker.diagnostics.errors?)
      try assert_instance_of(node.resolved_type.get, NeverType)
    }

    g.test('Using process_set_blocking()') {
      let module = new_std_module('foo')
      let type_checker = new_type_checker
      let body = parse('_INKOC.process_set_blocking')
      let node = body.children[0]

      type_checker.check_module(module: module, ast: body)

      try assert_false(type_checker.diagnostics.errors?)
      try assert_object_instance(
        node.resolved_type.get,
        type_checker.builtins.boolean_type
      )
    }

    g.test('Using process_panic()') {
      let module = new_std_module('foo')
      let type_checker = new_type_checker
      let body = parse('_INKOC.panic("foo")')
      let node = body.children[0]

      type_checker.check_module(module: module, ast: body)

      try assert_false(type_checker.diagnostics.errors?)
      try assert_instance_of(node.resolved_type.get, NeverType)
    }

    g.test('Using exit()') {
      let module = new_std_module('foo')
      let type_checker = new_type_checker
      let body = parse('_INKOC.exit')
      let node = body.children[0]

      type_checker.check_module(module: module, ast: body)

      try assert_false(type_checker.diagnostics.errors?)
      try assert_instance_of(node.resolved_type.get, NeverType)
    }

    g.test('Using byte_array_from_array()') {
      let module = new_std_module('foo')
      let type_checker = new_type_checker
      let body = parse('_INKOC.byte_array_from_array')
      let node = body.children[0]

      type_checker.check_module(module: module, ast: body)

      try assert_false(type_checker.diagnostics.errors?)
      try assert_object_instance(
        node.resolved_type.get,
        type_checker.builtins.byte_array_type
      )
    }

    g.test('Using byte_array_set()') {
      let module = new_std_module('foo')
      let type_checker = new_type_checker
      let body = parse('_INKOC.byte_array_set')
      let node = body.children[0]

      type_checker.check_module(module: module, ast: body)

      try assert_false(type_checker.diagnostics.errors?)
      try assert_object_instance(
        node.resolved_type.get,
        type_checker.builtins.integer_type
      )
    }

    g.test('Using byte_array_at()') {
      let module = new_std_module('foo')
      let type_checker = new_type_checker
      let body = parse('_INKOC.byte_array_at')
      let node = body.children[0]

      type_checker.check_module(module: module, ast: body)

      try assert_false(type_checker.diagnostics.errors?)
      try assert_object_instance(
        node.resolved_type.get,
        type_checker.builtins.integer_type
      )
    }

    g.test('Using byte_array_remove()') {
      let module = new_std_module('foo')
      let type_checker = new_type_checker
      let body = parse('_INKOC.byte_array_remove')
      let node = body.children[0]

      type_checker.check_module(module: module, ast: body)

      try assert_false(type_checker.diagnostics.errors?)
      try assert_object_instance(
        node.resolved_type.get,
        type_checker.builtins.integer_type
      )
    }

    g.test('Using byte_array_length()') {
      let module = new_std_module('foo')
      let type_checker = new_type_checker
      let body = parse('_INKOC.byte_array_length')
      let node = body.children[0]

      type_checker.check_module(module: module, ast: body)

      try assert_false(type_checker.diagnostics.errors?)
      try assert_object_instance(
        node.resolved_type.get,
        type_checker.builtins.integer_type
      )
    }

    g.test('Using byte_array_equals()') {
      let module = new_std_module('foo')
      let type_checker = new_type_checker
      let body = parse('_INKOC.byte_array_equals')
      let node = body.children[0]

      type_checker.check_module(module: module, ast: body)

      try assert_false(type_checker.diagnostics.errors?)
      try assert_object_instance(
        node.resolved_type.get,
        type_checker.builtins.boolean_type
      )
    }

    g.test('Using byte_array_to_string()') {
      let module = new_std_module('foo')
      let type_checker = new_type_checker
      let body = parse('_INKOC.byte_array_to_string')
      let node = body.children[0]

      type_checker.check_module(module: module, ast: body)

      try assert_false(type_checker.diagnostics.errors?)
      try assert_object_instance(
        node.resolved_type.get,
        type_checker.builtins.string_type
      )
    }

    g.test('Using get_boolean_prototype()') {
      let module = new_std_module('foo')
      let type_checker = new_type_checker
      let body = parse('_INKOC.get_boolean_prototype')
      let node = body.children[0]

      type_checker.check_module(module: module, ast: body)

      try assert_false(type_checker.diagnostics.errors?)
      try assert_same_object(node.resolved_type.get, type_checker.builtins.boolean_type)
    }

    g.test('Using get_byte_array_prototype()') {
      let module = new_std_module('foo')
      let type_checker = new_type_checker
      let body = parse('_INKOC.get_byte_array_prototype')
      let node = body.children[0]

      type_checker.check_module(module: module, ast: body)

      try assert_false(type_checker.diagnostics.errors?)
      try assert_same_object(
        node.resolved_type.get,
        type_checker.builtins.byte_array_type
      )
    }

    g.test('Using get_ffi_library_prototype()') {
      let module = new_std_module('foo')
      let type_checker = new_type_checker
      let body = parse('_INKOC.get_ffi_library_prototype')
      let node = body.children[0]

      type_checker.check_module(module: module, ast: body)

      try assert_false(type_checker.diagnostics.errors?)
      try assert_same_object(
        node.resolved_type.get,
        type_checker.builtins.ffi_library_type
      )
    }

    g.test('Using get_ffi_function_prototype()') {
      let module = new_std_module('foo')
      let type_checker = new_type_checker
      let body = parse('_INKOC.get_ffi_function_prototype')
      let node = body.children[0]

      type_checker.check_module(module: module, ast: body)

      try assert_false(type_checker.diagnostics.errors?)
      try assert_same_object(
        node.resolved_type.get,
        type_checker.builtins.ffi_function_type
      )
    }

    g.test('Using get_ffi_pointer_prototype()') {
      let module = new_std_module('foo')
      let type_checker = new_type_checker
      let body = parse('_INKOC.get_ffi_pointer_prototype')
      let node = body.children[0]

      type_checker.check_module(module: module, ast: body)

      try assert_false(type_checker.diagnostics.errors?)
      try assert_same_object(
        node.resolved_type.get,
        type_checker.builtins.ffi_pointer_type
      )
    }

    g.test('Using get_ip_socket_prototype()') {
      let module = new_std_module('foo')
      let type_checker = new_type_checker
      let body = parse('_INKOC.get_ip_socket_prototype')
      let node = body.children[0]

      type_checker.check_module(module: module, ast: body)

      try assert_false(type_checker.diagnostics.errors?)
      try assert_same_object(
        node.resolved_type.get,
        type_checker.builtins.ip_socket_type
      )
    }

    g.test('Using get_unix_socket_prototype()') {
      let module = new_std_module('foo')
      let type_checker = new_type_checker
      let body = parse('_INKOC.get_unix_socket_prototype')
      let node = body.children[0]

      type_checker.check_module(module: module, ast: body)

      try assert_false(type_checker.diagnostics.errors?)
      try assert_same_object(
        node.resolved_type.get,
        type_checker.builtins.unix_socket_type
      )
    }

    g.test('Using get_process_prototype()') {
      let module = new_std_module('foo')
      let type_checker = new_type_checker
      let body = parse('_INKOC.get_process_prototype')
      let node = body.children[0]

      type_checker.check_module(module: module, ast: body)

      try assert_false(type_checker.diagnostics.errors?)
      try assert_same_object(node.resolved_type.get, type_checker.builtins.process_type)
    }

    g.test('Using get_read_only_file_prototype()') {
      let module = new_std_module('foo')
      let type_checker = new_type_checker
      let body = parse('_INKOC.get_read_only_file_prototype')
      let node = body.children[0]

      type_checker.check_module(module: module, ast: body)

      try assert_false(type_checker.diagnostics.errors?)
      try assert_same_object(
        node.resolved_type.get,
        type_checker.builtins.read_only_file_type
      )
    }

    g.test('Using get_write_only_file_prototype()') {
      let module = new_std_module('foo')
      let type_checker = new_type_checker
      let body = parse('_INKOC.get_write_only_file_prototype')
      let node = body.children[0]

      type_checker.check_module(module: module, ast: body)

      try assert_false(type_checker.diagnostics.errors?)
      try assert_same_object(
        node.resolved_type.get,
        type_checker.builtins.write_only_file_type
      )
    }

    g.test('Using get_read_write_file_prototype()') {
      let module = new_std_module('foo')
      let type_checker = new_type_checker
      let body = parse('_INKOC.get_read_write_file_prototype')
      let node = body.children[0]

      type_checker.check_module(module: module, ast: body)

      try assert_false(type_checker.diagnostics.errors?)
      try assert_same_object(
        node.resolved_type.get,
        type_checker.builtins.read_write_file_type
      )
    }

    g.test('Using generator_prototype()') {
      let module = new_std_module('foo')
      let type_checker = new_type_checker
      let body = parse('_INKOC.get_generator_prototype')
      let node = body.children[0]

      type_checker.check_module(module: module, ast: body)

      try assert_false(type_checker.diagnostics.errors?)
      try assert_same_object(
        node.resolved_type.get,
        type_checker.builtins.generator_type
      )
    }

    g.test('Using child_process_prototype()') {
      let module = new_std_module('foo')
      let type_checker = new_type_checker
      let body = parse('_INKOC.get_child_process_prototype')
      let node = body.children[0]

      type_checker.check_module(module: module, ast: body)

      try assert_false(type_checker.diagnostics.errors?)
      try assert_same_object(
        node.resolved_type.get,
        type_checker.builtins.child_process_type
      )
    }

    g.test('Using set_object_name()') {
      let module = new_std_module('foo')
      let type_checker = new_type_checker
      let body = parse('_INKOC.set_object_name')
      let node = body.children[0]

      type_checker.check_module(module: module, ast: body)

      try assert_false(type_checker.diagnostics.errors?)
      try assert_object_instance(
        node.resolved_type.get,
        type_checker.builtins.string_type
      )
    }

    g.test('Using process_add_defer_to_caller()') {
      let module = new_std_module('foo')
      let type_checker = new_type_checker
      let body = parse('_INKOC.process_add_defer_to_caller')
      let node = body.children[0]

      type_checker.check_module(module: module, ast: body)

      try assert_false(type_checker.diagnostics.errors?)
      try assert_instance_of(node.resolved_type.get, AnyType)
    }

    g.test('Using process_set_pinned()') {
      let module = new_std_module('foo')
      let type_checker = new_type_checker
      let body = parse('_INKOC.process_set_pinned')
      let node = body.children[0]

      type_checker.check_module(module: module, ast: body)

      try assert_false(type_checker.diagnostics.errors?)
      try assert_object_instance(
        node.resolved_type.get,
        type_checker.builtins.boolean_type
      )
    }

    g.test('Using process_identifier()') {
      let module = new_std_module('foo')
      let type_checker = new_type_checker
      let body = parse('_INKOC.process_identifier')
      let node = body.children[0]

      type_checker.check_module(module: module, ast: body)

      try assert_false(type_checker.diagnostics.errors?)
      try assert_object_instance(
        node.resolved_type.get,
        type_checker.builtins.integer_type
      )
    }

    g.test('Using module_load()') {
      let module = new_std_module('foo')
      let type_checker = new_type_checker
      let body = parse('_INKOC.module_load')
      let node = body.children[0]

      type_checker.check_module(module: module, ast: body)

      try assert_false(type_checker.diagnostics.errors?)
      try assert_object_instance(
        node.resolved_type.get,
        type_checker.builtins.module_type
      )
    }

    g.test('Using module_get()') {
      let module = new_std_module('foo')
      let type_checker = new_type_checker
      let body = parse('_INKOC.module_get')
      let node = body.children[0]

      type_checker.check_module(module: module, ast: body)

      let type = node.resolved_type.get

      try assert_false(type_checker.diagnostics.errors?)
      try assert_object_instance(type, type_checker.builtins.module_type)
    }

    g.test('Using generator_resume()') {
      let module = new_std_module('foo')
      let type_checker = new_type_checker
      let body = parse('_INKOC.generator_resume')
      let node = body.children[0]

      type_checker.check_module(module: module, ast: body)

      try assert_false(type_checker.diagnostics.errors?)
      try assert_instance_of(node.resolved_type.get, NeverType)
    }

    g.test('Using generator_value()') {
      let module = new_std_module('foo')
      let type_checker = new_type_checker
      let body = parse('_INKOC.generator_value')
      let node = body.children[0]

      type_checker.check_module(module: module, ast: body)

      try assert_false(type_checker.diagnostics.errors?)
      try assert_instance_of(node.resolved_type.get, AnyType)
    }

    g.test('Using generator_yielded()') {
      let module = new_std_module('foo')
      let type_checker = new_type_checker
      let body = parse('_INKOC.generator_yielded')
      let node = body.children[0]

      type_checker.check_module(module: module, ast: body)

      try assert_false(type_checker.diagnostics.errors?)
      try assert_object_instance(
        node.resolved_type.get,
        type_checker.builtins.boolean_type
      )
    }
  }

  t.group('Type-checking object constructors') do (g) {
    g.test('Creating an instance without attributes') {
      let module = new_std_module('foo')
      let type_checker = new_type_checker
      let obj_type = ClassType.new('A')
      let body = parse('A {}')
      let node = body.children[0]

      module.globals.define(name: 'A', obj_type)
      type_checker.check_module(module: module, ast: body)

      try assert_false(type_checker.diagnostics.errors?)
      try assert_object_instance(node.resolved_type.get, obj_type)
    }

    g.test('Creating an instance with attributes') {
      let module = new_std_module('foo')
      let type_checker = new_type_checker
      let obj_type = ClassType.new('A')
      let builtins = type_checker.builtins
      let int_type = builtins.integer_type
      let str_type = builtins.string_type

      obj_type.define_attribute(name: '@a', type: int_type.new_instance)
      obj_type.define_attribute(name: '@b', type: str_type.new_instance)

      let body = parse('A { @a = 10, @b = "foo" }')
      let node = body.children[0] as Constructor

      module.globals.define(name: 'A', obj_type)
      type_checker.check_module(module: module, ast: body)

      try assert_false(type_checker.diagnostics.errors?)
      try assert_object_instance(node.resolved_type.get, obj_type)

      try assert_object_instance(node.attributes[0].resolved_type.get, int_type)
      try assert_object_instance(node.attributes[1].resolved_type.get, str_type)
    }

    g.test('Creating an instance without setting all attributes') {
      let module = new_std_module('foo')
      let type_checker = new_type_checker
      let obj_type = ClassType.new('A')
      let builtins = type_checker.builtins

      obj_type
        .define_attribute(name: '@a', type: builtins.integer_type.new_instance)

      obj_type
        .define_attribute(name: '@b', type: builtins.string_type.new_instance)

      let body = parse('A { @a = 10 }')
      let node = body.children[0]

      module.globals.define(name: 'A', obj_type)
      type_checker.check_module(module: module, ast: body)

      try assert_true(type_checker.diagnostics.errors?)
      try assert_object_instance(node.resolved_type.get, obj_type)
    }

    g.test('Creating an instance while setting the same attribute twice') {
      let module = new_std_module('foo')
      let type_checker = new_type_checker
      let obj_type = ClassType.new('A')
      let builtins = type_checker.builtins

      obj_type
        .define_attribute(name: '@a', type: builtins.integer_type.new_instance)

      let body = parse('A { @a = 10, @a = 20 }')
      let node = body.children[0]

      module.globals.define(name: 'A', obj_type)
      type_checker.check_module(module: module, ast: body)

      try assert_true(type_checker.diagnostics.errors?)
      try assert_object_instance(node.resolved_type.get, obj_type)
    }

    g.test('Creating an instance while setting an undefined attribute') {
      let module = new_std_module('foo')
      let type_checker = new_type_checker
      let obj_type = ClassType.new('A')
      let body = parse('A { @a = 10 }')
      let node = body.children[0]

      module.globals.define(name: 'A', obj_type)
      type_checker.check_module(module: module, ast: body)

      try assert_true(type_checker.diagnostics.errors?)
      try assert_object_instance(node.resolved_type.get, obj_type)
    }

    g.test('Creating an instance with a generic attribute') {
      let module = new_std_module('foo')
      let type_checker = new_type_checker
      let obj_type = ClassType.new('A')
      let int_type = type_checker.builtins.integer_type
      let param = TypeParameterType.new('T')

      obj_type.define_attribute(name: '@a', type: param)

      let body = parse('A { @a = 10 }')
      let node = body.children[0]

      module.globals.define(name: 'A', obj_type)
      type_checker.check_module(module: module, ast: body)

      let type = node.resolved_type.get

      try assert_false(type_checker.diagnostics.errors?)
      try assert_object_instance(type, obj_type)
      try assert_object_instance(type.lookup_type_parameter_type(param).get, int_type)
    }

    g.test('Creating an instance using a Self type in a module method') {
      let module = new_std_module('foo')
      let type_checker = new_type_checker
      let obj_type = ClassType.new('A')
      let body = parse('def foo { Self {} }')

      module.globals.define(name: 'A', obj_type)
      type_checker.check_module(module: module, ast: body)

      try assert_true(type_checker.diagnostics.errors?)
    }

    g.test('Creating an instance using a Self type in an instance method') {
      let module = new_std_module('foo')
      let type_checker = new_type_checker
      let body = parse('class A { def foo { Self {} } }')

      type_checker.check_module(module: module, ast: body)

      try assert_true(type_checker.diagnostics.errors?)
    }

    g.test('Creating an instance using a Self type in a static method') {
      let module = new_std_module('foo')
      let type_checker = new_type_checker
      let body = parse('class A { static def foo { Self {} } }')
      let object_node = body.children[0] as DefineClass
      let method_node = object_node.body.children[0] as DefineMethod
      let node = method_node.body.children[0]

      type_checker.check_module(module: module, ast: body)

      let obj_type = module.constants['A'].type as ClassType

      try assert_false(type_checker.diagnostics.errors?)
      try assert_object_instance(node.resolved_type.get, obj_type)
    }

    g.test('Creating an instance of a built-in type') {
      let module = new_std_module('foo')
      let type_checker = new_type_checker
      let byte_array = type_checker.builtins.byte_array_type
      let body = parse('ByteArray {}')
      let node = body.children[0]

      module.globals.define(name: byte_array.name, type: byte_array)
      type_checker.check_module(module: module, ast: body)

      try assert_true(type_checker.diagnostics.errors?)
      try assert_true(node.resolved_type.get.error?)
    }
  }

  t.group('Type-checking generators') do (g) {
    g.test('Creating a generator without parentheses') {
      let module = new_std_module('foo')
      let type_checker = new_type_checker
      let int_type = type_checker.builtins.integer_type
      let gen_type = type_checker.builtins.generator_type
      let body = parse(
        'def gen => Int { yield 10 }
        gen'
      )
      let node = body.children[1] as Identifier

      module.globals.define(name: 'Int', int_type)
      type_checker.check_module(module: module, ast: body)

      let type = node.resolved_type.get

      try assert_false(type_checker.diagnostics.errors?)
      try assert_object_instance(type, gen_type)

      let vparam =
        type.lookup_type_parameter(GENERATOR_VALUE_TYPE_PARAMETER).get.type

      let eparam =
        type.lookup_type_parameter(GENERATOR_ERROR_TYPE_PARAMETER).get.type

      try assert_object_instance(type.lookup_type_parameter_type(vparam).get, int_type)
      try assert_instance_of(type.lookup_type_parameter_type(eparam).get, NeverType)
    }

    g.test('Creating a generator using parentheses') {
      let module = new_std_module('foo')
      let type_checker = new_type_checker
      let int_type = type_checker.builtins.integer_type
      let gen_type = type_checker.builtins.generator_type
      let body = parse(
        'def gen => Int { yield 10 }
        gen()'
      )
      let node = body.children[1] as Send

      module.globals.define(name: 'Int', int_type)
      type_checker.check_module(module: module, ast: body)

      let type = node.resolved_type.get

      try assert_false(type_checker.diagnostics.errors?)
      try assert_object_instance(type, gen_type)

      let vparam =
        type.lookup_type_parameter(GENERATOR_VALUE_TYPE_PARAMETER).get.type

      let eparam =
        type.lookup_type_parameter(GENERATOR_ERROR_TYPE_PARAMETER).get.type

      try assert_object_instance(type.lookup_type_parameter_type(vparam).get, int_type)
      try assert_instance_of(type.lookup_type_parameter_type(eparam).get, NeverType)
    }

    g.test('Creating a generator that throws without parentheses') {
      let module = new_std_module('foo')
      let type_checker = new_type_checker
      let int_type = type_checker.builtins.integer_type
      let gen_type = type_checker.builtins.generator_type
      let body = parse(
        'def gen !! Int => Int {
          yield 10
          throw 20
        }
        gen'
      )
      let node = body.children[1] as Identifier

      module.globals.define(name: 'Int', int_type)
      type_checker.check_module(module: module, ast: body)

      let type = node.resolved_type.get

      try assert_false(type_checker.diagnostics.errors?)
      try assert_object_instance(type, gen_type)
      try assert_true(node.resolved_throw_type.none?)

      let vparam =
        type.lookup_type_parameter(GENERATOR_VALUE_TYPE_PARAMETER).get.type

      let eparam =
        type.lookup_type_parameter(GENERATOR_ERROR_TYPE_PARAMETER).get.type

      try assert_object_instance(type.lookup_type_parameter_type(vparam).get, int_type)
      try assert_object_instance(type.lookup_type_parameter_type(eparam).get, int_type)
    }

    g.test('Creating a generator that throws with parentheses') {
      let module = new_std_module('foo')
      let type_checker = new_type_checker
      let int_type = type_checker.builtins.integer_type
      let gen_type = type_checker.builtins.generator_type
      let body = parse(
        'def gen !! Int => Int {
          yield 10
          throw 20
        }
        gen()'
      )

      let node = body.children[1] as Send

      module.globals.define(name: 'Int', int_type)
      type_checker.check_module(module: module, ast: body)

      let type = node.resolved_type.get

      try assert_false(type_checker.diagnostics.errors?)
      try assert_object_instance(type, gen_type)
      try assert_true(node.resolved_throw_type.none?)

      let vparam =
        type.lookup_type_parameter(GENERATOR_VALUE_TYPE_PARAMETER).get.type

      let eparam =
        type.lookup_type_parameter(GENERATOR_ERROR_TYPE_PARAMETER).get.type

      try assert_object_instance(type.lookup_type_parameter_type(vparam).get, int_type)
      try assert_object_instance(type.lookup_type_parameter_type(eparam).get, int_type)
    }

    g.test('Creating a generator using a global') {
      let module = new_std_module('foo')
      let type_checker = new_type_checker
      let int_type = type_checker.builtins.integer_type
      let gen_type = type_checker.builtins.generator_type
      let body = parse(
        'def gen !! Int => Int {
          yield 10
          throw 20
        }
        ::gen'
      )

      let node = body.children[1] as Global

      module.globals.define(name: 'Int', int_type)
      type_checker.check_module(module: module, ast: body)

      let type = node.resolved_type.get

      try assert_false(type_checker.diagnostics.errors?)
      try assert_object_instance(type, gen_type)
      try assert_true(node.resolved_throw_type.none?)

      let vparam =
        type.lookup_type_parameter(GENERATOR_VALUE_TYPE_PARAMETER).get.type

      let eparam =
        type.lookup_type_parameter(GENERATOR_ERROR_TYPE_PARAMETER).get.type

      try assert_object_instance(
        type.lookup_type_parameter_type(vparam).get,
        int_type
      )

      try assert_object_instance(
        type.lookup_type_parameter_type(eparam).get,
        int_type
      )
    }
  }

  t.group('Type-checking Option types created using ?T') do (g) {
    g.test('Creating an Option type when Option is undefined') {
      let module = new_std_module('foo')
      let type_checker = new_type_checker
      let int_type = type_checker.builtins.integer_type
      let body = parse('def foo(arg: ?Int) {}')
      let node = body.children[0] as DefineMethod

      module.globals.define(name: int_type.name, type: int_type)
      type_checker.check_module(module: module, ast: body)

      try assert_true(type_checker.diagnostics.errors?)
      try assert_true(node.arguments[0].resolved_type.get.error?)
    }

    g.test('Creating an Option type when Option is defined') {
      let module = new_std_module('foo')
      let type_checker = new_type_checker
      let opt_mod = ModuleType.new(OPTION_MODULE)
      let opt_type = ClassType.new('Option')
      let opt_param = TypeParameterType.new('T')

      opt_type.type_parameters.define(name: opt_param.name, type: opt_param)
      opt_mod.define_constant(name: opt_type.name, type: opt_type)
      type_checker.add_module(opt_mod)

      let int_type = type_checker.builtins.integer_type
      let body = parse('def foo(arg: ?Int) {}')
      let node = body.children[0] as DefineMethod

      module.globals.define(name: int_type.name, type: int_type)
      type_checker.check_module(module: module, ast: body)

      let arg_type = node.arguments[0].resolved_type.get

      try assert_false(type_checker.diagnostics.errors?)
      try assert_object_instance(arg_type, opt_type)

      try assert_object_instance(
        arg_type.lookup_type_parameter_type(opt_param).get,
        int_type
      )
    }
  }

  t.group('Type-checking external function definitions') do (g) {
    g.test('Defining an external function') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let int_type = type_checker.builtins.integer_type
      let flt_type = type_checker.builtins.float_type
      let str_type = type_checker.builtins.string_type
      let body = parse('extern def foo(num: Int) !! Float -> String')

      module.define_constant(name: 'Int', type: int_type)
      module.define_constant(name: 'Float', type: flt_type)
      module.define_constant(name: 'String', type: str_type)
      type_checker.check_module(module: module, ast: body)

      let method = module.lookup_method('foo').get.type as MethodType

      try assert_true(method.external_function?)
      try assert_object_instance(method.arguments['num'].type, int_type)
      try assert_object_instance(method.throw_type.get, flt_type)
      try assert_object_instance(method.return_type, str_type)
    }
  }

  t.group('Type-checking external function calls') do (g) {
    g.test('Calling an external function without a receiver') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let int_type = type_checker.builtins.integer_type
      let body = parse('foo')
      let node = body.children[0]
      let foo = MethodType.new(
        name: 'foo',
        layout: BlockLayout.new(int_type.new_instance),
        external: True
      )

      module.define_method(name: foo.name, type: foo)
      type_checker.check_module(module: module, ast: body)

      try assert_false(type_checker.diagnostics.errors?)
      try assert_object_instance(node.resolved_type.get, int_type)
    }

    g.test('Calling an external function with a receiver') {
      let module = new_module('foo')
      let type_checker = new_type_checker
      let int_type = type_checker.builtins.integer_type
      let body = parse('self.foo')
      let node = body.children[0]
      let foo = MethodType.new(
        name: 'foo',
        layout: BlockLayout.new(int_type.new_instance),
        external: True
      )

      module.define_method(name: foo.name, type: foo)
      type_checker.check_module(module: module, ast: body)

      try assert_true(type_checker.diagnostics.errors?)
      try assert_true(node.resolved_type.get.error?)
    }
  }
}
