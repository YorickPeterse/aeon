import std::debug::(self, StackFrame)
import std::process
import std::test::*
import std::test::test::(
  Failure, Group, Test, TestRequest, TestResult, ProgressFormatter
)
import std::time::Duration

def tests(t: ref Tests) {
  t.group('std::test::test::ProgressFormatter.format_location') do (g) {
    g.test('Generating the failure location description for a failed test') {
      let fmt = ProgressFormatter.new(colors: True)
      let frame = debug.stacktrace(skip: 1, limit: 0)[-1]

      try assert_equal(fmt.format_location(frame), `{frame.path}:{frame.line}`)
    }
  }

  t.group('std::test::test::ProgressFormatter.duration_unit') do (g) {
    g.test('Obtaining the time unit for the duration of a test suite') {
      let fmt = ProgressFormatter.new(colors: True)

      try assert_equal(
        fmt.duration_unit(Duration.from_milliseconds(5)),
        'milliseconds'
      )

      try assert_equal(fmt.duration_unit(Duration.from_seconds(5)), 'seconds')
    }
  }

  t.group('std::test::test::ProgressFormatter.test_suite_statistics') do (g) {
    g.test('Formatting the test suite statistics') {
      let fmt = ProgressFormatter.new(colors: False)
      let test = Test.new(
        description: 'test name',
        group_description: 'group name',
        code: fn {}
      )

      fmt.passed(TestResult.new(test, failure: Option.none))

      try assert_equal(fmt.test_suite_statistics, '1 tests, 0 failures')
    }
  }

  t.group('std::test::test::ProgressFormatter.green') do (g) {
    g.test('Generating a green string when colors are enabled') {
      let fmt = ProgressFormatter.new(colors: True)

      try assert_equal(fmt.green('hello'), "\e[32mhello\e[0m")
    }

    g.test('Generating a normal string when colors are disabled') {
      try assert_equal(
        ProgressFormatter.new(colors: False).green('hello'),
        'hello'
      )
    }
  }

  t.group('std::test::test::ProgressFormatter.red') do (g) {
    g.test('Generating a red string when colors are enabled') {
      let fmt = ProgressFormatter.new(colors: True)

      try assert_equal(fmt.red('hello'), "\e[31mhello\e[0m")
    }

    g.test('Generating a normal string when colors are disabled') {
      try assert_equal(
        ProgressFormatter.new(colors: False).red('hello'),
        'hello'
      )
    }
  }

  t.group('std::test::test::ProgressFormatter.cyan') do (g) {
    g.test('Generating a cyan string when colors are enabled') {
      let fmt = ProgressFormatter.new(colors: True)

      try assert_equal(fmt.cyan('hello'), "\e[36mhello\e[0m")
    }

    g.test('Generating a normal string when colors are disabled') {
      try assert_equal(
        ProgressFormatter.new(colors: False).cyan('hello'),
        'hello'
      )
    }
  }

  t.group('std::test::test::ProgressFormatter.bold') do (g) {
    g.test('Generating a bold string when colors are enabled') {
      let fmt = ProgressFormatter.new(colors: True)

      try assert_equal(fmt.bold('hello'), "\e[1mhello\e[0m")
    }

    g.test('Generating a normal string when colors are disabled') {
      try assert_equal(
        ProgressFormatter.new(colors: False).bold('hello'),
        'hello'
      )
    }
  }

  t.group('std::test::test::Failure.description') do (g) {
    g.test('Getting the description of a failure') {
      let failed_at = try! debug.stacktrace(skip: 1, limit: 0).pop.get
      let failure = Failure.new('foo', failed_at)

      try assert_equal(failure.description, 'foo')
    }
  }

  t.group('std::test::test::Failure.failed_at') do (g) {
    g.test('Getting the location of a failure') {
      let failed_at = StackFrame.new(path: 'test.inko', name: 'foo', line: 1)
      let failure = Failure.new('foo', failed_at)

      try assert_equal(failure.failed_at.path.to_string, 'test.inko')
    }
  }

  t.group('std::test::test::TestResult.test') do (g) {
    g.test('Getting the test of a test result') {
      let test =
        Test.new(description: 'name', group_description: 'group', code: fn {})

      let result = TestResult.new(test, failure: Option.none)

      try assert_equal(result.test.description, 'name')
    }
  }

  t.group('std::test::test::TestResult.failure') do (g) {
    g.test('Getting the test failure of a passed test') {
      let test =
        Test.new(description: 'name', group_description: 'group', code: fn {})

      let result = TestResult.new(test, failure: Option.none)

      try assert_true(result.failure.none?)
    }

    g.test('Getting the test failure of a failed test') {
      let failed_at = StackFrame.new(path: 'test.inko', name: 'foo', line: 1)
      let failure = Failure.new('foo', failed_at)
      let test =
        Test.new(description: 'name', group_description: 'group', code: fn {})
      let result = TestResult.new(test, failure: Option.some(failure))

      try assert_true(result.failure.some?)
    }
  }

  t.group('std::test::test::TestRequest.run') do (g) {
    g.test('Running a test that passes') {
      let test =
        Test.new(description: 'name', group_description: 'group', code: fn {})

      TestRequest.new(test, reply_to: process.current).run

      let result = process.receive as TestResult

      try assert_true(result.failure.none?)
    }

    g.test('Running a test that fails') {
      let code = fn {
        throw Failure.new(
          'foo',
          StackFrame.new(path: 'test.inko', name: 'foo', line: 1)
        )
      }

      let test =
        Test.new(description: 'name', group_description: 'group', code: code)

      TestRequest.new(test, reply_to: process.current).run

      let result = process.receive as TestResult

      try assert_true(result.failure.some?)
    }
  }

  t.group('std::test::test::Test.description') do (g) {
    g.test('Getting the description of a test') {
      let test = Test.new(
        description: 'foo',
        group_description: 'bar',
        code: fn {}
      )

      try assert_equal(test.description, 'foo')
    }
  }

  t.group('std::test::test::Test.group_description') do (g) {
    g.test('Getting the description of a test group') {
      let test = Test.new(
        description: 'foo',
        group_description: 'bar',
        code: fn {}
      )

      try assert_equal(test.group_description, 'bar')
    }
  }

  t.group('std::test::test::Test.defined_at') do (g) {
    g.test('Getting the location of a test') {
      let test = Test.new(
        description: 'foo',
        group_description: 'bar',
        code: fn {}
      )

      try assert_equal(test.defined_at.line, 209)
    }
  }

  t.group('std::test::test::Test.schedule') do (g) {
    g.test('Running a test') {
      let test = Test.new(
        description: 'foo',
        group_description: 'bar',
        code: fn {}
      )

      test.schedule

      let result = process.receive as TestResult

      try assert_true(result.failure.none?)
    }
  }

  t.group('std::test::test::Group.test') do (g) {
    g.test('Defining a new test') {
      let tests: Array!(Test) = Array.new
      let group = Group.new(description: 'bar', tests: tests)

      group.test('foo') {}

      try assert_equal(tests.length, 1)
      try assert_equal(tests[0].description, 'foo')
      try assert_equal(tests[0].group_description, 'bar')
    }
  }
}
