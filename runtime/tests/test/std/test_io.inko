import std::conversion::ToString
import std::io::(Error, INVALID_INPUT, NOT_FOUND, Read, Write)
import std::os::NEWLINE
import std::test::*

class Reader {
  static def new -> Self {
    Self {}
  }
}

impl Read for Reader {
  def read(into: ref ByteArray, size: Int) -> Int {
    let input = ByteArray.new(105, 110, 107, 111)
    let max = if size.positive? { size } else { input.length }
    let mut index = 0

    while index < max {
      into.push(input[index])
      index += 1
    }

    max
  }
}

class Writer {
  @buffer: Array!(String)

  static def new -> Self {
    Self { @buffer = Array.new }
  }

  def buffer -> ref Array!(String) {
    @buffer
  }
}

impl Write for Writer {
  def write_bytes(bytes: ref ByteArray) -> Int {
    0
  }

  def flush {}

  def write_string(string: ref ToString) -> Int {
    let to_write = string.to_string
    let written = to_write.length

    @buffer.push(to_write)

    written
  }
}

def tests(t: ref Tests) {
  t.group('std::io::Error.new') do (g) {
    g.test('Creating an Error for an error code') {
      let error = Error.new(NOT_FOUND)

      try assert_equal(error.code, NOT_FOUND)
    }
  }

  t.group('std::io::Error.invalid_input') do (g) {
    g.test('Creating a custom Error for invalid input') {
      let error = Error.invalid_input('testing')

      try assert_equal(error.code, INVALID_INPUT)
    }
  }

  t.group('std::io::Read.read_string') do (g) {
    g.test('Reading all bytes into a String') {
      let reader = Reader.new
      let string = try! reader.read_string

      try assert_equal(string, 'inko')
    }

    g.test('Reading a limited number of bytes into a String') {
      let reader = Reader.new
      let string = try! reader.read_string(size: 2)

      try assert_equal(string, 'in')
    }
  }

  t.group('std::io::Write.print') do (g) {
    g.test('Printing a String') {
      let writer = Writer.new
      let written = try! writer.print('inko')

      try assert_equal(written, 5)
      try assert_equal(writer.buffer, Array.new("inko\n"))
    }
  }
}
